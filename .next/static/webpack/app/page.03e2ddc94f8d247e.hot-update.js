"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/detailedStigRequirements.ts":
/*!*******************************************!*\
  !*** ./utils/detailedStigRequirements.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearStoredStigRequirements: () => (/* binding */ clearStoredStigRequirements),\n/* harmony export */   convertCsvToStigRequirement: () => (/* binding */ convertCsvToStigRequirement),\n/* harmony export */   convertStigRequirementsToMatrix: () => (/* binding */ convertStigRequirementsToMatrix),\n/* harmony export */   convertToStigRequirements: () => (/* binding */ convertToStigRequirements),\n/* harmony export */   fetchAndConvertStigRequirements: () => (/* binding */ fetchAndConvertStigRequirements),\n/* harmony export */   fetchAndConvertStigRequirementsToMatrix: () => (/* binding */ fetchAndConvertStigRequirementsToMatrix),\n/* harmony export */   getAllStoredStigRequirements: () => (/* binding */ getAllStoredStigRequirements),\n/* harmony export */   getDetailedStigRequirements: () => (/* binding */ getDetailedStigRequirements),\n/* harmony export */   getStoredStigRequirements: () => (/* binding */ getStoredStigRequirements),\n/* harmony export */   parseStigCsv: () => (/* binding */ parseStigCsv),\n/* harmony export */   stigRequirementsDatabase: () => (/* binding */ stigRequirementsDatabase),\n/* harmony export */   storeStigRequirements: () => (/* binding */ storeStigRequirements),\n/* harmony export */   uploadedStigRequirements: () => (/* binding */ uploadedStigRequirements)\n/* harmony export */ });\n/**\r\n * STIG CSV Upload and Management\r\n * Handles parsing and processing of STIG CSV files\r\n */ // Function to convert CSV STIG data to our internal format\nfunction convertCsvToStigRequirement(csvRow) {\n    // Normalize severity values\n    const normalizeSeverity = (severity)=>{\n        const sev = severity.toLowerCase();\n        if (sev === 'high' || sev === 'cat i') return 'CAT I';\n        if (sev === 'medium' || sev === 'cat ii') return 'CAT II';\n        if (sev === 'low' || sev === 'cat iii') return 'CAT III';\n        return 'CAT II'; // default\n    };\n    // Extract CCI references\n    const cciRefs = csvRow.ccis ? csvRow.ccis.split('\\n').filter((line)=>line.includes('CCI-')).map((line)=>{\n        const match = line.match(/CCI-\\d+/);\n        return match ? match[0] : '';\n    }).filter((cci)=>cci) : [\n        'CCI-000366'\n    ];\n    // Normalize status values\n    const normalizeStatus = (status)=>{\n        if (!status) return 'Not Started';\n        const stat = status.toLowerCase();\n        if (stat.includes('progress') || stat.includes('ongoing')) return 'In Progress';\n        if (stat.includes('complete') || stat.includes('done')) return 'Completed';\n        if (stat.includes('exception') || stat.includes('waiver')) return 'Exception Requested';\n        return 'Not Started';\n    };\n    return {\n        stigId: csvRow.stigId || csvRow.ruleId || 'UNKNOWN',\n        vulnId: csvRow.groupId || undefined,\n        severity: normalizeSeverity(csvRow.severity),\n        title: csvRow.ruleTitle || 'Untitled Requirement',\n        description: csvRow.discussion || 'No description provided',\n        checkText: csvRow.checkContent || 'No check procedure provided',\n        fixText: csvRow.fixText || 'No fix procedure provided',\n        applicability: 'Applicable',\n        status: normalizeStatus(csvRow.status),\n        implementationStatus: 'Open',\n        cciRef: cciRefs\n    };\n}\n// Parse CSV content and return STIG requirements\nfunction parseStigCsv(csvContent, familyId) {\n    const lines = csvContent.split('\\n');\n    if (lines.length < 2) return [];\n    // Parse header row\n    const headers = lines[0].split(',').map((h)=>h.replace(/\"/g, '').trim().toLowerCase().replace(/\\s+/g, ''));\n    const requirements = [];\n    for(let i = 1; i < lines.length; i++){\n        const line = lines[i].trim();\n        if (!line) continue;\n        // Parse CSV row (handling quoted fields)\n        const values = [];\n        let current = '';\n        let inQuotes = false;\n        for(let j = 0; j < line.length; j++){\n            const char = line[j];\n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                values.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        values.push(current.trim()); // Add the last value\n        // Create CSV STIG object\n        const csvRow = {\n            severity: 'medium',\n            stigId: '',\n            ruleTitle: '',\n            fixText: '',\n            discussion: '',\n            checkContent: ''\n        };\n        // Map values to CSV STIG object based on headers\n        headers.forEach((header, index)=>{\n            if (values[index]) {\n                const value = values[index].replace(/^\"|\"$/g, ''); // Remove surrounding quotes\n                switch(header){\n                    case 'benchmarkname':\n                        csvRow.benchmarkName = value;\n                        break;\n                    case 'benchmarkid':\n                        csvRow.benchmarkId = value;\n                        break;\n                    case 'severity':\n                        csvRow.severity = value;\n                        break;\n                    case 'stigid':\n                        csvRow.stigId = value;\n                        break;\n                    case 'ruletitle':\n                        csvRow.ruleTitle = value;\n                        break;\n                    case 'fixtext':\n                        csvRow.fixText = value;\n                        break;\n                    case 'discussion':\n                        csvRow.discussion = value;\n                        break;\n                    case 'checkcontent':\n                        csvRow.checkContent = value;\n                        break;\n                    case 'ccis':\n                        csvRow.ccis = value;\n                        break;\n                    case 'groupid':\n                        csvRow.groupId = value;\n                        break;\n                    case 'ruleid':\n                        csvRow.ruleId = value;\n                        break;\n                    case 'status':\n                        csvRow.status = value;\n                        break;\n                }\n            }\n        });\n        // Convert to our internal format\n        if (csvRow.stigId && csvRow.ruleTitle) {\n            const requirement = convertCsvToStigRequirement(csvRow);\n            if (familyId) {\n                requirement.family = familyId;\n            }\n            requirements.push(requirement);\n        }\n    }\n    return requirements;\n}\n// Database for managing uploaded STIG requirements\nconst uploadedStigRequirements = {};\n// Function to store uploaded STIG requirements\nfunction storeStigRequirements(familyId, requirements) {\n    uploadedStigRequirements[familyId] = requirements;\n}\n// Function to get stored STIG requirements\nfunction getStoredStigRequirements(familyId) {\n    return uploadedStigRequirements[familyId] || [];\n}\n// Function to get all stored STIG requirements across all families\nfunction getAllStoredStigRequirements() {\n    const allRequirements = [];\n    Object.keys(uploadedStigRequirements).forEach((familyId)=>{\n        const familyRequirements = uploadedStigRequirements[familyId];\n        familyRequirements.forEach((req, index)=>{\n            allRequirements.push({\n                id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n                family: req.family || familyId,\n                ...req,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n        });\n    });\n    return allRequirements;\n}\n// Function to clear stored STIG requirements\nfunction clearStoredStigRequirements(familyId) {\n    if (familyId) {\n        delete uploadedStigRequirements[familyId];\n    } else {\n        // Clear all\n        Object.keys(uploadedStigRequirements).forEach((key)=>{\n            delete uploadedStigRequirements[key];\n        });\n    }\n}\n/**\r\n * Get detailed STIG requirements for a given STIG family ID\r\n * Now supports uploaded CSV data\r\n */ function getDetailedStigRequirements(stigFamilyId) {\n    // Return stored uploaded requirements\n    return getStoredStigRequirements(stigFamilyId);\n}\n/**\r\n * Convert STIG requirements to the format expected by the traceability matrix\r\n */ function convertStigRequirementsToMatrix(stigFamilyIds) {\n    console.log('Converting STIG requirements for families:', stigFamilyIds);\n    const allRequirements = [];\n    stigFamilyIds.forEach((familyId)=>{\n        const detailedRequirements = getStoredStigRequirements(familyId);\n        console.log(\"Found \".concat(detailedRequirements.length, \" requirements for family: \").concat(familyId));\n        detailedRequirements.forEach((req, index)=>{\n            allRequirements.push({\n                id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n                ...req,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n        });\n    });\n    console.log(\"Total converted requirements: \".concat(allRequirements.length));\n    return allRequirements;\n}\n// New: Fetch STIG CSV from stigviewer and convert to requirements\nasync function fetchAndConvertStigRequirements(familyIds) {\n    // Use internal API route to fetch multiple STIG CSVs (avoids CORS/network errors)\n    const allRequirements = [];\n    const param = encodeURIComponent(familyIds.join(','));\n    try {\n        const apiRes = await fetch(\"/api/fetch-stig-csv?familyIds=\".concat(param));\n        if (!apiRes.ok) {\n            console.error(\"Failed to fetch STIG CSVs from API: \".concat(apiRes.status));\n            return allRequirements;\n        }\n        const csvResults = await apiRes.json();\n        for (const familyId of familyIds){\n            const csvText = csvResults[familyId];\n            if (csvText) {\n                const detailed = parseStigCsv(csvText, familyId);\n                allRequirements.push(...detailed);\n            } else {\n                console.error(\"No CSV data returned for \".concat(familyId));\n            }\n        }\n    } catch (err) {\n        console.error('Error fetching STIG CSVs via API:', err);\n    }\n    return allRequirements;\n}\n// New: Fetch and convert STIG CSVs directly to the matrix format (StigRequirement[])\nasync function fetchAndConvertStigRequirementsToMatrix(familyIds) {\n    const detailed = await fetchAndConvertStigRequirements(familyIds);\n    const all = [];\n    detailed.forEach((req, index)=>{\n        const familyId = req.family || 'unknown';\n        all.push({\n            id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n            ...req,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        });\n    });\n    return all;\n}\n// Legacy function name support\nconst convertToStigRequirements = convertStigRequirementsToMatrix;\n// Empty database for backward compatibility\nconst stigRequirementsDatabase = {};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2RldGFpbGVkU3RpZ1JlcXVpcmVtZW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBb0RELDJEQUEyRDtBQUNwRCxTQUFTQSw0QkFBNEJDLE1BQTBCO0lBQ3BFLDRCQUE0QjtJQUM1QixNQUFNQyxvQkFBb0IsQ0FBQ0M7UUFDekIsTUFBTUMsTUFBTUQsU0FBU0UsV0FBVztRQUNoQyxJQUFJRCxRQUFRLFVBQVVBLFFBQVEsU0FBUyxPQUFPO1FBQzlDLElBQUlBLFFBQVEsWUFBWUEsUUFBUSxVQUFVLE9BQU87UUFDakQsSUFBSUEsUUFBUSxTQUFTQSxRQUFRLFdBQVcsT0FBTztRQUMvQyxPQUFPLFVBQVUsVUFBVTtJQUM3QjtJQUVBLHlCQUF5QjtJQUN6QixNQUFNRSxVQUFVTCxPQUFPTSxJQUFJLEdBQ3pCTixPQUFPTSxJQUFJLENBQUNDLEtBQUssQ0FBQyxNQUFNQyxNQUFNLENBQUNDLENBQUFBLE9BQVFBLEtBQUtDLFFBQVEsQ0FBQyxTQUFTQyxHQUFHLENBQUNGLENBQUFBO1FBQ2hFLE1BQU1HLFFBQVFILEtBQUtHLEtBQUssQ0FBQztRQUN6QixPQUFPQSxRQUFRQSxLQUFLLENBQUMsRUFBRSxHQUFHO0lBQzVCLEdBQUdKLE1BQU0sQ0FBQ0ssQ0FBQUEsTUFBT0EsT0FBTztRQUFDO0tBQWE7SUFFeEMsMEJBQTBCO0lBQzFCLE1BQU1DLGtCQUFrQixDQUFDQztRQUN2QixJQUFJLENBQUNBLFFBQVEsT0FBTztRQUNwQixNQUFNQyxPQUFPRCxPQUFPWCxXQUFXO1FBQy9CLElBQUlZLEtBQUtOLFFBQVEsQ0FBQyxlQUFlTSxLQUFLTixRQUFRLENBQUMsWUFBWSxPQUFPO1FBQ2xFLElBQUlNLEtBQUtOLFFBQVEsQ0FBQyxlQUFlTSxLQUFLTixRQUFRLENBQUMsU0FBUyxPQUFPO1FBQy9ELElBQUlNLEtBQUtOLFFBQVEsQ0FBQyxnQkFBZ0JNLEtBQUtOLFFBQVEsQ0FBQyxXQUFX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QUFDeEIsTUFBTUMsNEJBQTRCckIsZ0NBQWdDO0FBRXpFLDRDQUE0QztBQUNyQyxNQUFNc0IsMkJBQThFLENBQUMsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxyb25uaVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2plY3RzXFxTUlRNLXRvb2xcXHV0aWxzXFxkZXRhaWxlZFN0aWdSZXF1aXJlbWVudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFNUSUcgQ1NWIFVwbG9hZCBhbmQgTWFuYWdlbWVudFxyXG4gKiBIYW5kbGVzIHBhcnNpbmcgYW5kIHByb2Nlc3Npbmcgb2YgU1RJRyBDU1YgZmlsZXNcclxuICovXHJcblxyXG5pbXBvcnQgeyBTdGlnUmVxdWlyZW1lbnQgfSBmcm9tICcuLi90eXBlcy9zcnRtJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnQgZXh0ZW5kcyBPbWl0PFN0aWdSZXF1aXJlbWVudCwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+IHtcclxuICAvLyBBbGwgb3RoZXIgZmllbGRzIGZyb20gU3RpZ1JlcXVpcmVtZW50IGludGVyZmFjZVxyXG4gIGZhbWlseT86IHN0cmluZzsgLy8gQWRkIGZhbWlseSB0cmFja2luZ1xyXG59XHJcblxyXG4vLyBDU1YgVXBsb2FkIFN1cHBvcnQgZm9yIFNUSUcgUmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ3N2U3RpZ1JlcXVpcmVtZW50IHtcclxuICBiZW5jaG1hcmtOYW1lPzogc3RyaW5nO1xyXG4gIGJlbmNobWFya0lkPzogc3RyaW5nO1xyXG4gIHJlbGVhc2VJbmZvPzogc3RyaW5nO1xyXG4gIHZlcnNpb24/OiBzdHJpbmc7XHJcbiAgZ3JvdXBJZD86IHN0cmluZztcclxuICBzZXZlcml0eTogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JyB8ICdDQVQgSScgfCAnQ0FUIElJJyB8ICdDQVQgSUlJJztcclxuICBydWxlSWQ/OiBzdHJpbmc7XHJcbiAgc3RpZ0lkOiBzdHJpbmc7XHJcbiAgY2xhc3NpZmljYXRpb24/OiBzdHJpbmc7XHJcbiAgYXNzZXRQb3N0dXJlPzogc3RyaW5nO1xyXG4gIHNyZ0lkPzogc3RyaW5nO1xyXG4gIHJ1bGVUaXRsZTogc3RyaW5nO1xyXG4gIGZpeFRleHQ6IHN0cmluZztcclxuICBkaXNjdXNzaW9uOiBzdHJpbmc7XHJcbiAgY2Npcz86IHN0cmluZztcclxuICBsZWdhY3lJZHM/OiBzdHJpbmc7XHJcbiAgY2hlY2tDb250ZW50OiBzdHJpbmc7XHJcbiAgY2hlY2tDb250ZW50UmVmPzogc3RyaW5nO1xyXG4gIGlhQ29udHJvbHM/OiBzdHJpbmc7XHJcbiAgd2VpZ2h0Pzogc3RyaW5nO1xyXG4gIGZhbHNlUG9zaXRpdmVzPzogc3RyaW5nO1xyXG4gIGZhbHNlTmVnYXRpdmVzPzogc3RyaW5nO1xyXG4gIGRvY3VtZW50YWJsZT86IHN0cmluZztcclxuICBzZWN1cml0eU92ZXJyaWRlR3VpZGFuY2U/OiBzdHJpbmc7XHJcbiAgcG90ZW50aWFsSW1wYWN0cz86IHN0cmluZztcclxuICB0aGlyZFBhcnR5VG9vbHM/OiBzdHJpbmc7XHJcbiAgcmVzcG9uc2liaWxpdHk/OiBzdHJpbmc7XHJcbiAgbWl0aWdhdGlvbnM/OiBzdHJpbmc7XHJcbiAgbWl0aWdhdGlvbkNvbnRyb2w/OiBzdHJpbmc7XHJcbiAgc3RhdHVzPzogc3RyaW5nO1xyXG4gIGNvbW1lbnRzPzogc3RyaW5nO1xyXG4gIGZpbmRpbmdEZXRhaWxzPzogc3RyaW5nO1xyXG4gIHNldmVyaXR5T3ZlcnJpZGU/OiBzdHJpbmc7XHJcbiAgc2V2ZXJpdHlPdmVycmlkZVJlYXNvbj86IHN0cmluZztcclxuICBmcWRuPzogc3RyaW5nO1xyXG4gIGlwQWRkcmVzcz86IHN0cmluZztcclxuICBtYWNBZGRyZXNzPzogc3RyaW5nO1xyXG4gIG5hbWU/OiBzdHJpbmc7XHJcbiAgdGVjaG5vbG9neUFyZWE/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGNvbnZlcnQgQ1NWIFNUSUcgZGF0YSB0byBvdXIgaW50ZXJuYWwgZm9ybWF0XHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0Q3N2VG9TdGlnUmVxdWlyZW1lbnQoY3N2Um93OiBDc3ZTdGlnUmVxdWlyZW1lbnQpOiBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudCB7XHJcbiAgLy8gTm9ybWFsaXplIHNldmVyaXR5IHZhbHVlc1xyXG4gIGNvbnN0IG5vcm1hbGl6ZVNldmVyaXR5ID0gKHNldmVyaXR5OiBzdHJpbmcpOiAnQ0FUIEknIHwgJ0NBVCBJSScgfCAnQ0FUIElJSScgPT4ge1xyXG4gICAgY29uc3Qgc2V2ID0gc2V2ZXJpdHkudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmIChzZXYgPT09ICdoaWdoJyB8fCBzZXYgPT09ICdjYXQgaScpIHJldHVybiAnQ0FUIEknO1xyXG4gICAgaWYgKHNldiA9PT0gJ21lZGl1bScgfHwgc2V2ID09PSAnY2F0IGlpJykgcmV0dXJuICdDQVQgSUknO1xyXG4gICAgaWYgKHNldiA9PT0gJ2xvdycgfHwgc2V2ID09PSAnY2F0IGlpaScpIHJldHVybiAnQ0FUIElJSSc7XHJcbiAgICByZXR1cm4gJ0NBVCBJSSc7IC8vIGRlZmF1bHRcclxuICB9O1xyXG5cclxuICAvLyBFeHRyYWN0IENDSSByZWZlcmVuY2VzXHJcbiAgY29uc3QgY2NpUmVmcyA9IGNzdlJvdy5jY2lzID8gXHJcbiAgICBjc3ZSb3cuY2Npcy5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS5pbmNsdWRlcygnQ0NJLScpKS5tYXAobGluZSA9PiB7XHJcbiAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaCgvQ0NJLVxcZCsvKTtcclxuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcclxuICAgIH0pLmZpbHRlcihjY2kgPT4gY2NpKSA6IFsnQ0NJLTAwMDM2NiddO1xyXG5cclxuICAvLyBOb3JtYWxpemUgc3RhdHVzIHZhbHVlc1xyXG4gIGNvbnN0IG5vcm1hbGl6ZVN0YXR1cyA9IChzdGF0dXM/OiBzdHJpbmcpOiAnTm90IFN0YXJ0ZWQnIHwgJ0luIFByb2dyZXNzJyB8ICdDb21wbGV0ZWQnIHwgJ0V4Y2VwdGlvbiBSZXF1ZXN0ZWQnID0+IHtcclxuICAgIGlmICghc3RhdHVzKSByZXR1cm4gJ05vdCBTdGFydGVkJztcclxuICAgIGNvbnN0IHN0YXQgPSBzdGF0dXMudG9Mb3dlckNhc2UoKTtcclxuICAgIGlmIChzdGF0LmluY2x1ZGVzKCdwcm9ncmVzcycpIHx8IHN0YXQuaW5jbHVkZXMoJ29uZ29pbmcnKSkgcmV0dXJuICdJbiBQcm9ncmVzcyc7XHJcbiAgICBpZiAoc3RhdC5pbmNsdWRlcygnY29tcGxldGUnKSB8fCBzdGF0LmluY2x1ZGVzKCdkb25lJykpIHJldHVybiAnQ29tcGxldGVkJztcclxuICAgIGlmIChzdGF0LmluY2x1ZGVzKCdleGNlcHRpb24nKSB8fCBzdGF0LmluY2x1ZGVzKCd3YWl2ZXInKSkgcmV0dXJuICdFeGNlcHRpb24gUmVxdWVzdGVkJztcclxuICAgIHJldHVybiAnTm90IFN0YXJ0ZWQnO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzdGlnSWQ6IGNzdlJvdy5zdGlnSWQgfHwgY3N2Um93LnJ1bGVJZCB8fCAnVU5LTk9XTicsXHJcbiAgICB2dWxuSWQ6IGNzdlJvdy5ncm91cElkIHx8IHVuZGVmaW5lZCxcclxuICAgIHNldmVyaXR5OiBub3JtYWxpemVTZXZlcml0eShjc3ZSb3cuc2V2ZXJpdHkpLFxyXG4gICAgdGl0bGU6IGNzdlJvdy5ydWxlVGl0bGUgfHwgJ1VudGl0bGVkIFJlcXVpcmVtZW50JyxcclxuICAgIGRlc2NyaXB0aW9uOiBjc3ZSb3cuZGlzY3Vzc2lvbiB8fCAnTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQnLFxyXG4gICAgY2hlY2tUZXh0OiBjc3ZSb3cuY2hlY2tDb250ZW50IHx8ICdObyBjaGVjayBwcm9jZWR1cmUgcHJvdmlkZWQnLFxyXG4gICAgZml4VGV4dDogY3N2Um93LmZpeFRleHQgfHwgJ05vIGZpeCBwcm9jZWR1cmUgcHJvdmlkZWQnLFxyXG4gICAgYXBwbGljYWJpbGl0eTogJ0FwcGxpY2FibGUnLFxyXG4gICAgc3RhdHVzOiBub3JtYWxpemVTdGF0dXMoY3N2Um93LnN0YXR1cyksXHJcbiAgICBpbXBsZW1lbnRhdGlvblN0YXR1czogJ09wZW4nLFxyXG4gICAgY2NpUmVmOiBjY2lSZWZzXHJcbiAgfTtcclxufVxyXG5cclxuLy8gUGFyc2UgQ1NWIGNvbnRlbnQgYW5kIHJldHVybiBTVElHIHJlcXVpcmVtZW50c1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdGlnQ3N2KGNzdkNvbnRlbnQ6IHN0cmluZywgZmFtaWx5SWQ/OiBzdHJpbmcpOiBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudFtdIHtcclxuICBjb25zdCBsaW5lcyA9IGNzdkNvbnRlbnQuc3BsaXQoJ1xcbicpO1xyXG4gIGlmIChsaW5lcy5sZW5ndGggPCAyKSByZXR1cm4gW107XHJcblxyXG4gIC8vIFBhcnNlIGhlYWRlciByb3dcclxuICBjb25zdCBoZWFkZXJzID0gbGluZXNbMF0uc3BsaXQoJywnKS5tYXAoaCA9PiBoLnJlcGxhY2UoL1wiL2csICcnKS50cmltKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcnKSk7XHJcbiAgXHJcbiAgY29uc3QgcmVxdWlyZW1lbnRzOiBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudFtdID0gW107XHJcblxyXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XHJcbiAgICBpZiAoIWxpbmUpIGNvbnRpbnVlO1xyXG5cclxuICAgIC8vIFBhcnNlIENTViByb3cgKGhhbmRsaW5nIHF1b3RlZCBmaWVsZHMpXHJcbiAgICBjb25zdCB2YWx1ZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBsZXQgY3VycmVudCA9ICcnO1xyXG4gICAgbGV0IGluUXVvdGVzID0gZmFsc2U7XHJcblxyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIGNvbnN0IGNoYXIgPSBsaW5lW2pdO1xyXG4gICAgICBcclxuICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcclxuICAgICAgICBpblF1b3RlcyA9ICFpblF1b3RlcztcclxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLCcgJiYgIWluUXVvdGVzKSB7XHJcbiAgICAgICAgdmFsdWVzLnB1c2goY3VycmVudC50cmltKCkpO1xyXG4gICAgICAgIGN1cnJlbnQgPSAnJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyZW50ICs9IGNoYXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhbHVlcy5wdXNoKGN1cnJlbnQudHJpbSgpKTsgLy8gQWRkIHRoZSBsYXN0IHZhbHVlXHJcblxyXG4gICAgLy8gQ3JlYXRlIENTViBTVElHIG9iamVjdFxyXG4gICAgY29uc3QgY3N2Um93OiBDc3ZTdGlnUmVxdWlyZW1lbnQgPSB7XHJcbiAgICAgIHNldmVyaXR5OiAnbWVkaXVtJyBhcyBjb25zdCxcclxuICAgICAgc3RpZ0lkOiAnJyxcclxuICAgICAgcnVsZVRpdGxlOiAnJyxcclxuICAgICAgZml4VGV4dDogJycsXHJcbiAgICAgIGRpc2N1c3Npb246ICcnLFxyXG4gICAgICBjaGVja0NvbnRlbnQ6ICcnXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE1hcCB2YWx1ZXMgdG8gQ1NWIFNUSUcgb2JqZWN0IGJhc2VkIG9uIGhlYWRlcnNcclxuICAgIGhlYWRlcnMuZm9yRWFjaCgoaGVhZGVyLCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAodmFsdWVzW2luZGV4XSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKTsgLy8gUmVtb3ZlIHN1cnJvdW5kaW5nIHF1b3Rlc1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCAoaGVhZGVyKSB7XHJcbiAgICAgICAgICBjYXNlICdiZW5jaG1hcmtuYW1lJzpcclxuICAgICAgICAgICAgY3N2Um93LmJlbmNobWFya05hbWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdiZW5jaG1hcmtpZCc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5iZW5jaG1hcmtJZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3NldmVyaXR5JzpcclxuICAgICAgICAgICAgY3N2Um93LnNldmVyaXR5ID0gdmFsdWUgYXMgYW55O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3N0aWdpZCc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5zdGlnSWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdydWxldGl0bGUnOlxyXG4gICAgICAgICAgICBjc3ZSb3cucnVsZVRpdGxlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnZml4dGV4dCc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5maXhUZXh0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnZGlzY3Vzc2lvbic6XHJcbiAgICAgICAgICAgIGNzdlJvdy5kaXNjdXNzaW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnY2hlY2tjb250ZW50JzpcclxuICAgICAgICAgICAgY3N2Um93LmNoZWNrQ29udGVudCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2NjaXMnOlxyXG4gICAgICAgICAgICBjc3ZSb3cuY2NpcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2dyb3VwaWQnOlxyXG4gICAgICAgICAgICBjc3ZSb3cuZ3JvdXBJZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3J1bGVpZCc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5ydWxlSWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdzdGF0dXMnOlxyXG4gICAgICAgICAgICBjc3ZSb3cuc3RhdHVzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ29udmVydCB0byBvdXIgaW50ZXJuYWwgZm9ybWF0XHJcbiAgICBpZiAoY3N2Um93LnN0aWdJZCAmJiBjc3ZSb3cucnVsZVRpdGxlKSB7XHJcbiAgICAgIGNvbnN0IHJlcXVpcmVtZW50ID0gY29udmVydENzdlRvU3RpZ1JlcXVpcmVtZW50KGNzdlJvdyk7XHJcbiAgICAgIGlmIChmYW1pbHlJZCkge1xyXG4gICAgICAgIHJlcXVpcmVtZW50LmZhbWlseSA9IGZhbWlseUlkO1xyXG4gICAgICB9XHJcbiAgICAgIHJlcXVpcmVtZW50cy5wdXNoKHJlcXVpcmVtZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXF1aXJlbWVudHM7XHJcbn1cclxuXHJcbi8vIERhdGFiYXNlIGZvciBtYW5hZ2luZyB1cGxvYWRlZCBTVElHIHJlcXVpcmVtZW50c1xyXG5leHBvcnQgY29uc3QgdXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzOiB7IFtmYW1pbHlJZDogc3RyaW5nXTogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSB9ID0ge307XHJcblxyXG4vLyBGdW5jdGlvbiB0byBzdG9yZSB1cGxvYWRlZCBTVElHIHJlcXVpcmVtZW50c1xyXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVTdGlnUmVxdWlyZW1lbnRzKGZhbWlseUlkOiBzdHJpbmcsIHJlcXVpcmVtZW50czogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSkge1xyXG4gIHVwbG9hZGVkU3RpZ1JlcXVpcmVtZW50c1tmYW1pbHlJZF0gPSByZXF1aXJlbWVudHM7XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGdldCBzdG9yZWQgU1RJRyByZXF1aXJlbWVudHNcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0b3JlZFN0aWdSZXF1aXJlbWVudHMoZmFtaWx5SWQ6IHN0cmluZyk6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10ge1xyXG4gIHJldHVybiB1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHNbZmFtaWx5SWRdIHx8IFtdO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBnZXQgYWxsIHN0b3JlZCBTVElHIHJlcXVpcmVtZW50cyBhY3Jvc3MgYWxsIGZhbWlsaWVzXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxTdG9yZWRTdGlnUmVxdWlyZW1lbnRzKCk6IFN0aWdSZXF1aXJlbWVudFtdIHtcclxuICBjb25zdCBhbGxSZXF1aXJlbWVudHM6IFN0aWdSZXF1aXJlbWVudFtdID0gW107XHJcbiAgXHJcbiAgT2JqZWN0LmtleXModXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzKS5mb3JFYWNoKGZhbWlseUlkID0+IHtcclxuICAgIGNvbnN0IGZhbWlseVJlcXVpcmVtZW50cyA9IHVwbG9hZGVkU3RpZ1JlcXVpcmVtZW50c1tmYW1pbHlJZF07XHJcbiAgICBmYW1pbHlSZXF1aXJlbWVudHMuZm9yRWFjaCgocmVxLCBpbmRleCkgPT4ge1xyXG4gICAgICBhbGxSZXF1aXJlbWVudHMucHVzaCh7XHJcbiAgICAgICAgaWQ6IGAke2ZhbWlseUlkfS0ke0RhdGUubm93KCl9LSR7aW5kZXh9YCxcclxuICAgICAgICBmYW1pbHk6IHJlcS5mYW1pbHkgfHwgZmFtaWx5SWQsIC8vIFVzZSB0aGUgZmFtaWx5IGZyb20gcmVxdWlyZW1lbnQgb3IgZmFsbGJhY2sgdG8gZmFtaWx5SWRcclxuICAgICAgICAuLi5yZXEsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIFxyXG4gIHJldHVybiBhbGxSZXF1aXJlbWVudHM7XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGNsZWFyIHN0b3JlZCBTVElHIHJlcXVpcmVtZW50c1xyXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJTdG9yZWRTdGlnUmVxdWlyZW1lbnRzKGZhbWlseUlkPzogc3RyaW5nKSB7XHJcbiAgaWYgKGZhbWlseUlkKSB7XHJcbiAgICBkZWxldGUgdXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzW2ZhbWlseUlkXTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gQ2xlYXIgYWxsXHJcbiAgICBPYmplY3Qua2V5cyh1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgZGVsZXRlIHVwbG9hZGVkU3RpZ1JlcXVpcmVtZW50c1trZXldO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGRldGFpbGVkIFNUSUcgcmVxdWlyZW1lbnRzIGZvciBhIGdpdmVuIFNUSUcgZmFtaWx5IElEXHJcbiAqIE5vdyBzdXBwb3J0cyB1cGxvYWRlZCBDU1YgZGF0YVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERldGFpbGVkU3RpZ1JlcXVpcmVtZW50cyhzdGlnRmFtaWx5SWQ6IHN0cmluZyk6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10ge1xyXG4gIC8vIFJldHVybiBzdG9yZWQgdXBsb2FkZWQgcmVxdWlyZW1lbnRzXHJcbiAgcmV0dXJuIGdldFN0b3JlZFN0aWdSZXF1aXJlbWVudHMoc3RpZ0ZhbWlseUlkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgU1RJRyByZXF1aXJlbWVudHMgdG8gdGhlIGZvcm1hdCBleHBlY3RlZCBieSB0aGUgdHJhY2VhYmlsaXR5IG1hdHJpeFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRTdGlnUmVxdWlyZW1lbnRzVG9NYXRyaXgoc3RpZ0ZhbWlseUlkczogc3RyaW5nW10pOiBTdGlnUmVxdWlyZW1lbnRbXSB7XHJcbiAgY29uc29sZS5sb2coJ0NvbnZlcnRpbmcgU1RJRyByZXF1aXJlbWVudHMgZm9yIGZhbWlsaWVzOicsIHN0aWdGYW1pbHlJZHMpO1xyXG4gIFxyXG4gIGNvbnN0IGFsbFJlcXVpcmVtZW50czogU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuICBcclxuICBzdGlnRmFtaWx5SWRzLmZvckVhY2goZmFtaWx5SWQgPT4ge1xyXG4gICAgY29uc3QgZGV0YWlsZWRSZXF1aXJlbWVudHMgPSBnZXRTdG9yZWRTdGlnUmVxdWlyZW1lbnRzKGZhbWlseUlkKTtcclxuICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2RldGFpbGVkUmVxdWlyZW1lbnRzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZvciBmYW1pbHk6ICR7ZmFtaWx5SWR9YCk7XHJcbiAgICBcclxuICAgIGRldGFpbGVkUmVxdWlyZW1lbnRzLmZvckVhY2goKHJlcSwgaW5kZXgpID0+IHtcclxuICAgICAgYWxsUmVxdWlyZW1lbnRzLnB1c2goe1xyXG4gICAgICAgIGlkOiBgJHtmYW1pbHlJZH0tJHtEYXRlLm5vdygpfS0ke2luZGV4fWAsXHJcbiAgICAgICAgLi4ucmVxLFxyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcclxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICBcclxuICBjb25zb2xlLmxvZyhgVG90YWwgY29udmVydGVkIHJlcXVpcmVtZW50czogJHthbGxSZXF1aXJlbWVudHMubGVuZ3RofWApO1xyXG4gIHJldHVybiBhbGxSZXF1aXJlbWVudHM7XHJcbn1cclxuXHJcbi8vIE5ldzogRmV0Y2ggU1RJRyBDU1YgZnJvbSBzdGlndmlld2VyIGFuZCBjb252ZXJ0IHRvIHJlcXVpcmVtZW50c1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRDb252ZXJ0U3RpZ1JlcXVpcmVtZW50cyhmYW1pbHlJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxEZXRhaWxlZFN0aWdSZXF1aXJlbWVudFtdPiB7XHJcbiAgLy8gVXNlIGludGVybmFsIEFQSSByb3V0ZSB0byBmZXRjaCBtdWx0aXBsZSBTVElHIENTVnMgKGF2b2lkcyBDT1JTL25ldHdvcmsgZXJyb3JzKVxyXG4gIGNvbnN0IGFsbFJlcXVpcmVtZW50czogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG4gIGNvbnN0IHBhcmFtID0gZW5jb2RlVVJJQ29tcG9uZW50KGZhbWlseUlkcy5qb2luKCcsJykpO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBhcGlSZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9mZXRjaC1zdGlnLWNzdj9mYW1pbHlJZHM9JHtwYXJhbX1gKTtcclxuICAgIGlmICghYXBpUmVzLm9rKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBmZXRjaCBTVElHIENTVnMgZnJvbSBBUEk6ICR7YXBpUmVzLnN0YXR1c31gKTtcclxuICAgICAgcmV0dXJuIGFsbFJlcXVpcmVtZW50cztcclxuICAgIH1cclxuICAgIGNvbnN0IGNzdlJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBhd2FpdCBhcGlSZXMuanNvbigpO1xyXG4gICAgZm9yIChjb25zdCBmYW1pbHlJZCBvZiBmYW1pbHlJZHMpIHtcclxuICAgICAgY29uc3QgY3N2VGV4dCA9IGNzdlJlc3VsdHNbZmFtaWx5SWRdO1xyXG4gICAgICBpZiAoY3N2VGV4dCkge1xyXG4gICAgICAgIGNvbnN0IGRldGFpbGVkID0gcGFyc2VTdGlnQ3N2KGNzdlRleHQsIGZhbWlseUlkKTtcclxuICAgICAgICBhbGxSZXF1aXJlbWVudHMucHVzaCguLi5kZXRhaWxlZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgTm8gQ1NWIGRhdGEgcmV0dXJuZWQgZm9yICR7ZmFtaWx5SWR9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIFNUSUcgQ1NWcyB2aWEgQVBJOicsIGVycik7XHJcbiAgfVxyXG4gIHJldHVybiBhbGxSZXF1aXJlbWVudHM7XHJcbn1cclxuLy8gTmV3OiBGZXRjaCBhbmQgY29udmVydCBTVElHIENTVnMgZGlyZWN0bHkgdG8gdGhlIG1hdHJpeCBmb3JtYXQgKFN0aWdSZXF1aXJlbWVudFtdKVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRDb252ZXJ0U3RpZ1JlcXVpcmVtZW50c1RvTWF0cml4KGZhbWlseUlkczogc3RyaW5nW10pOiBQcm9taXNlPFN0aWdSZXF1aXJlbWVudFtdPiB7XHJcbiAgY29uc3QgZGV0YWlsZWQgPSBhd2FpdCBmZXRjaEFuZENvbnZlcnRTdGlnUmVxdWlyZW1lbnRzKGZhbWlseUlkcyk7XHJcbiAgY29uc3QgYWxsOiBTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG4gIGRldGFpbGVkLmZvckVhY2goKHJlcSwgaW5kZXgpID0+IHtcclxuICAgIGNvbnN0IGZhbWlseUlkID0gcmVxLmZhbWlseSB8fCAndW5rbm93bic7XHJcbiAgICBhbGwucHVzaCh7XHJcbiAgICAgIGlkOiBgJHtmYW1pbHlJZH0tJHtEYXRlLm5vdygpfS0ke2luZGV4fWAsXHJcbiAgICAgIC4uLnJlcSxcclxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBhbGw7XHJcbn1cclxuXHJcbi8vIExlZ2FjeSBmdW5jdGlvbiBuYW1lIHN1cHBvcnRcclxuZXhwb3J0IGNvbnN0IGNvbnZlcnRUb1N0aWdSZXF1aXJlbWVudHMgPSBjb252ZXJ0U3RpZ1JlcXVpcmVtZW50c1RvTWF0cml4O1xyXG5cclxuLy8gRW1wdHkgZGF0YWJhc2UgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuZXhwb3J0IGNvbnN0IHN0aWdSZXF1aXJlbWVudHNEYXRhYmFzZTogeyBbZmFtaWx5SWQ6IHN0cmluZ106IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10gfSA9IHt9OyJdLCJuYW1lcyI6WyJjb252ZXJ0Q3N2VG9TdGlnUmVxdWlyZW1lbnQiLCJjc3ZSb3ciLCJub3JtYWxpemVTZXZlcml0eSIsInNldmVyaXR5Iiwic2V2IiwidG9Mb3dlckNhc2UiLCJjY2lSZWZzIiwiY2NpcyIsInNwbGl0IiwiZmlsdGVyIiwibGluZSIsImluY2x1ZGVzIiwibWFwIiwibWF0Y2giLCJjY2kiLCJub3JtYWxpemVTdGF0dXMiLCJzdGF0dXMiLCJzdGF0Iiwic3RpZ0lkIiwicnVsZUlkIiwidnVsbklkIiwiZ3JvdXBJZCIsInVuZGVmaW5lZCIsInRpdGxlIiwicnVsZVRpdGxlIiwiZGVzY3JpcHRpb24iLCJkaXNjdXNzaW9uIiwiY2hlY2tUZXh0IiwiY2hlY2tDb250ZW50IiwiZml4VGV4dCIsImFwcGxpY2FiaWxpdHkiLCJpbXBsZW1lbnRhdGlvblN0YXR1cyIsImNjaVJlZiIsInBhcnNlU3RpZ0NzdiIsImNzdkNvbnRlbnQiLCJmYW1pbHlJZCIsImxpbmVzIiwibGVuZ3RoIiwiaGVhZGVycyIsImgiLCJyZXBsYWNlIiwidHJpbSIsInJlcXVpcmVtZW50cyIsImkiLCJ2YWx1ZXMiLCJjdXJyZW50IiwiaW5RdW90ZXMiLCJqIiwiY2hhciIsInB1c2giLCJmb3JFYWNoIiwiaGVhZGVyIiwiaW5kZXgiLCJ2YWx1ZSIsImJlbmNobWFya05hbWUiLCJiZW5jaG1hcmtJZCIsInJlcXVpcmVtZW50IiwiZmFtaWx5IiwidXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzIiwic3RvcmVTdGlnUmVxdWlyZW1lbnRzIiwiZ2V0U3RvcmVkU3RpZ1JlcXVpcmVtZW50cyIsImdldEFsbFN0b3JlZFN0aWdSZXF1aXJlbWVudHMiLCJhbGxSZXF1aXJlbWVudHMiLCJPYmplY3QiLCJrZXlzIiwiZmFtaWx5UmVxdWlyZW1lbnRzIiwicmVxIiwiaWQiLCJEYXRlIiwibm93IiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiY2xlYXJTdG9yZWRTdGlnUmVxdWlyZW1lbnRzIiwia2V5IiwiZ2V0RGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRzIiwic3RpZ0ZhbWlseUlkIiwiY29udmVydFN0aWdSZXF1aXJlbWVudHNUb01hdHJpeCIsInN0aWdGYW1pbHlJZHMiLCJjb25zb2xlIiwibG9nIiwiZGV0YWlsZWRSZXF1aXJlbWVudHMiLCJmZXRjaEFuZENvbnZlcnRTdGlnUmVxdWlyZW1lbnRzIiwiZmFtaWx5SWRzIiwicGFyYW0iLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwiYXBpUmVzIiwiZmV0Y2giLCJvayIsImVycm9yIiwiY3N2UmVzdWx0cyIsImpzb24iLCJjc3ZUZXh0IiwiZGV0YWlsZWQiLCJlcnIiLCJmZXRjaEFuZENvbnZlcnRTdGlnUmVxdWlyZW1lbnRzVG9NYXRyaXgiLCJhbGwiLCJjb252ZXJ0VG9TdGlnUmVxdWlyZW1lbnRzIiwic3RpZ1JlcXVpcmVtZW50c0RhdGFiYXNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/detailedStigRequirements.ts\n"));

/***/ })

});