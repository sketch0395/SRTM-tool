"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/detailedStigRequirements.ts":
/*!*******************************************!*\
  !*** ./utils/detailedStigRequirements.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearStoredStigRequirements: () => (/* binding */ clearStoredStigRequirements),\n/* harmony export */   convertCsvToStigRequirement: () => (/* binding */ convertCsvToStigRequirement),\n/* harmony export */   convertStigRequirementsToMatrix: () => (/* binding */ convertStigRequirementsToMatrix),\n/* harmony export */   convertToStigRequirements: () => (/* binding */ convertToStigRequirements),\n/* harmony export */   fetchAndConvertStigRequirements: () => (/* binding */ fetchAndConvertStigRequirements),\n/* harmony export */   fetchAndConvertStigRequirementsToMatrix: () => (/* binding */ fetchAndConvertStigRequirementsToMatrix),\n/* harmony export */   getAllStoredStigRequirements: () => (/* binding */ getAllStoredStigRequirements),\n/* harmony export */   getDetailedStigRequirements: () => (/* binding */ getDetailedStigRequirements),\n/* harmony export */   getStoredStigRequirements: () => (/* binding */ getStoredStigRequirements),\n/* harmony export */   getUniqueStigRequirementCount: () => (/* binding */ getUniqueStigRequirementCount),\n/* harmony export */   groupStigRequirementsByTitle: () => (/* binding */ groupStigRequirementsByTitle),\n/* harmony export */   parseStigCsv: () => (/* binding */ parseStigCsv),\n/* harmony export */   stigRequirementsDatabase: () => (/* binding */ stigRequirementsDatabase),\n/* harmony export */   storeStigRequirements: () => (/* binding */ storeStigRequirements),\n/* harmony export */   uploadedStigRequirements: () => (/* binding */ uploadedStigRequirements)\n/* harmony export */ });\n/**\r\n * STIG CSV Upload and Management\r\n * Handles parsing and processing of STIG CSV files\r\n */ /**\r\n * Mapping of internal STIG family IDs to stigviewer.com STIG IDs\r\n * Note: stigviewer.com uses different naming conventions\r\n * Format: stigviewer.com/stig/{stigviewerId}/\r\n */ const STIG_ID_MAPPING = {\n    // Application & Web\n    'application-security-dev': 'application_security_and_development',\n    'web-server-srg': 'web_server',\n    'application-server-srg': 'application_server',\n    // Database\n    'postgresql': 'postgresql_9-x',\n    'mysql': 'mysql',\n    'oracle': 'oracle_database_12c',\n    'mssql': 'ms_sql_server_2016',\n    'mongodb': 'mongodb',\n    // Operating Systems\n    'rhel-8': 'red_hat_enterprise_linux_8',\n    'rhel-9': 'red_hat_enterprise_linux_9',\n    'ubuntu': 'canonical_ubuntu_20.04_lts',\n    'windows-server-2019': 'windows_server_2019',\n    'windows-server-2022': 'windows_server_2022',\n    'windows-10': 'windows_10',\n    'windows-11': 'windows_11',\n    // Web Servers\n    'apache-2.4': 'apache_server_2.4_unix',\n    'nginx': 'nginx',\n    'iis-10': 'iis_10.0_server',\n    'iis-8.5': 'iis_8.5_server',\n    // Middleware\n    'docker': 'docker_enterprise',\n    'kubernetes': 'kubernetes',\n    // Network/Infrastructure\n    'firewall-srg': 'firewall',\n    'router-srg': 'router',\n    'switch-srg': 'network_switch',\n    // Cloud\n    'aws': 'amazon_web_services',\n    'azure': 'microsoft_azure',\n    'gcp': 'google_cloud_platform'\n};\n/**\r\n * Convert internal STIG family ID to stigviewer.com STIG ID\r\n */ function mapToStigViewerId(internalId) {\n    return STIG_ID_MAPPING[internalId] || internalId;\n}\n// Function to convert CSV STIG data to our internal format\nfunction convertCsvToStigRequirement(csvRow) {\n    // Normalize severity values\n    const normalizeSeverity = (severity)=>{\n        const sev = severity.toLowerCase();\n        if (sev === 'high' || sev === 'cat i') return 'CAT I';\n        if (sev === 'medium' || sev === 'cat ii') return 'CAT II';\n        if (sev === 'low' || sev === 'cat iii') return 'CAT III';\n        return 'CAT II'; // default\n    };\n    // Extract CCI references\n    const cciRefs = csvRow.ccis ? csvRow.ccis.split('\\n').filter((line)=>line.includes('CCI-')).map((line)=>{\n        const match = line.match(/CCI-\\d+/);\n        return match ? match[0] : '';\n    }).filter((cci)=>cci) : [\n        'CCI-000366'\n    ];\n    // Normalize status values\n    const normalizeStatus = (status)=>{\n        if (!status) return 'Not Started';\n        const stat = status.toLowerCase();\n        if (stat.includes('progress') || stat.includes('ongoing')) return 'In Progress';\n        if (stat.includes('complete') || stat.includes('done')) return 'Completed';\n        if (stat.includes('exception') || stat.includes('waiver')) return 'Exception Requested';\n        return 'Not Started';\n    };\n    return {\n        stigId: csvRow.stigId || csvRow.ruleId || 'UNKNOWN',\n        vulnId: csvRow.groupId || undefined,\n        severity: normalizeSeverity(csvRow.severity),\n        title: csvRow.ruleTitle || 'Untitled Requirement',\n        description: csvRow.discussion || 'No description provided',\n        checkText: csvRow.checkContent || 'No check procedure provided',\n        fixText: csvRow.fixText || 'No fix procedure provided',\n        applicability: 'Applicable',\n        status: normalizeStatus(csvRow.status),\n        implementationStatus: 'Open',\n        cciRef: cciRefs\n    };\n}\n// Parse CSV content and return STIG requirements\nfunction parseStigCsv(csvContent, familyId) {\n    const lines = csvContent.split('\\n');\n    if (lines.length < 2) return [];\n    // Parse header row\n    const headers = lines[0].split(',').map((h)=>h.replace(/\"/g, '').trim().toLowerCase().replace(/\\s+/g, ''));\n    const requirements = [];\n    for(let i = 1; i < lines.length; i++){\n        const line = lines[i].trim();\n        if (!line) continue;\n        // Parse CSV row (handling quoted fields)\n        const values = [];\n        let current = '';\n        let inQuotes = false;\n        for(let j = 0; j < line.length; j++){\n            const char = line[j];\n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                values.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        values.push(current.trim()); // Add the last value\n        // Create CSV STIG object\n        const csvRow = {\n            severity: 'medium',\n            stigId: '',\n            ruleTitle: '',\n            fixText: '',\n            discussion: '',\n            checkContent: ''\n        };\n        // Map values to CSV STIG object based on headers\n        headers.forEach((header, index)=>{\n            if (values[index]) {\n                const value = values[index].replace(/^\"|\"$/g, ''); // Remove surrounding quotes\n                switch(header){\n                    case 'benchmarkname':\n                        csvRow.benchmarkName = value;\n                        break;\n                    case 'benchmarkid':\n                        csvRow.benchmarkId = value;\n                        break;\n                    case 'severity':\n                        csvRow.severity = value;\n                        break;\n                    case 'stigid':\n                        csvRow.stigId = value;\n                        break;\n                    case 'ruletitle':\n                        csvRow.ruleTitle = value;\n                        break;\n                    case 'fixtext':\n                        csvRow.fixText = value;\n                        break;\n                    case 'discussion':\n                        csvRow.discussion = value;\n                        break;\n                    case 'checkcontent':\n                        csvRow.checkContent = value;\n                        break;\n                    case 'ccis':\n                        csvRow.ccis = value;\n                        break;\n                    case 'groupid':\n                        csvRow.groupId = value;\n                        break;\n                    case 'ruleid':\n                        csvRow.ruleId = value;\n                        break;\n                    case 'status':\n                        csvRow.status = value;\n                        break;\n                }\n            }\n        });\n        // Convert to our internal format\n        if (csvRow.stigId && csvRow.ruleTitle) {\n            const requirement = convertCsvToStigRequirement(csvRow);\n            if (familyId) {\n                requirement.family = familyId;\n            }\n            requirements.push(requirement);\n        }\n    }\n    return requirements;\n}\n// Database for managing uploaded STIG requirements\nconst uploadedStigRequirements = {};\n// Function to store uploaded STIG requirements\nfunction storeStigRequirements(familyId, requirements) {\n    uploadedStigRequirements[familyId] = requirements;\n}\n// Function to get stored STIG requirements\nfunction getStoredStigRequirements(familyId) {\n    return uploadedStigRequirements[familyId] || [];\n}\n// Function to get all stored STIG requirements across all families\nfunction getAllStoredStigRequirements() {\n    const allRequirements = [];\n    Object.keys(uploadedStigRequirements).forEach((familyId)=>{\n        const familyRequirements = uploadedStigRequirements[familyId];\n        familyRequirements.forEach((req, index)=>{\n            allRequirements.push({\n                id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n                family: req.family || familyId,\n                ...req,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n        });\n    });\n    return allRequirements;\n}\n// Function to clear stored STIG requirements\nfunction clearStoredStigRequirements(familyId) {\n    if (familyId) {\n        delete uploadedStigRequirements[familyId];\n    } else {\n        // Clear all\n        Object.keys(uploadedStigRequirements).forEach((key)=>{\n            delete uploadedStigRequirements[key];\n        });\n    }\n}\n/**\r\n * Get detailed STIG requirements for a given STIG family ID\r\n * Now supports uploaded CSV data\r\n */ function getDetailedStigRequirements(stigFamilyId) {\n    // Return stored uploaded requirements\n    return getStoredStigRequirements(stigFamilyId);\n}\n/**\r\n * Convert STIG requirements to the format expected by the traceability matrix\r\n */ function convertStigRequirementsToMatrix(stigFamilyIds) {\n    console.log('Converting STIG requirements for families:', stigFamilyIds);\n    const allRequirements = [];\n    stigFamilyIds.forEach((familyId)=>{\n        const detailedRequirements = getStoredStigRequirements(familyId);\n        console.log(\"Found \".concat(detailedRequirements.length, \" requirements for family: \").concat(familyId));\n        detailedRequirements.forEach((req, index)=>{\n            allRequirements.push({\n                id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n                ...req,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n        });\n    });\n    console.log(\"Total converted requirements: \".concat(allRequirements.length));\n    return allRequirements;\n}\n// New: Fetch STIG from stigviewer and convert to requirements\nasync function fetchAndConvertStigRequirements(familyIds) {\n    // Use internal API route to fetch STIG data (avoids CORS/network errors)\n    const allRequirements = [];\n    const failedFetches = [];\n    for (const familyId of familyIds){\n        // Map internal ID to stigviewer.com ID\n        const stigviewerId = mapToStigViewerId(familyId);\n        const apiUrl =  true ? \"\".concat(window.location.origin, \"/api/import-stig?stigId=\").concat(encodeURIComponent(stigviewerId)) : 0;\n        console.log(\"\\uD83D\\uDD0D Fetching STIG: \".concat(familyId, \" → \").concat(stigviewerId));\n        try {\n            const apiRes = await fetch(apiUrl);\n            const result = await apiRes.json();\n            if (!apiRes.ok || !result.success) {\n                // API returned error (503 = stigviewer.com unavailable)\n                console.warn(\"⚠️ Could not fetch \".concat(familyId, \" (\").concat(stigviewerId, \"): \").concat(result.error || result.message));\n                failedFetches.push(\"\".concat(familyId, \" → \").concat(stigviewerId));\n                continue;\n            }\n            if (result.success && result.requirements) {\n                console.log(\"\\uD83D\\uDCCA API returned \".concat(result.requirements.length, \" requirements\"));\n                // Log severity distribution from API\n                const severityCounts = {};\n                result.requirements.forEach((req)=>{\n                    const sev = req.severity || 'unknown';\n                    severityCounts[sev] = (severityCounts[sev] || 0) + 1;\n                });\n                console.log(\"\\uD83D\\uDCCA Severity distribution from API:\", severityCounts);\n                // Convert the API format to DetailedStigRequirement format\n                const converted = result.requirements.map((req)=>{\n                    // Normalize severity - API returns 'high', 'medium', 'low'\n                    let severity = 'CAT II';\n                    const sevText = (req.severity || 'medium').toLowerCase();\n                    if (sevText === 'high' || sevText === 'cat i' || sevText.includes('cat i')) {\n                        severity = 'CAT I';\n                    } else if (sevText === 'low' || sevText === 'cat iii' || sevText.includes('cat iii')) {\n                        severity = 'CAT III';\n                    } else {\n                        severity = 'CAT II';\n                    }\n                    return {\n                        stigId: req.vulnId || req.ruleId || 'UNKNOWN',\n                        vulnId: req.vulnId,\n                        ruleId: req.ruleId,\n                        severity,\n                        title: req.title || 'Untitled Requirement',\n                        description: req.description || 'No description provided',\n                        checkText: req.checkText || 'No check procedure provided',\n                        fixText: req.fixText || 'No fix procedure provided',\n                        applicability: 'Applicable',\n                        status: 'Not Started',\n                        implementationStatus: 'Open',\n                        cciRef: req.cci && req.cci.length > 0 ? req.cci : [\n                            'CCI-000366'\n                        ],\n                        family: familyId\n                    };\n                });\n                // Log severity distribution after conversion\n                const convertedCounts = {};\n                converted.forEach((req)=>{\n                    convertedCounts[req.severity] = (convertedCounts[req.severity] || 0) + 1;\n                });\n                console.log(\"\\uD83D\\uDCCA Severity distribution after conversion:\", convertedCounts);\n                allRequirements.push(...converted);\n                console.log(\"✅ Successfully loaded \".concat(converted.length, \" requirements for \").concat(familyId));\n            }\n        } catch (err) {\n            console.error(\"❌ Error fetching STIG for \".concat(familyId, \":\"), err);\n            failedFetches.push(\"\".concat(familyId, \" → \").concat(stigviewerId));\n        }\n    }\n    // Show user-friendly message if fetches failed\n    if (failedFetches.length > 0 && \"object\" !== 'undefined') {\n        console.warn(\"\\n⚠️ STIG IMPORT ISSUE\\n\" + \"Failed to automatically fetch \".concat(failedFetches.length, \" STIG(s):\\n\") + failedFetches.map((f)=>\"  • \".concat(f)).join('\\n') + '\\n\\n' + \"Possible reasons:\\n\" + \"  • STIG ID mapping may be incorrect for stigviewer.com\\n\" + \"  • STIG may not be available on stigviewer.com\\n\" + \"  • Network connectivity issues\\n\\n\" + \"MANUAL UPLOAD OPTIONS:\\n\" + \"  1. Download STIG XML from DISA: https://public.cyber.mil/stigs/downloads/\\n\" + \"  2. Or browse STIGs: https://stigviewer.com/stigs\\n\" + \"  3. Use the STIG Import component to upload the XCCDF XML file\\n\");\n    }\n    return allRequirements;\n}\n// New: Fetch and convert STIG CSVs directly to the matrix format (StigRequirement[])\nasync function fetchAndConvertStigRequirementsToMatrix(familyIds) {\n    const detailed = await fetchAndConvertStigRequirements(familyIds);\n    const all = [];\n    detailed.forEach((req, index)=>{\n        const familyId = req.family || 'unknown';\n        all.push({\n            id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n            ...req,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        });\n    });\n    return all;\n}\n// Legacy function name support\nconst convertToStigRequirements = convertStigRequirementsToMatrix;\n// Empty database for backward compatibility\nconst stigRequirementsDatabase = {};\n/**\r\n * Group STIG requirements by title to avoid duplicate display\r\n * Requirements with the same title are grouped together with a count\r\n */ function groupStigRequirementsByTitle(requirements) {\n    const groupedMap = new Map();\n    requirements.forEach((req)=>{\n        const key = req.title.trim();\n        if (groupedMap.has(key)) {\n            const existing = groupedMap.get(key);\n            existing.count += 1;\n            existing.stigIds.push(req.stigId);\n            existing.requirements.push(req);\n            // Update status to highest priority status\n            if (req.status === 'Completed' && existing.status !== 'Completed') {\n                existing.status = 'Completed';\n            } else if (req.status === 'In Progress' && existing.status === 'Not Started') {\n                existing.status = 'In Progress';\n            } else if (req.status === 'Exception Requested') {\n                existing.status = 'Exception Requested';\n            }\n            // Update implementation status to most severe\n            if (req.implementationStatus === 'Open' && existing.implementationStatus !== 'Open') {\n                existing.implementationStatus = 'Open';\n            } else if (req.implementationStatus === 'NotAFinding' && existing.implementationStatus === 'Not_Applicable') {\n                existing.implementationStatus = 'NotAFinding';\n            }\n        } else {\n            groupedMap.set(key, {\n                title: req.title,\n                count: 1,\n                family: req.family,\n                severity: req.severity,\n                description: req.description,\n                checkText: req.checkText,\n                fixText: req.fixText,\n                stigIds: [\n                    req.stigId\n                ],\n                requirements: [\n                    req\n                ],\n                status: req.status,\n                implementationStatus: req.implementationStatus\n            });\n        }\n    });\n    return Array.from(groupedMap.values()).sort((a, b)=>{\n        // Sort by severity first (CAT I > CAT II > CAT III), then by title\n        const severityOrder = {\n            'CAT I': 1,\n            'CAT II': 2,\n            'CAT III': 3\n        };\n        const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];\n        if (severityDiff !== 0) return severityDiff;\n        return a.title.localeCompare(b.title);\n    });\n}\n/**\r\n * Get unique count of STIG requirements by title for a family\r\n */ function getUniqueStigRequirementCount(familyId) {\n    const requirements = getStoredStigRequirements(familyId);\n    const titleSet = new Set(requirements.map((req)=>{\n        var _req_title;\n        return (_req_title = req.title) === null || _req_title === void 0 ? void 0 : _req_title.trim();\n    }).filter(Boolean));\n    return titleSet.size;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2RldGFpbGVkU3RpZ1JlcXVpcmVtZW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FTRDs7OztDQUlDLEdBQ0QsTUFBTUEsa0JBQTBDO0lBQzlDLG9CQUFvQjtJQUNwQiw0QkFBNEI7SUFDNUIsa0JBQWtCO0lBQ2xCLDBCQUEwQjtJQUUxQixXQUFXO0lBQ1gsY0FBYztJQUNkLFNBQVM7SUFDVCxVQUFVO0lBQ1YsU0FBUztJQUNULFdBQVc7SUFFWCxvQkFBb0I7SUFDcEIsVUFBVTtJQUNWLFVBQVU7SUFDVixVQUFVO0lBQ1YsdUJBQXVCO0lBQ3ZCLHVCQUF1QjtJQUN2QixjQUFjO0lBQ2QsY0FBYztJQUVkLGNBQWM7SUFDZCxjQUFjO0lBQ2QsU0FBUztJQUNULFVBQVU7SUFDVixXQUFXO0lBRVgsYUFBYTtJQUNiLFVBQVU7SUFDVixjQUFjO0lBRWQseUJBQXlCO0lBQ3pCLGdCQUFnQjtJQUNoQixjQUFjO0lBQ2QsY0FBYztJQUVkLFFBQVE7SUFDUixPQUFPO0lBQ1AsU0FBUztJQUNULE9BQU87QUFDVDtBQUVBOztDQUVDLEdBQ0QsU0FBU0Msa0JBQWtCQyxVQUFrQjtJQUMzQyxPQUFPRixlQUFlLENBQUNFLFdBQVcsSUFBSUE7QUFDeEM7QUE2Q0EsMkRBQTJEO0FBQ3BELFNBQVNDLDRCQUE0QkMsTUFBMEI7SUFDcEUsNEJBQTRCO0lBQzVCLE1BQU1DLG9CQUFvQixDQUFDQztRQUN6QixNQUFNQyxNQUFNRCxTQUFTRSxXQUFXO1FBQ2hDLElBQUlELFFBQVEsVUFBVUEsUUFBUSxTQUFTLE9BQU87UUFDOUMsSUFBSUEsUUFBUSxZQUFZQSxRQUFRLFVBQVUsT0FBTztRQUNqRCxJQUFJQSxRQUFRLFNBQVNBLFFBQVEsV0FBVyxPQUFPO1FBQy9DLE9BQU8sVUFBVSxVQUFVO0lBQzdCO0lBRUEseUJBQXlCO0lBQ3pCLE1BQU1FLFVBQVVMLE9BQU9NLElBQUksR0FDekJOLE9BQU9N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LElBQUksQ0FBQ1QsV0FBV3BFLE1BQU0sSUFBSThFLElBQUksQ0FBQyxDQUFDQyxHQUFHQztRQUM5QyxtRUFBbUU7UUFDbkUsTUFBTUMsZ0JBQWdCO1lBQUUsU0FBUztZQUFHLFVBQVU7WUFBRyxXQUFXO1FBQUU7UUFDOUQsTUFBTUMsZUFBZUQsYUFBYSxDQUFDRixFQUFFeEgsUUFBUSxDQUFDLEdBQUcwSCxhQUFhLENBQUNELEVBQUV6SCxRQUFRLENBQUM7UUFDMUUsSUFBSTJILGlCQUFpQixHQUFHLE9BQU9BO1FBQy9CLE9BQU9ILEVBQUVwRyxLQUFLLENBQUN3RyxhQUFhLENBQUNILEVBQUVyRyxLQUFLO0lBQ3RDO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVN5Ryw4QkFBOEI3RixRQUFnQjtJQUM1RCxNQUFNTyxlQUFla0IsMEJBQTBCekI7SUFDL0MsTUFBTThGLFdBQVcsSUFBSUMsSUFBSXhGLGFBQWE5QixHQUFHLENBQUNzRCxDQUFBQTtZQUFPQTtnQkFBQUEsYUFBQUEsSUFBSTNDLEtBQUssY0FBVDJDLGlDQUFBQSxXQUFXekIsSUFBSTtPQUFJaEMsTUFBTSxDQUFDMEg7SUFDM0UsT0FBT0YsU0FBU0csSUFBSTtBQUN0QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxyb25uaVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2plY3RzXFxTUlRNLXRvb2xcXHV0aWxzXFxkZXRhaWxlZFN0aWdSZXF1aXJlbWVudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFNUSUcgQ1NWIFVwbG9hZCBhbmQgTWFuYWdlbWVudFxyXG4gKiBIYW5kbGVzIHBhcnNpbmcgYW5kIHByb2Nlc3Npbmcgb2YgU1RJRyBDU1YgZmlsZXNcclxuICovXHJcblxyXG5pbXBvcnQgeyBTdGlnUmVxdWlyZW1lbnQsIEdyb3VwZWRTdGlnUmVxdWlyZW1lbnQgfSBmcm9tICcuLi90eXBlcy9zcnRtJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnQgZXh0ZW5kcyBPbWl0PFN0aWdSZXF1aXJlbWVudCwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+IHtcclxuICAvLyBBbGwgb3RoZXIgZmllbGRzIGZyb20gU3RpZ1JlcXVpcmVtZW50IGludGVyZmFjZVxyXG4gIGZhbWlseT86IHN0cmluZzsgLy8gQWRkIGZhbWlseSB0cmFja2luZ1xyXG59XHJcblxyXG4vKipcclxuICogTWFwcGluZyBvZiBpbnRlcm5hbCBTVElHIGZhbWlseSBJRHMgdG8gc3RpZ3ZpZXdlci5jb20gU1RJRyBJRHNcclxuICogTm90ZTogc3RpZ3ZpZXdlci5jb20gdXNlcyBkaWZmZXJlbnQgbmFtaW5nIGNvbnZlbnRpb25zXHJcbiAqIEZvcm1hdDogc3RpZ3ZpZXdlci5jb20vc3RpZy97c3RpZ3ZpZXdlcklkfS9cclxuICovXHJcbmNvbnN0IFNUSUdfSURfTUFQUElORzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAvLyBBcHBsaWNhdGlvbiAmIFdlYlxyXG4gICdhcHBsaWNhdGlvbi1zZWN1cml0eS1kZXYnOiAnYXBwbGljYXRpb25fc2VjdXJpdHlfYW5kX2RldmVsb3BtZW50JyxcclxuICAnd2ViLXNlcnZlci1zcmcnOiAnd2ViX3NlcnZlcicsXHJcbiAgJ2FwcGxpY2F0aW9uLXNlcnZlci1zcmcnOiAnYXBwbGljYXRpb25fc2VydmVyJyxcclxuICBcclxuICAvLyBEYXRhYmFzZVxyXG4gICdwb3N0Z3Jlc3FsJzogJ3Bvc3RncmVzcWxfOS14JyxcclxuICAnbXlzcWwnOiAnbXlzcWwnLFxyXG4gICdvcmFjbGUnOiAnb3JhY2xlX2RhdGFiYXNlXzEyYycsXHJcbiAgJ21zc3FsJzogJ21zX3NxbF9zZXJ2ZXJfMjAxNicsXHJcbiAgJ21vbmdvZGInOiAnbW9uZ29kYicsXHJcbiAgXHJcbiAgLy8gT3BlcmF0aW5nIFN5c3RlbXNcclxuICAncmhlbC04JzogJ3JlZF9oYXRfZW50ZXJwcmlzZV9saW51eF84JyxcclxuICAncmhlbC05JzogJ3JlZF9oYXRfZW50ZXJwcmlzZV9saW51eF85JywgXHJcbiAgJ3VidW50dSc6ICdjYW5vbmljYWxfdWJ1bnR1XzIwLjA0X2x0cycsXHJcbiAgJ3dpbmRvd3Mtc2VydmVyLTIwMTknOiAnd2luZG93c19zZXJ2ZXJfMjAxOScsXHJcbiAgJ3dpbmRvd3Mtc2VydmVyLTIwMjInOiAnd2luZG93c19zZXJ2ZXJfMjAyMicsXHJcbiAgJ3dpbmRvd3MtMTAnOiAnd2luZG93c18xMCcsXHJcbiAgJ3dpbmRvd3MtMTEnOiAnd2luZG93c18xMScsXHJcbiAgXHJcbiAgLy8gV2ViIFNlcnZlcnNcclxuICAnYXBhY2hlLTIuNCc6ICdhcGFjaGVfc2VydmVyXzIuNF91bml4JyxcclxuICAnbmdpbngnOiAnbmdpbngnLFxyXG4gICdpaXMtMTAnOiAnaWlzXzEwLjBfc2VydmVyJyxcclxuICAnaWlzLTguNSc6ICdpaXNfOC41X3NlcnZlcicsXHJcbiAgXHJcbiAgLy8gTWlkZGxld2FyZVxyXG4gICdkb2NrZXInOiAnZG9ja2VyX2VudGVycHJpc2UnLFxyXG4gICdrdWJlcm5ldGVzJzogJ2t1YmVybmV0ZXMnLFxyXG4gIFxyXG4gIC8vIE5ldHdvcmsvSW5mcmFzdHJ1Y3R1cmVcclxuICAnZmlyZXdhbGwtc3JnJzogJ2ZpcmV3YWxsJyxcclxuICAncm91dGVyLXNyZyc6ICdyb3V0ZXInLFxyXG4gICdzd2l0Y2gtc3JnJzogJ25ldHdvcmtfc3dpdGNoJyxcclxuICBcclxuICAvLyBDbG91ZFxyXG4gICdhd3MnOiAnYW1hem9uX3dlYl9zZXJ2aWNlcycsXHJcbiAgJ2F6dXJlJzogJ21pY3Jvc29mdF9henVyZScsXHJcbiAgJ2djcCc6ICdnb29nbGVfY2xvdWRfcGxhdGZvcm0nLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgaW50ZXJuYWwgU1RJRyBmYW1pbHkgSUQgdG8gc3RpZ3ZpZXdlci5jb20gU1RJRyBJRFxyXG4gKi9cclxuZnVuY3Rpb24gbWFwVG9TdGlnVmlld2VySWQoaW50ZXJuYWxJZDogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gU1RJR19JRF9NQVBQSU5HW2ludGVybmFsSWRdIHx8IGludGVybmFsSWQ7XHJcbn1cclxuXHJcbi8vIENTViBVcGxvYWQgU3VwcG9ydCBmb3IgU1RJRyBSZXF1aXJlbWVudHNcclxuZXhwb3J0IGludGVyZmFjZSBDc3ZTdGlnUmVxdWlyZW1lbnQge1xyXG4gIGJlbmNobWFya05hbWU/OiBzdHJpbmc7XHJcbiAgYmVuY2htYXJrSWQ/OiBzdHJpbmc7XHJcbiAgcmVsZWFzZUluZm8/OiBzdHJpbmc7XHJcbiAgdmVyc2lvbj86IHN0cmluZztcclxuICBncm91cElkPzogc3RyaW5nO1xyXG4gIHNldmVyaXR5OiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnIHwgJ0NBVCBJJyB8ICdDQVQgSUknIHwgJ0NBVCBJSUknO1xyXG4gIHJ1bGVJZD86IHN0cmluZztcclxuICBzdGlnSWQ6IHN0cmluZztcclxuICBjbGFzc2lmaWNhdGlvbj86IHN0cmluZztcclxuICBhc3NldFBvc3R1cmU/OiBzdHJpbmc7XHJcbiAgc3JnSWQ/OiBzdHJpbmc7XHJcbiAgcnVsZVRpdGxlOiBzdHJpbmc7XHJcbiAgZml4VGV4dDogc3RyaW5nO1xyXG4gIGRpc2N1c3Npb246IHN0cmluZztcclxuICBjY2lzPzogc3RyaW5nO1xyXG4gIGxlZ2FjeUlkcz86IHN0cmluZztcclxuICBjaGVja0NvbnRlbnQ6IHN0cmluZztcclxuICBjaGVja0NvbnRlbnRSZWY/OiBzdHJpbmc7XHJcbiAgaWFDb250cm9scz86IHN0cmluZztcclxuICB3ZWlnaHQ/OiBzdHJpbmc7XHJcbiAgZmFsc2VQb3NpdGl2ZXM/OiBzdHJpbmc7XHJcbiAgZmFsc2VOZWdhdGl2ZXM/OiBzdHJpbmc7XHJcbiAgZG9jdW1lbnRhYmxlPzogc3RyaW5nO1xyXG4gIHNlY3VyaXR5T3ZlcnJpZGVHdWlkYW5jZT86IHN0cmluZztcclxuICBwb3RlbnRpYWxJbXBhY3RzPzogc3RyaW5nO1xyXG4gIHRoaXJkUGFydHlUb29scz86IHN0cmluZztcclxuICByZXNwb25zaWJpbGl0eT86IHN0cmluZztcclxuICBtaXRpZ2F0aW9ucz86IHN0cmluZztcclxuICBtaXRpZ2F0aW9uQ29udHJvbD86IHN0cmluZztcclxuICBzdGF0dXM/OiBzdHJpbmc7XHJcbiAgY29tbWVudHM/OiBzdHJpbmc7XHJcbiAgZmluZGluZ0RldGFpbHM/OiBzdHJpbmc7XHJcbiAgc2V2ZXJpdHlPdmVycmlkZT86IHN0cmluZztcclxuICBzZXZlcml0eU92ZXJyaWRlUmVhc29uPzogc3RyaW5nO1xyXG4gIGZxZG4/OiBzdHJpbmc7XHJcbiAgaXBBZGRyZXNzPzogc3RyaW5nO1xyXG4gIG1hY0FkZHJlc3M/OiBzdHJpbmc7XHJcbiAgbmFtZT86IHN0cmluZztcclxuICB0ZWNobm9sb2d5QXJlYT86IHN0cmluZztcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gY29udmVydCBDU1YgU1RJRyBkYXRhIHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRDc3ZUb1N0aWdSZXF1aXJlbWVudChjc3ZSb3c6IENzdlN0aWdSZXF1aXJlbWVudCk6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50IHtcclxuICAvLyBOb3JtYWxpemUgc2V2ZXJpdHkgdmFsdWVzXHJcbiAgY29uc3Qgbm9ybWFsaXplU2V2ZXJpdHkgPSAoc2V2ZXJpdHk6IHN0cmluZyk6ICdDQVQgSScgfCAnQ0FUIElJJyB8ICdDQVQgSUlJJyA9PiB7XHJcbiAgICBjb25zdCBzZXYgPSBzZXZlcml0eS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKHNldiA9PT0gJ2hpZ2gnIHx8IHNldiA9PT0gJ2NhdCBpJykgcmV0dXJuICdDQVQgSSc7XHJcbiAgICBpZiAoc2V2ID09PSAnbWVkaXVtJyB8fCBzZXYgPT09ICdjYXQgaWknKSByZXR1cm4gJ0NBVCBJSSc7XHJcbiAgICBpZiAoc2V2ID09PSAnbG93JyB8fCBzZXYgPT09ICdjYXQgaWlpJykgcmV0dXJuICdDQVQgSUlJJztcclxuICAgIHJldHVybiAnQ0FUIElJJzsgLy8gZGVmYXVsdFxyXG4gIH07XHJcblxyXG4gIC8vIEV4dHJhY3QgQ0NJIHJlZmVyZW5jZXNcclxuICBjb25zdCBjY2lSZWZzID0gY3N2Um93LmNjaXMgPyBcclxuICAgIGNzdlJvdy5jY2lzLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLmluY2x1ZGVzKCdDQ0ktJykpLm1hcChsaW5lID0+IHtcclxuICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKC9DQ0ktXFxkKy8pO1xyXG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xyXG4gICAgfSkuZmlsdGVyKGNjaSA9PiBjY2kpIDogWydDQ0ktMDAwMzY2J107XHJcblxyXG4gIC8vIE5vcm1hbGl6ZSBzdGF0dXMgdmFsdWVzXHJcbiAgY29uc3Qgbm9ybWFsaXplU3RhdHVzID0gKHN0YXR1cz86IHN0cmluZyk6ICdOb3QgU3RhcnRlZCcgfCAnSW4gUHJvZ3Jlc3MnIHwgJ0NvbXBsZXRlZCcgfCAnRXhjZXB0aW9uIFJlcXVlc3RlZCcgPT4ge1xyXG4gICAgaWYgKCFzdGF0dXMpIHJldHVybiAnTm90IFN0YXJ0ZWQnO1xyXG4gICAgY29uc3Qgc3RhdCA9IHN0YXR1cy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKHN0YXQuaW5jbHVkZXMoJ3Byb2dyZXNzJykgfHwgc3RhdC5pbmNsdWRlcygnb25nb2luZycpKSByZXR1cm4gJ0luIFByb2dyZXNzJztcclxuICAgIGlmIChzdGF0LmluY2x1ZGVzKCdjb21wbGV0ZScpIHx8IHN0YXQuaW5jbHVkZXMoJ2RvbmUnKSkgcmV0dXJuICdDb21wbGV0ZWQnO1xyXG4gICAgaWYgKHN0YXQuaW5jbHVkZXMoJ2V4Y2VwdGlvbicpIHx8IHN0YXQuaW5jbHVkZXMoJ3dhaXZlcicpKSByZXR1cm4gJ0V4Y2VwdGlvbiBSZXF1ZXN0ZWQnO1xyXG4gICAgcmV0dXJuICdOb3QgU3RhcnRlZCc7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN0aWdJZDogY3N2Um93LnN0aWdJZCB8fCBjc3ZSb3cucnVsZUlkIHx8ICdVTktOT1dOJyxcclxuICAgIHZ1bG5JZDogY3N2Um93Lmdyb3VwSWQgfHwgdW5kZWZpbmVkLFxyXG4gICAgc2V2ZXJpdHk6IG5vcm1hbGl6ZVNldmVyaXR5KGNzdlJvdy5zZXZlcml0eSksXHJcbiAgICB0aXRsZTogY3N2Um93LnJ1bGVUaXRsZSB8fCAnVW50aXRsZWQgUmVxdWlyZW1lbnQnLFxyXG4gICAgZGVzY3JpcHRpb246IGNzdlJvdy5kaXNjdXNzaW9uIHx8ICdObyBkZXNjcmlwdGlvbiBwcm92aWRlZCcsXHJcbiAgICBjaGVja1RleHQ6IGNzdlJvdy5jaGVja0NvbnRlbnQgfHwgJ05vIGNoZWNrIHByb2NlZHVyZSBwcm92aWRlZCcsXHJcbiAgICBmaXhUZXh0OiBjc3ZSb3cuZml4VGV4dCB8fCAnTm8gZml4IHByb2NlZHVyZSBwcm92aWRlZCcsXHJcbiAgICBhcHBsaWNhYmlsaXR5OiAnQXBwbGljYWJsZScsXHJcbiAgICBzdGF0dXM6IG5vcm1hbGl6ZVN0YXR1cyhjc3ZSb3cuc3RhdHVzKSxcclxuICAgIGltcGxlbWVudGF0aW9uU3RhdHVzOiAnT3BlbicsXHJcbiAgICBjY2lSZWY6IGNjaVJlZnNcclxuICB9O1xyXG59XHJcblxyXG4vLyBQYXJzZSBDU1YgY29udGVudCBhbmQgcmV0dXJuIFNUSUcgcmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0aWdDc3YoY3N2Q29udGVudDogc3RyaW5nLCBmYW1pbHlJZD86IHN0cmluZyk6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10ge1xyXG4gIGNvbnN0IGxpbmVzID0gY3N2Q29udGVudC5zcGxpdCgnXFxuJyk7XHJcbiAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHJldHVybiBbXTtcclxuXHJcbiAgLy8gUGFyc2UgaGVhZGVyIHJvd1xyXG4gIGNvbnN0IGhlYWRlcnMgPSBsaW5lc1swXS5zcGxpdCgnLCcpLm1hcChoID0+IGgucmVwbGFjZSgvXCIvZywgJycpLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJycpKTtcclxuICBcclxuICBjb25zdCByZXF1aXJlbWVudHM6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcclxuICAgIGlmICghbGluZSkgY29udGludWU7XHJcblxyXG4gICAgLy8gUGFyc2UgQ1NWIHJvdyAoaGFuZGxpbmcgcXVvdGVkIGZpZWxkcylcclxuICAgIGNvbnN0IHZhbHVlczogc3RyaW5nW10gPSBbXTtcclxuICAgIGxldCBjdXJyZW50ID0gJyc7XHJcbiAgICBsZXQgaW5RdW90ZXMgPSBmYWxzZTtcclxuXHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgY29uc3QgY2hhciA9IGxpbmVbal07XHJcbiAgICAgIFxyXG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xyXG4gICAgICAgIGluUXVvdGVzID0gIWluUXVvdGVzO1xyXG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICcsJyAmJiAhaW5RdW90ZXMpIHtcclxuICAgICAgICB2YWx1ZXMucHVzaChjdXJyZW50LnRyaW0oKSk7XHJcbiAgICAgICAgY3VycmVudCA9ICcnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFsdWVzLnB1c2goY3VycmVudC50cmltKCkpOyAvLyBBZGQgdGhlIGxhc3QgdmFsdWVcclxuXHJcbiAgICAvLyBDcmVhdGUgQ1NWIFNUSUcgb2JqZWN0XHJcbiAgICBjb25zdCBjc3ZSb3c6IENzdlN0aWdSZXF1aXJlbWVudCA9IHtcclxuICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nIGFzIGNvbnN0LFxyXG4gICAgICBzdGlnSWQ6ICcnLFxyXG4gICAgICBydWxlVGl0bGU6ICcnLFxyXG4gICAgICBmaXhUZXh0OiAnJyxcclxuICAgICAgZGlzY3Vzc2lvbjogJycsXHJcbiAgICAgIGNoZWNrQ29udGVudDogJydcclxuICAgIH07XHJcblxyXG4gICAgLy8gTWFwIHZhbHVlcyB0byBDU1YgU1RJRyBvYmplY3QgYmFzZWQgb24gaGVhZGVyc1xyXG4gICAgaGVhZGVycy5mb3JFYWNoKChoZWFkZXIsIGluZGV4KSA9PiB7XHJcbiAgICAgIGlmICh2YWx1ZXNbaW5kZXhdKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdLnJlcGxhY2UoL15cInxcIiQvZywgJycpOyAvLyBSZW1vdmUgc3Vycm91bmRpbmcgcXVvdGVzXHJcbiAgICAgICAgXHJcbiAgICAgICAgc3dpdGNoIChoZWFkZXIpIHtcclxuICAgICAgICAgIGNhc2UgJ2JlbmNobWFya25hbWUnOlxyXG4gICAgICAgICAgICBjc3ZSb3cuYmVuY2htYXJrTmFtZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2JlbmNobWFya2lkJzpcclxuICAgICAgICAgICAgY3N2Um93LmJlbmNobWFya0lkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnc2V2ZXJpdHknOlxyXG4gICAgICAgICAgICBjc3ZSb3cuc2V2ZXJpdHkgPSB2YWx1ZSBhcyBhbnk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnc3RpZ2lkJzpcclxuICAgICAgICAgICAgY3N2Um93LnN0aWdJZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3J1bGV0aXRsZSc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5ydWxlVGl0bGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdmaXh0ZXh0JzpcclxuICAgICAgICAgICAgY3N2Um93LmZpeFRleHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdkaXNjdXNzaW9uJzpcclxuICAgICAgICAgICAgY3N2Um93LmRpc2N1c3Npb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdjaGVja2NvbnRlbnQnOlxyXG4gICAgICAgICAgICBjc3ZSb3cuY2hlY2tDb250ZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnY2Npcyc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5jY2lzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnZ3JvdXBpZCc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5ncm91cElkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAncnVsZWlkJzpcclxuICAgICAgICAgICAgY3N2Um93LnJ1bGVJZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3N0YXR1cyc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5zdGF0dXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcclxuICAgIGlmIChjc3ZSb3cuc3RpZ0lkICYmIGNzdlJvdy5ydWxlVGl0bGUpIHtcclxuICAgICAgY29uc3QgcmVxdWlyZW1lbnQgPSBjb252ZXJ0Q3N2VG9TdGlnUmVxdWlyZW1lbnQoY3N2Um93KTtcclxuICAgICAgaWYgKGZhbWlseUlkKSB7XHJcbiAgICAgICAgcmVxdWlyZW1lbnQuZmFtaWx5ID0gZmFtaWx5SWQ7XHJcbiAgICAgIH1cclxuICAgICAgcmVxdWlyZW1lbnRzLnB1c2gocmVxdWlyZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlcXVpcmVtZW50cztcclxufVxyXG5cclxuLy8gRGF0YWJhc2UgZm9yIG1hbmFnaW5nIHVwbG9hZGVkIFNUSUcgcmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBjb25zdCB1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHM6IHsgW2ZhbWlseUlkOiBzdHJpbmddOiBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudFtdIH0gPSB7fTtcclxuXHJcbi8vIEZ1bmN0aW9uIHRvIHN0b3JlIHVwbG9hZGVkIFNUSUcgcmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9yZVN0aWdSZXF1aXJlbWVudHMoZmFtaWx5SWQ6IHN0cmluZywgcmVxdWlyZW1lbnRzOiBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudFtdKSB7XHJcbiAgdXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzW2ZhbWlseUlkXSA9IHJlcXVpcmVtZW50cztcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gZ2V0IHN0b3JlZCBTVElHIHJlcXVpcmVtZW50c1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVkU3RpZ1JlcXVpcmVtZW50cyhmYW1pbHlJZDogc3RyaW5nKTogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSB7XHJcbiAgcmV0dXJuIHVwbG9hZGVkU3RpZ1JlcXVpcmVtZW50c1tmYW1pbHlJZF0gfHwgW107XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGdldCBhbGwgc3RvcmVkIFNUSUcgcmVxdWlyZW1lbnRzIGFjcm9zcyBhbGwgZmFtaWxpZXNcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFN0b3JlZFN0aWdSZXF1aXJlbWVudHMoKTogU3RpZ1JlcXVpcmVtZW50W10ge1xyXG4gIGNvbnN0IGFsbFJlcXVpcmVtZW50czogU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuICBcclxuICBPYmplY3Qua2V5cyh1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHMpLmZvckVhY2goZmFtaWx5SWQgPT4ge1xyXG4gICAgY29uc3QgZmFtaWx5UmVxdWlyZW1lbnRzID0gdXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzW2ZhbWlseUlkXTtcclxuICAgIGZhbWlseVJlcXVpcmVtZW50cy5mb3JFYWNoKChyZXEsIGluZGV4KSA9PiB7XHJcbiAgICAgIGFsbFJlcXVpcmVtZW50cy5wdXNoKHtcclxuICAgICAgICBpZDogYCR7ZmFtaWx5SWR9LSR7RGF0ZS5ub3coKX0tJHtpbmRleH1gLFxyXG4gICAgICAgIGZhbWlseTogcmVxLmZhbWlseSB8fCBmYW1pbHlJZCwgLy8gVXNlIHRoZSBmYW1pbHkgZnJvbSByZXF1aXJlbWVudCBvciBmYWxsYmFjayB0byBmYW1pbHlJZFxyXG4gICAgICAgIC4uLnJlcSxcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIGFsbFJlcXVpcmVtZW50cztcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gY2xlYXIgc3RvcmVkIFNUSUcgcmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhclN0b3JlZFN0aWdSZXF1aXJlbWVudHMoZmFtaWx5SWQ/OiBzdHJpbmcpIHtcclxuICBpZiAoZmFtaWx5SWQpIHtcclxuICAgIGRlbGV0ZSB1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHNbZmFtaWx5SWRdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBDbGVhciBhbGxcclxuICAgIE9iamVjdC5rZXlzKHVwbG9hZGVkU3RpZ1JlcXVpcmVtZW50cykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBkZWxldGUgdXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzW2tleV07XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZGV0YWlsZWQgU1RJRyByZXF1aXJlbWVudHMgZm9yIGEgZ2l2ZW4gU1RJRyBmYW1pbHkgSURcclxuICogTm93IHN1cHBvcnRzIHVwbG9hZGVkIENTViBkYXRhXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRzKHN0aWdGYW1pbHlJZDogc3RyaW5nKTogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSB7XHJcbiAgLy8gUmV0dXJuIHN0b3JlZCB1cGxvYWRlZCByZXF1aXJlbWVudHNcclxuICByZXR1cm4gZ2V0U3RvcmVkU3RpZ1JlcXVpcmVtZW50cyhzdGlnRmFtaWx5SWQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBTVElHIHJlcXVpcmVtZW50cyB0byB0aGUgZm9ybWF0IGV4cGVjdGVkIGJ5IHRoZSB0cmFjZWFiaWxpdHkgbWF0cml4XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFN0aWdSZXF1aXJlbWVudHNUb01hdHJpeChzdGlnRmFtaWx5SWRzOiBzdHJpbmdbXSk6IFN0aWdSZXF1aXJlbWVudFtdIHtcclxuICBjb25zb2xlLmxvZygnQ29udmVydGluZyBTVElHIHJlcXVpcmVtZW50cyBmb3IgZmFtaWxpZXM6Jywgc3RpZ0ZhbWlseUlkcyk7XHJcbiAgXHJcbiAgY29uc3QgYWxsUmVxdWlyZW1lbnRzOiBTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG4gIFxyXG4gIHN0aWdGYW1pbHlJZHMuZm9yRWFjaChmYW1pbHlJZCA9PiB7XHJcbiAgICBjb25zdCBkZXRhaWxlZFJlcXVpcmVtZW50cyA9IGdldFN0b3JlZFN0aWdSZXF1aXJlbWVudHMoZmFtaWx5SWQpO1xyXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7ZGV0YWlsZWRSZXF1aXJlbWVudHMubGVuZ3RofSByZXF1aXJlbWVudHMgZm9yIGZhbWlseTogJHtmYW1pbHlJZH1gKTtcclxuICAgIFxyXG4gICAgZGV0YWlsZWRSZXF1aXJlbWVudHMuZm9yRWFjaCgocmVxLCBpbmRleCkgPT4ge1xyXG4gICAgICBhbGxSZXF1aXJlbWVudHMucHVzaCh7XHJcbiAgICAgICAgaWQ6IGAke2ZhbWlseUlkfS0ke0RhdGUubm93KCl9LSR7aW5kZXh9YCxcclxuICAgICAgICAuLi5yZXEsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKGBUb3RhbCBjb252ZXJ0ZWQgcmVxdWlyZW1lbnRzOiAke2FsbFJlcXVpcmVtZW50cy5sZW5ndGh9YCk7XHJcbiAgcmV0dXJuIGFsbFJlcXVpcmVtZW50cztcclxufVxyXG5cclxuLy8gTmV3OiBGZXRjaCBTVElHIGZyb20gc3RpZ3ZpZXdlciBhbmQgY29udmVydCB0byByZXF1aXJlbWVudHNcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kQ29udmVydFN0aWdSZXF1aXJlbWVudHMoZmFtaWx5SWRzOiBzdHJpbmdbXSk6IFByb21pc2U8RGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXT4ge1xyXG4gIC8vIFVzZSBpbnRlcm5hbCBBUEkgcm91dGUgdG8gZmV0Y2ggU1RJRyBkYXRhIChhdm9pZHMgQ09SUy9uZXR3b3JrIGVycm9ycylcclxuICBjb25zdCBhbGxSZXF1aXJlbWVudHM6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuICBjb25zdCBmYWlsZWRGZXRjaGVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIFxyXG4gIGZvciAoY29uc3QgZmFtaWx5SWQgb2YgZmFtaWx5SWRzKSB7XHJcbiAgICAvLyBNYXAgaW50ZXJuYWwgSUQgdG8gc3RpZ3ZpZXdlci5jb20gSURcclxuICAgIGNvbnN0IHN0aWd2aWV3ZXJJZCA9IG1hcFRvU3RpZ1ZpZXdlcklkKGZhbWlseUlkKTtcclxuICAgIFxyXG4gICAgY29uc3QgYXBpVXJsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgID8gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vYXBpL2ltcG9ydC1zdGlnP3N0aWdJZD0ke2VuY29kZVVSSUNvbXBvbmVudChzdGlndmlld2VySWQpfWBcclxuICAgICAgOiBgL2FwaS9pbXBvcnQtc3RpZz9zdGlnSWQ9JHtlbmNvZGVVUklDb21wb25lbnQoc3RpZ3ZpZXdlcklkKX1gKTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCflI0gRmV0Y2hpbmcgU1RJRzogJHtmYW1pbHlJZH0g4oaSICR7c3RpZ3ZpZXdlcklkfWApO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBhcGlSZXMgPSBhd2FpdCBmZXRjaChhcGlVcmwpO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhcGlSZXMuanNvbigpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFhcGlSZXMub2sgfHwgIXJlc3VsdC5zdWNjZXNzKSB7XHJcbiAgICAgICAgLy8gQVBJIHJldHVybmVkIGVycm9yICg1MDMgPSBzdGlndmlld2VyLmNvbSB1bmF2YWlsYWJsZSlcclxuICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBDb3VsZCBub3QgZmV0Y2ggJHtmYW1pbHlJZH0gKCR7c3RpZ3ZpZXdlcklkfSk6ICR7cmVzdWx0LmVycm9yIHx8IHJlc3VsdC5tZXNzYWdlfWApO1xyXG4gICAgICAgIGZhaWxlZEZldGNoZXMucHVzaChgJHtmYW1pbHlJZH0g4oaSICR7c3RpZ3ZpZXdlcklkfWApO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LnJlcXVpcmVtZW50cykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIEFQSSByZXR1cm5lZCAke3Jlc3VsdC5yZXF1aXJlbWVudHMubGVuZ3RofSByZXF1aXJlbWVudHNgKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBMb2cgc2V2ZXJpdHkgZGlzdHJpYnV0aW9uIGZyb20gQVBJXHJcbiAgICAgICAgY29uc3Qgc2V2ZXJpdHlDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuICAgICAgICByZXN1bHQucmVxdWlyZW1lbnRzLmZvckVhY2goKHJlcTogYW55KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzZXYgPSByZXEuc2V2ZXJpdHkgfHwgJ3Vua25vd24nO1xyXG4gICAgICAgICAgc2V2ZXJpdHlDb3VudHNbc2V2XSA9IChzZXZlcml0eUNvdW50c1tzZXZdIHx8IDApICsgMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBTZXZlcml0eSBkaXN0cmlidXRpb24gZnJvbSBBUEk6YCwgc2V2ZXJpdHlDb3VudHMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIEFQSSBmb3JtYXQgdG8gRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnQgZm9ybWF0XHJcbiAgICAgICAgY29uc3QgY29udmVydGVkID0gcmVzdWx0LnJlcXVpcmVtZW50cy5tYXAoKHJlcTogYW55KSA9PiB7XHJcbiAgICAgICAgICAvLyBOb3JtYWxpemUgc2V2ZXJpdHkgLSBBUEkgcmV0dXJucyAnaGlnaCcsICdtZWRpdW0nLCAnbG93J1xyXG4gICAgICAgICAgbGV0IHNldmVyaXR5OiAnQ0FUIEknIHwgJ0NBVCBJSScgfCAnQ0FUIElJSScgPSAnQ0FUIElJJztcclxuICAgICAgICAgIGNvbnN0IHNldlRleHQgPSAocmVxLnNldmVyaXR5IHx8ICdtZWRpdW0nKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoc2V2VGV4dCA9PT0gJ2hpZ2gnIHx8IHNldlRleHQgPT09ICdjYXQgaScgfHwgc2V2VGV4dC5pbmNsdWRlcygnY2F0IGknKSkge1xyXG4gICAgICAgICAgICBzZXZlcml0eSA9ICdDQVQgSSc7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHNldlRleHQgPT09ICdsb3cnIHx8IHNldlRleHQgPT09ICdjYXQgaWlpJyB8fCBzZXZUZXh0LmluY2x1ZGVzKCdjYXQgaWlpJykpIHtcclxuICAgICAgICAgICAgc2V2ZXJpdHkgPSAnQ0FUIElJSSc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXZlcml0eSA9ICdDQVQgSUknO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGlnSWQ6IHJlcS52dWxuSWQgfHwgcmVxLnJ1bGVJZCB8fCAnVU5LTk9XTicsXHJcbiAgICAgICAgICAgIHZ1bG5JZDogcmVxLnZ1bG5JZCxcclxuICAgICAgICAgICAgcnVsZUlkOiByZXEucnVsZUlkLFxyXG4gICAgICAgICAgICBzZXZlcml0eSxcclxuICAgICAgICAgICAgdGl0bGU6IHJlcS50aXRsZSB8fCAnVW50aXRsZWQgUmVxdWlyZW1lbnQnLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogcmVxLmRlc2NyaXB0aW9uIHx8ICdObyBkZXNjcmlwdGlvbiBwcm92aWRlZCcsXHJcbiAgICAgICAgICAgIGNoZWNrVGV4dDogcmVxLmNoZWNrVGV4dCB8fCAnTm8gY2hlY2sgcHJvY2VkdXJlIHByb3ZpZGVkJyxcclxuICAgICAgICAgICAgZml4VGV4dDogcmVxLmZpeFRleHQgfHwgJ05vIGZpeCBwcm9jZWR1cmUgcHJvdmlkZWQnLFxyXG4gICAgICAgICAgICBhcHBsaWNhYmlsaXR5OiAnQXBwbGljYWJsZScgYXMgY29uc3QsXHJcbiAgICAgICAgICAgIHN0YXR1czogJ05vdCBTdGFydGVkJyBhcyBjb25zdCxcclxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb25TdGF0dXM6ICdPcGVuJyBhcyBjb25zdCxcclxuICAgICAgICAgICAgY2NpUmVmOiByZXEuY2NpICYmIHJlcS5jY2kubGVuZ3RoID4gMCA/IHJlcS5jY2kgOiBbJ0NDSS0wMDAzNjYnXSxcclxuICAgICAgICAgICAgZmFtaWx5OiBmYW1pbHlJZFxyXG4gICAgICAgICAgfSBhcyBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBMb2cgc2V2ZXJpdHkgZGlzdHJpYnV0aW9uIGFmdGVyIGNvbnZlcnNpb25cclxuICAgICAgICBjb25zdCBjb252ZXJ0ZWRDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuICAgICAgICBjb252ZXJ0ZWQuZm9yRWFjaChyZXEgPT4ge1xyXG4gICAgICAgICAgY29udmVydGVkQ291bnRzW3JlcS5zZXZlcml0eV0gPSAoY29udmVydGVkQ291bnRzW3JlcS5zZXZlcml0eV0gfHwgMCkgKyAxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFNldmVyaXR5IGRpc3RyaWJ1dGlvbiBhZnRlciBjb252ZXJzaW9uOmAsIGNvbnZlcnRlZENvdW50cyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYWxsUmVxdWlyZW1lbnRzLnB1c2goLi4uY29udmVydGVkKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBsb2FkZWQgJHtjb252ZXJ0ZWQubGVuZ3RofSByZXF1aXJlbWVudHMgZm9yICR7ZmFtaWx5SWR9YCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgZmV0Y2hpbmcgU1RJRyBmb3IgJHtmYW1pbHlJZH06YCwgZXJyKTtcclxuICAgICAgZmFpbGVkRmV0Y2hlcy5wdXNoKGAke2ZhbWlseUlkfSDihpIgJHtzdGlndmlld2VySWR9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFNob3cgdXNlci1mcmllbmRseSBtZXNzYWdlIGlmIGZldGNoZXMgZmFpbGVkXHJcbiAgaWYgKGZhaWxlZEZldGNoZXMubGVuZ3RoID4gMCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgY29uc29sZS53YXJuKGBcXG7imqDvuI8gU1RJRyBJTVBPUlQgSVNTVUVcXG5gICtcclxuICAgICAgYEZhaWxlZCB0byBhdXRvbWF0aWNhbGx5IGZldGNoICR7ZmFpbGVkRmV0Y2hlcy5sZW5ndGh9IFNUSUcocyk6XFxuYCArXHJcbiAgICAgIGZhaWxlZEZldGNoZXMubWFwKGYgPT4gYCAg4oCiICR7Zn1gKS5qb2luKCdcXG4nKSArICdcXG5cXG4nICtcclxuICAgICAgYFBvc3NpYmxlIHJlYXNvbnM6XFxuYCArXHJcbiAgICAgIGAgIOKAoiBTVElHIElEIG1hcHBpbmcgbWF5IGJlIGluY29ycmVjdCBmb3Igc3RpZ3ZpZXdlci5jb21cXG5gICtcclxuICAgICAgYCAg4oCiIFNUSUcgbWF5IG5vdCBiZSBhdmFpbGFibGUgb24gc3RpZ3ZpZXdlci5jb21cXG5gICtcclxuICAgICAgYCAg4oCiIE5ldHdvcmsgY29ubmVjdGl2aXR5IGlzc3Vlc1xcblxcbmAgK1xyXG4gICAgICBgTUFOVUFMIFVQTE9BRCBPUFRJT05TOlxcbmAgK1xyXG4gICAgICBgICAxLiBEb3dubG9hZCBTVElHIFhNTCBmcm9tIERJU0E6IGh0dHBzOi8vcHVibGljLmN5YmVyLm1pbC9zdGlncy9kb3dubG9hZHMvXFxuYCArXHJcbiAgICAgIGAgIDIuIE9yIGJyb3dzZSBTVElHczogaHR0cHM6Ly9zdGlndmlld2VyLmNvbS9zdGlnc1xcbmAgK1xyXG4gICAgICBgICAzLiBVc2UgdGhlIFNUSUcgSW1wb3J0IGNvbXBvbmVudCB0byB1cGxvYWQgdGhlIFhDQ0RGIFhNTCBmaWxlXFxuYCk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBhbGxSZXF1aXJlbWVudHM7XHJcbn1cclxuLy8gTmV3OiBGZXRjaCBhbmQgY29udmVydCBTVElHIENTVnMgZGlyZWN0bHkgdG8gdGhlIG1hdHJpeCBmb3JtYXQgKFN0aWdSZXF1aXJlbWVudFtdKVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRDb252ZXJ0U3RpZ1JlcXVpcmVtZW50c1RvTWF0cml4KGZhbWlseUlkczogc3RyaW5nW10pOiBQcm9taXNlPFN0aWdSZXF1aXJlbWVudFtdPiB7XHJcbiAgY29uc3QgZGV0YWlsZWQgPSBhd2FpdCBmZXRjaEFuZENvbnZlcnRTdGlnUmVxdWlyZW1lbnRzKGZhbWlseUlkcyk7XHJcbiAgY29uc3QgYWxsOiBTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG4gIGRldGFpbGVkLmZvckVhY2goKHJlcSwgaW5kZXgpID0+IHtcclxuICAgIGNvbnN0IGZhbWlseUlkID0gcmVxLmZhbWlseSB8fCAndW5rbm93bic7XHJcbiAgICBhbGwucHVzaCh7XHJcbiAgICAgIGlkOiBgJHtmYW1pbHlJZH0tJHtEYXRlLm5vdygpfS0ke2luZGV4fWAsXHJcbiAgICAgIC4uLnJlcSxcclxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBhbGw7XHJcbn1cclxuXHJcbi8vIExlZ2FjeSBmdW5jdGlvbiBuYW1lIHN1cHBvcnRcclxuZXhwb3J0IGNvbnN0IGNvbnZlcnRUb1N0aWdSZXF1aXJlbWVudHMgPSBjb252ZXJ0U3RpZ1JlcXVpcmVtZW50c1RvTWF0cml4O1xyXG5cclxuLy8gRW1wdHkgZGF0YWJhc2UgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuZXhwb3J0IGNvbnN0IHN0aWdSZXF1aXJlbWVudHNEYXRhYmFzZTogeyBbZmFtaWx5SWQ6IHN0cmluZ106IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10gfSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEdyb3VwIFNUSUcgcmVxdWlyZW1lbnRzIGJ5IHRpdGxlIHRvIGF2b2lkIGR1cGxpY2F0ZSBkaXNwbGF5XHJcbiAqIFJlcXVpcmVtZW50cyB3aXRoIHRoZSBzYW1lIHRpdGxlIGFyZSBncm91cGVkIHRvZ2V0aGVyIHdpdGggYSBjb3VudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwU3RpZ1JlcXVpcmVtZW50c0J5VGl0bGUocmVxdWlyZW1lbnRzOiBTdGlnUmVxdWlyZW1lbnRbXSk6IEdyb3VwZWRTdGlnUmVxdWlyZW1lbnRbXSB7XHJcbiAgY29uc3QgZ3JvdXBlZE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBHcm91cGVkU3RpZ1JlcXVpcmVtZW50PigpO1xyXG5cclxuICByZXF1aXJlbWVudHMuZm9yRWFjaChyZXEgPT4ge1xyXG4gICAgY29uc3Qga2V5ID0gcmVxLnRpdGxlLnRyaW0oKTtcclxuICAgIFxyXG4gICAgaWYgKGdyb3VwZWRNYXAuaGFzKGtleSkpIHtcclxuICAgICAgY29uc3QgZXhpc3RpbmcgPSBncm91cGVkTWFwLmdldChrZXkpITtcclxuICAgICAgZXhpc3RpbmcuY291bnQgKz0gMTtcclxuICAgICAgZXhpc3Rpbmcuc3RpZ0lkcy5wdXNoKHJlcS5zdGlnSWQpO1xyXG4gICAgICBleGlzdGluZy5yZXF1aXJlbWVudHMucHVzaChyZXEpO1xyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIHN0YXR1cyB0byBoaWdoZXN0IHByaW9yaXR5IHN0YXR1c1xyXG4gICAgICBpZiAocmVxLnN0YXR1cyA9PT0gJ0NvbXBsZXRlZCcgJiYgZXhpc3Rpbmcuc3RhdHVzICE9PSAnQ29tcGxldGVkJykge1xyXG4gICAgICAgIGV4aXN0aW5nLnN0YXR1cyA9ICdDb21wbGV0ZWQnO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlcS5zdGF0dXMgPT09ICdJbiBQcm9ncmVzcycgJiYgZXhpc3Rpbmcuc3RhdHVzID09PSAnTm90IFN0YXJ0ZWQnKSB7XHJcbiAgICAgICAgZXhpc3Rpbmcuc3RhdHVzID0gJ0luIFByb2dyZXNzJztcclxuICAgICAgfSBlbHNlIGlmIChyZXEuc3RhdHVzID09PSAnRXhjZXB0aW9uIFJlcXVlc3RlZCcpIHtcclxuICAgICAgICBleGlzdGluZy5zdGF0dXMgPSAnRXhjZXB0aW9uIFJlcXVlc3RlZCc7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBpbXBsZW1lbnRhdGlvbiBzdGF0dXMgdG8gbW9zdCBzZXZlcmVcclxuICAgICAgaWYgKHJlcS5pbXBsZW1lbnRhdGlvblN0YXR1cyA9PT0gJ09wZW4nICYmIGV4aXN0aW5nLmltcGxlbWVudGF0aW9uU3RhdHVzICE9PSAnT3BlbicpIHtcclxuICAgICAgICBleGlzdGluZy5pbXBsZW1lbnRhdGlvblN0YXR1cyA9ICdPcGVuJztcclxuICAgICAgfSBlbHNlIGlmIChyZXEuaW1wbGVtZW50YXRpb25TdGF0dXMgPT09ICdOb3RBRmluZGluZycgJiYgZXhpc3RpbmcuaW1wbGVtZW50YXRpb25TdGF0dXMgPT09ICdOb3RfQXBwbGljYWJsZScpIHtcclxuICAgICAgICBleGlzdGluZy5pbXBsZW1lbnRhdGlvblN0YXR1cyA9ICdOb3RBRmluZGluZyc7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGdyb3VwZWRNYXAuc2V0KGtleSwge1xyXG4gICAgICAgIHRpdGxlOiByZXEudGl0bGUsXHJcbiAgICAgICAgY291bnQ6IDEsXHJcbiAgICAgICAgZmFtaWx5OiByZXEuZmFtaWx5LFxyXG4gICAgICAgIHNldmVyaXR5OiByZXEuc2V2ZXJpdHksXHJcbiAgICAgICAgZGVzY3JpcHRpb246IHJlcS5kZXNjcmlwdGlvbixcclxuICAgICAgICBjaGVja1RleHQ6IHJlcS5jaGVja1RleHQsXHJcbiAgICAgICAgZml4VGV4dDogcmVxLmZpeFRleHQsXHJcbiAgICAgICAgc3RpZ0lkczogW3JlcS5zdGlnSWRdLFxyXG4gICAgICAgIHJlcXVpcmVtZW50czogW3JlcV0sXHJcbiAgICAgICAgc3RhdHVzOiByZXEuc3RhdHVzLFxyXG4gICAgICAgIGltcGxlbWVudGF0aW9uU3RhdHVzOiByZXEuaW1wbGVtZW50YXRpb25TdGF0dXNcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBBcnJheS5mcm9tKGdyb3VwZWRNYXAudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IHtcclxuICAgIC8vIFNvcnQgYnkgc2V2ZXJpdHkgZmlyc3QgKENBVCBJID4gQ0FUIElJID4gQ0FUIElJSSksIHRoZW4gYnkgdGl0bGVcclxuICAgIGNvbnN0IHNldmVyaXR5T3JkZXIgPSB7ICdDQVQgSSc6IDEsICdDQVQgSUknOiAyLCAnQ0FUIElJSSc6IDMgfTtcclxuICAgIGNvbnN0IHNldmVyaXR5RGlmZiA9IHNldmVyaXR5T3JkZXJbYS5zZXZlcml0eV0gLSBzZXZlcml0eU9yZGVyW2Iuc2V2ZXJpdHldO1xyXG4gICAgaWYgKHNldmVyaXR5RGlmZiAhPT0gMCkgcmV0dXJuIHNldmVyaXR5RGlmZjtcclxuICAgIHJldHVybiBhLnRpdGxlLmxvY2FsZUNvbXBhcmUoYi50aXRsZSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdW5pcXVlIGNvdW50IG9mIFNUSUcgcmVxdWlyZW1lbnRzIGJ5IHRpdGxlIGZvciBhIGZhbWlseVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXF1ZVN0aWdSZXF1aXJlbWVudENvdW50KGZhbWlseUlkOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gIGNvbnN0IHJlcXVpcmVtZW50cyA9IGdldFN0b3JlZFN0aWdSZXF1aXJlbWVudHMoZmFtaWx5SWQpO1xyXG4gIGNvbnN0IHRpdGxlU2V0ID0gbmV3IFNldChyZXF1aXJlbWVudHMubWFwKHJlcSA9PiByZXEudGl0bGU/LnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pKTtcclxuICByZXR1cm4gdGl0bGVTZXQuc2l6ZTtcclxufSJdLCJuYW1lcyI6WyJTVElHX0lEX01BUFBJTkciLCJtYXBUb1N0aWdWaWV3ZXJJZCIsImludGVybmFsSWQiLCJjb252ZXJ0Q3N2VG9TdGlnUmVxdWlyZW1lbnQiLCJjc3ZSb3ciLCJub3JtYWxpemVTZXZlcml0eSIsInNldmVyaXR5Iiwic2V2IiwidG9Mb3dlckNhc2UiLCJjY2lSZWZzIiwiY2NpcyIsInNwbGl0IiwiZmlsdGVyIiwibGluZSIsImluY2x1ZGVzIiwibWFwIiwibWF0Y2giLCJjY2kiLCJub3JtYWxpemVTdGF0dXMiLCJzdGF0dXMiLCJzdGF0Iiwic3RpZ0lkIiwicnVsZUlkIiwidnVsbklkIiwiZ3JvdXBJZCIsInVuZGVmaW5lZCIsInRpdGxlIiwicnVsZVRpdGxlIiwiZGVzY3JpcHRpb24iLCJkaXNjdXNzaW9uIiwiY2hlY2tUZXh0IiwiY2hlY2tDb250ZW50IiwiZml4VGV4dCIsImFwcGxpY2FiaWxpdHkiLCJpbXBsZW1lbnRhdGlvblN0YXR1cyIsImNjaVJlZiIsInBhcnNlU3RpZ0NzdiIsImNzdkNvbnRlbnQiLCJmYW1pbHlJZCIsImxpbmVzIiwibGVuZ3RoIiwiaGVhZGVycyIsImgiLCJyZXBsYWNlIiwidHJpbSIsInJlcXVpcmVtZW50cyIsImkiLCJ2YWx1ZXMiLCJjdXJyZW50IiwiaW5RdW90ZXMiLCJqIiwiY2hhciIsInB1c2giLCJmb3JFYWNoIiwiaGVhZGVyIiwiaW5kZXgiLCJ2YWx1ZSIsImJlbmNobWFya05hbWUiLCJiZW5jaG1hcmtJZCIsInJlcXVpcmVtZW50IiwiZmFtaWx5IiwidXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzIiwic3RvcmVTdGlnUmVxdWlyZW1lbnRzIiwiZ2V0U3RvcmVkU3RpZ1JlcXVpcmVtZW50cyIsImdldEFsbFN0b3JlZFN0aWdSZXF1aXJlbWVudHMiLCJhbGxSZXF1aXJlbWVudHMiLCJPYmplY3QiLCJrZXlzIiwiZmFtaWx5UmVxdWlyZW1lbnRzIiwicmVxIiwiaWQiLCJEYXRlIiwibm93IiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiY2xlYXJTdG9yZWRTdGlnUmVxdWlyZW1lbnRzIiwia2V5IiwiZ2V0RGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRzIiwic3RpZ0ZhbWlseUlkIiwiY29udmVydFN0aWdSZXF1aXJlbWVudHNUb01hdHJpeCIsInN0aWdGYW1pbHlJZHMiLCJjb25zb2xlIiwibG9nIiwiZGV0YWlsZWRSZXF1aXJlbWVudHMiLCJmZXRjaEFuZENvbnZlcnRTdGlnUmVxdWlyZW1lbnRzIiwiZmFtaWx5SWRzIiwiZmFpbGVkRmV0Y2hlcyIsInN0aWd2aWV3ZXJJZCIsImFwaVVybCIsImVuY29kZVVSSUNvbXBvbmVudCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiYXBpUmVzIiwiZmV0Y2giLCJyZXN1bHQiLCJqc29uIiwib2siLCJzdWNjZXNzIiwid2FybiIsImVycm9yIiwibWVzc2FnZSIsInNldmVyaXR5Q291bnRzIiwiY29udmVydGVkIiwic2V2VGV4dCIsImNvbnZlcnRlZENvdW50cyIsImVyciIsImYiLCJqb2luIiwiZmV0Y2hBbmRDb252ZXJ0U3RpZ1JlcXVpcmVtZW50c1RvTWF0cml4IiwiZGV0YWlsZWQiLCJhbGwiLCJjb252ZXJ0VG9TdGlnUmVxdWlyZW1lbnRzIiwic3RpZ1JlcXVpcmVtZW50c0RhdGFiYXNlIiwiZ3JvdXBTdGlnUmVxdWlyZW1lbnRzQnlUaXRsZSIsImdyb3VwZWRNYXAiLCJNYXAiLCJoYXMiLCJleGlzdGluZyIsImdldCIsImNvdW50Iiwic3RpZ0lkcyIsInNldCIsIkFycmF5IiwiZnJvbSIsInNvcnQiLCJhIiwiYiIsInNldmVyaXR5T3JkZXIiLCJzZXZlcml0eURpZmYiLCJsb2NhbGVDb21wYXJlIiwiZ2V0VW5pcXVlU3RpZ1JlcXVpcmVtZW50Q291bnQiLCJ0aXRsZVNldCIsIlNldCIsIkJvb2xlYW4iLCJzaXplIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/detailedStigRequirements.ts\n"));

/***/ })

});