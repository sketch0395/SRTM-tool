"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/detailedStigRequirements.ts":
/*!*******************************************!*\
  !*** ./utils/detailedStigRequirements.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearStoredStigRequirements: () => (/* binding */ clearStoredStigRequirements),\n/* harmony export */   convertCsvToStigRequirement: () => (/* binding */ convertCsvToStigRequirement),\n/* harmony export */   convertStigRequirementsToMatrix: () => (/* binding */ convertStigRequirementsToMatrix),\n/* harmony export */   convertToStigRequirements: () => (/* binding */ convertToStigRequirements),\n/* harmony export */   fetchAndConvertStigRequirements: () => (/* binding */ fetchAndConvertStigRequirements),\n/* harmony export */   getAllStoredStigRequirements: () => (/* binding */ getAllStoredStigRequirements),\n/* harmony export */   getDetailedStigRequirements: () => (/* binding */ getDetailedStigRequirements),\n/* harmony export */   getStoredStigRequirements: () => (/* binding */ getStoredStigRequirements),\n/* harmony export */   parseStigCsv: () => (/* binding */ parseStigCsv),\n/* harmony export */   stigRequirementsDatabase: () => (/* binding */ stigRequirementsDatabase),\n/* harmony export */   storeStigRequirements: () => (/* binding */ storeStigRequirements),\n/* harmony export */   uploadedStigRequirements: () => (/* binding */ uploadedStigRequirements)\n/* harmony export */ });\n/**\r\n * STIG CSV Upload and Management\r\n * Handles parsing and processing of STIG CSV files\r\n */ // Function to convert CSV STIG data to our internal format\nfunction convertCsvToStigRequirement(csvRow) {\n    // Normalize severity values\n    const normalizeSeverity = (severity)=>{\n        const sev = severity.toLowerCase();\n        if (sev === 'high' || sev === 'cat i') return 'CAT I';\n        if (sev === 'medium' || sev === 'cat ii') return 'CAT II';\n        if (sev === 'low' || sev === 'cat iii') return 'CAT III';\n        return 'CAT II'; // default\n    };\n    // Extract CCI references\n    const cciRefs = csvRow.ccis ? csvRow.ccis.split('\\n').filter((line)=>line.includes('CCI-')).map((line)=>{\n        const match = line.match(/CCI-\\d+/);\n        return match ? match[0] : '';\n    }).filter((cci)=>cci) : [\n        'CCI-000366'\n    ];\n    // Normalize status values\n    const normalizeStatus = (status)=>{\n        if (!status) return 'Not Started';\n        const stat = status.toLowerCase();\n        if (stat.includes('progress') || stat.includes('ongoing')) return 'In Progress';\n        if (stat.includes('complete') || stat.includes('done')) return 'Completed';\n        if (stat.includes('exception') || stat.includes('waiver')) return 'Exception Requested';\n        return 'Not Started';\n    };\n    return {\n        stigId: csvRow.stigId || csvRow.ruleId || 'UNKNOWN',\n        vulnId: csvRow.groupId || undefined,\n        severity: normalizeSeverity(csvRow.severity),\n        title: csvRow.ruleTitle || 'Untitled Requirement',\n        description: csvRow.discussion || 'No description provided',\n        checkText: csvRow.checkContent || 'No check procedure provided',\n        fixText: csvRow.fixText || 'No fix procedure provided',\n        applicability: 'Applicable',\n        status: normalizeStatus(csvRow.status),\n        implementationStatus: 'Open',\n        cciRef: cciRefs\n    };\n}\n// Parse CSV content and return STIG requirements\nfunction parseStigCsv(csvContent, familyId) {\n    const lines = csvContent.split('\\n');\n    if (lines.length < 2) return [];\n    // Parse header row\n    const headers = lines[0].split(',').map((h)=>h.replace(/\"/g, '').trim().toLowerCase().replace(/\\s+/g, ''));\n    const requirements = [];\n    for(let i = 1; i < lines.length; i++){\n        const line = lines[i].trim();\n        if (!line) continue;\n        // Parse CSV row (handling quoted fields)\n        const values = [];\n        let current = '';\n        let inQuotes = false;\n        for(let j = 0; j < line.length; j++){\n            const char = line[j];\n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                values.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        values.push(current.trim()); // Add the last value\n        // Create CSV STIG object\n        const csvRow = {\n            severity: 'medium',\n            stigId: '',\n            ruleTitle: '',\n            fixText: '',\n            discussion: '',\n            checkContent: ''\n        };\n        // Map values to CSV STIG object based on headers\n        headers.forEach((header, index)=>{\n            if (values[index]) {\n                const value = values[index].replace(/^\"|\"$/g, ''); // Remove surrounding quotes\n                switch(header){\n                    case 'benchmarkname':\n                        csvRow.benchmarkName = value;\n                        break;\n                    case 'benchmarkid':\n                        csvRow.benchmarkId = value;\n                        break;\n                    case 'severity':\n                        csvRow.severity = value;\n                        break;\n                    case 'stigid':\n                        csvRow.stigId = value;\n                        break;\n                    case 'ruletitle':\n                        csvRow.ruleTitle = value;\n                        break;\n                    case 'fixtext':\n                        csvRow.fixText = value;\n                        break;\n                    case 'discussion':\n                        csvRow.discussion = value;\n                        break;\n                    case 'checkcontent':\n                        csvRow.checkContent = value;\n                        break;\n                    case 'ccis':\n                        csvRow.ccis = value;\n                        break;\n                    case 'groupid':\n                        csvRow.groupId = value;\n                        break;\n                    case 'ruleid':\n                        csvRow.ruleId = value;\n                        break;\n                    case 'status':\n                        csvRow.status = value;\n                        break;\n                }\n            }\n        });\n        // Convert to our internal format\n        if (csvRow.stigId && csvRow.ruleTitle) {\n            const requirement = convertCsvToStigRequirement(csvRow);\n            if (familyId) {\n                requirement.family = familyId;\n            }\n            requirements.push(requirement);\n        }\n    }\n    return requirements;\n}\n// Database for managing uploaded STIG requirements\nconst uploadedStigRequirements = {};\n// Function to store uploaded STIG requirements\nfunction storeStigRequirements(familyId, requirements) {\n    uploadedStigRequirements[familyId] = requirements;\n}\n// Function to get stored STIG requirements\nfunction getStoredStigRequirements(familyId) {\n    return uploadedStigRequirements[familyId] || [];\n}\n// Function to get all stored STIG requirements across all families\nfunction getAllStoredStigRequirements() {\n    const allRequirements = [];\n    Object.keys(uploadedStigRequirements).forEach((familyId)=>{\n        const familyRequirements = uploadedStigRequirements[familyId];\n        familyRequirements.forEach((req, index)=>{\n            allRequirements.push({\n                id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n                family: req.family || familyId,\n                ...req,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n        });\n    });\n    return allRequirements;\n}\n// Function to clear stored STIG requirements\nfunction clearStoredStigRequirements(familyId) {\n    if (familyId) {\n        delete uploadedStigRequirements[familyId];\n    } else {\n        // Clear all\n        Object.keys(uploadedStigRequirements).forEach((key)=>{\n            delete uploadedStigRequirements[key];\n        });\n    }\n}\n/**\r\n * Get detailed STIG requirements for a given STIG family ID\r\n * Now supports uploaded CSV data\r\n */ function getDetailedStigRequirements(stigFamilyId) {\n    // Return stored uploaded requirements\n    return getStoredStigRequirements(stigFamilyId);\n}\n/**\r\n * Convert STIG requirements to the format expected by the traceability matrix\r\n */ function convertStigRequirementsToMatrix(stigFamilyIds) {\n    console.log('Converting STIG requirements for families:', stigFamilyIds);\n    const allRequirements = [];\n    stigFamilyIds.forEach((familyId)=>{\n        const detailedRequirements = getStoredStigRequirements(familyId);\n        console.log(\"Found \".concat(detailedRequirements.length, \" requirements for family: \").concat(familyId));\n        detailedRequirements.forEach((req, index)=>{\n            allRequirements.push({\n                id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n                ...req,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n        });\n    });\n    console.log(\"Total converted requirements: \".concat(allRequirements.length));\n    return allRequirements;\n}\n// New: Fetch STIG CSV from stigviewer and convert to requirements\nasync function fetchAndConvertStigRequirements(familyIds) {\n    const allRequirements = [];\n    for (const familyId of familyIds){\n        try {\n            // Construct CSV download URL (CSV endpoint)\n            const url = \"https://stigviewer.com/stigs/download/\".concat(familyId, \".csv\");\n            const response = await fetch(url);\n            if (!response.ok) {\n                console.error(\"Failed to fetch STIG CSV for \".concat(familyId, \": \").concat(response.status));\n                continue;\n            }\n            const csvText = await response.text();\n            const detailed = parseStigCsv(csvText, familyId);\n            allRequirements.push(...detailed);\n        } catch (err) {\n            console.error(\"Error fetching STIG for \".concat(familyId, \":\"), err);\n        }\n    }\n    return allRequirements;\n}\n// Legacy function name support\nconst convertToStigRequirements = convertStigRequirementsToMatrix;\n// Empty database for backward compatibility\nconst stigRequirementsDatabase = {};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2RldGFpbGVkU3RpZ1JlcXVpcmVtZW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FvREQsMkRBQTJEO0FBQ3BELFNBQVNBLDRCQUE0QkMsTUFBMEI7SUFDcEUsNEJBQTRCO0lBQzVCLE1BQU1DLG9CQUFvQixDQUFDQztRQUN6QixNQUFNQyxNQUFNRCxTQUFTRSxXQUFXO1FBQ2hDLElBQUlELFFBQVEsVUFBVUEsUUFBUSxTQUFTLE9BQU87UUFDOUMsSUFBSUEsUUFBUSxZQUFZQSxRQUFRLFVBQVUsT0FBTztRQUNqRCxJQUFJQSxRQUFRLFNBQVNBLFFBQVEsV0FBVyxPQUFPO1FBQy9DLE9BQU8sVUFBVSxVQUFVO0lBQzdCO0lBRUEseUJBQXlCO0lBQ3pCLE1BQU1FLFVBQVVMLE9BQU9NLElBQUksR0FDekJOLE9BQU9NLElBQUksQ0FBQ0MsS0FBSyxDQUFDLE1BQU1DLE1BQU0sQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0MsUUFBUSxDQUFDLFNBQVNDLEdBQUcsQ0FBQ0YsQ0FBQUE7UUFDaEUsTUFBTUcsUUFBUUgsS0FBS0csS0FBSyxDQUFDO1FBQ3pCLE9BQU9BLFFBQVFBLEtBQUssQ0FBQyxFQUFFLEdBQUc7SUFDNUIsR0FBR0osTUFBTSxDQUFDSyxDQUFBQSxNQUFPQSxPQUFPO1FBQUM7S0FBYTtJQUV4QywwQkFBMEI7SUFDMUIsTUFBTUMsa0JBQWtCLENBQUNDO1FBQ3ZCLElBQUksQ0FBQ0EsUUFBUSxPQUFPO1FBQ3BCLE1BQU1DLE9BQU9ELE9BQU9YLFdBQVc7UUFDL0IsSUFBSVksS0FBS04sUUFBUSxDQUFDLGVBQWVNLEtBQUtOLFFBQVEsQ0FBQyxZQUFZLE9BQU87UUFDbEUsSUFBSU0sS0FBS04sUUFBUSxDQUFDLGVBQWVNLEtBQUtOLFFBQVEsQ0FBQyxTQUFTLE9BQU87UUFDL0QsSUFBSU0sS0FBS04sUUFBUSxDQUFDLGdCQUFnQk0sS0FBS04sUUFBUSxDQUFDLFdBQVcs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QUN2RSxNQUFNcEIsa0JBQTZDLEVBQUU7SUFDckQsS0FBSyxNQUFNM0IsWUFBWStDLFVBQVc7UUFDaEMsSUFBSTtZQUNGLDRDQUE0QztZQUM1QyxNQUFNQyxNQUFNLHlDQUFrRCxPQUFUaEQsVUFBUztZQUM5RCxNQUFNaUQsV0FBVyxNQUFNQyxNQUFNRjtZQUM3QixJQUFJLENBQUNDLFNBQVNFLEVBQUUsRUFBRTtnQkFDaEJSLFFBQVFTLEtBQUssQ0FBQyxnQ0FBNkNILE9BQWJqRCxVQUFTLE1BQW9CLE9BQWhCaUQsU0FBU3BFLE1BQU07Z0JBQzFFO1lBQ0Y7WUFDQSxNQUFNd0UsVUFBVSxNQUFNSixTQUFTSyxJQUFJO1lBQ25DLE1BQU1DLFdBQVd6RCxhQUFhdUQsU0FBU3JEO1lBQ3ZDMkIsZ0JBQWdCYixJQUFJLElBQUl5QztRQUMxQixFQUFFLE9BQU9DLEtBQUs7WUFDWmIsUUFBUVMsS0FBSyxDQUFDLDJCQUFvQyxPQUFUcEQsVUFBUyxNQUFJd0Q7UUFDeEQ7SUFDRjtJQUNBLE9BQU83QjtBQUNUO0FBRUEsK0JBQStCO0FBQ3hCLE1BQU04Qiw0QkFBNEJoQixnQ0FBZ0M7QUFFekUsNENBQTRDO0FBQ3JDLE1BQU1pQiwyQkFBOEUsQ0FBQyxFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHJvbm5pXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamVjdHNcXFNSVE0tdG9vbFxcdXRpbHNcXGRldGFpbGVkU3RpZ1JlcXVpcmVtZW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU1RJRyBDU1YgVXBsb2FkIGFuZCBNYW5hZ2VtZW50XHJcbiAqIEhhbmRsZXMgcGFyc2luZyBhbmQgcHJvY2Vzc2luZyBvZiBTVElHIENTViBmaWxlc1xyXG4gKi9cclxuXHJcbmltcG9ydCB7IFN0aWdSZXF1aXJlbWVudCB9IGZyb20gJy4uL3R5cGVzL3NydG0nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudCBleHRlbmRzIE9taXQ8U3RpZ1JlcXVpcmVtZW50LCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAndXBkYXRlZEF0Jz4ge1xyXG4gIC8vIEFsbCBvdGhlciBmaWVsZHMgZnJvbSBTdGlnUmVxdWlyZW1lbnQgaW50ZXJmYWNlXHJcbiAgZmFtaWx5Pzogc3RyaW5nOyAvLyBBZGQgZmFtaWx5IHRyYWNraW5nXHJcbn1cclxuXHJcbi8vIENTViBVcGxvYWQgU3VwcG9ydCBmb3IgU1RJRyBSZXF1aXJlbWVudHNcclxuZXhwb3J0IGludGVyZmFjZSBDc3ZTdGlnUmVxdWlyZW1lbnQge1xyXG4gIGJlbmNobWFya05hbWU/OiBzdHJpbmc7XHJcbiAgYmVuY2htYXJrSWQ/OiBzdHJpbmc7XHJcbiAgcmVsZWFzZUluZm8/OiBzdHJpbmc7XHJcbiAgdmVyc2lvbj86IHN0cmluZztcclxuICBncm91cElkPzogc3RyaW5nO1xyXG4gIHNldmVyaXR5OiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnIHwgJ0NBVCBJJyB8ICdDQVQgSUknIHwgJ0NBVCBJSUknO1xyXG4gIHJ1bGVJZD86IHN0cmluZztcclxuICBzdGlnSWQ6IHN0cmluZztcclxuICBjbGFzc2lmaWNhdGlvbj86IHN0cmluZztcclxuICBhc3NldFBvc3R1cmU/OiBzdHJpbmc7XHJcbiAgc3JnSWQ/OiBzdHJpbmc7XHJcbiAgcnVsZVRpdGxlOiBzdHJpbmc7XHJcbiAgZml4VGV4dDogc3RyaW5nO1xyXG4gIGRpc2N1c3Npb246IHN0cmluZztcclxuICBjY2lzPzogc3RyaW5nO1xyXG4gIGxlZ2FjeUlkcz86IHN0cmluZztcclxuICBjaGVja0NvbnRlbnQ6IHN0cmluZztcclxuICBjaGVja0NvbnRlbnRSZWY/OiBzdHJpbmc7XHJcbiAgaWFDb250cm9scz86IHN0cmluZztcclxuICB3ZWlnaHQ/OiBzdHJpbmc7XHJcbiAgZmFsc2VQb3NpdGl2ZXM/OiBzdHJpbmc7XHJcbiAgZmFsc2VOZWdhdGl2ZXM/OiBzdHJpbmc7XHJcbiAgZG9jdW1lbnRhYmxlPzogc3RyaW5nO1xyXG4gIHNlY3VyaXR5T3ZlcnJpZGVHdWlkYW5jZT86IHN0cmluZztcclxuICBwb3RlbnRpYWxJbXBhY3RzPzogc3RyaW5nO1xyXG4gIHRoaXJkUGFydHlUb29scz86IHN0cmluZztcclxuICByZXNwb25zaWJpbGl0eT86IHN0cmluZztcclxuICBtaXRpZ2F0aW9ucz86IHN0cmluZztcclxuICBtaXRpZ2F0aW9uQ29udHJvbD86IHN0cmluZztcclxuICBzdGF0dXM/OiBzdHJpbmc7XHJcbiAgY29tbWVudHM/OiBzdHJpbmc7XHJcbiAgZmluZGluZ0RldGFpbHM/OiBzdHJpbmc7XHJcbiAgc2V2ZXJpdHlPdmVycmlkZT86IHN0cmluZztcclxuICBzZXZlcml0eU92ZXJyaWRlUmVhc29uPzogc3RyaW5nO1xyXG4gIGZxZG4/OiBzdHJpbmc7XHJcbiAgaXBBZGRyZXNzPzogc3RyaW5nO1xyXG4gIG1hY0FkZHJlc3M/OiBzdHJpbmc7XHJcbiAgbmFtZT86IHN0cmluZztcclxuICB0ZWNobm9sb2d5QXJlYT86IHN0cmluZztcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gY29udmVydCBDU1YgU1RJRyBkYXRhIHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRDc3ZUb1N0aWdSZXF1aXJlbWVudChjc3ZSb3c6IENzdlN0aWdSZXF1aXJlbWVudCk6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50IHtcclxuICAvLyBOb3JtYWxpemUgc2V2ZXJpdHkgdmFsdWVzXHJcbiAgY29uc3Qgbm9ybWFsaXplU2V2ZXJpdHkgPSAoc2V2ZXJpdHk6IHN0cmluZyk6ICdDQVQgSScgfCAnQ0FUIElJJyB8ICdDQVQgSUlJJyA9PiB7XHJcbiAgICBjb25zdCBzZXYgPSBzZXZlcml0eS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKHNldiA9PT0gJ2hpZ2gnIHx8IHNldiA9PT0gJ2NhdCBpJykgcmV0dXJuICdDQVQgSSc7XHJcbiAgICBpZiAoc2V2ID09PSAnbWVkaXVtJyB8fCBzZXYgPT09ICdjYXQgaWknKSByZXR1cm4gJ0NBVCBJSSc7XHJcbiAgICBpZiAoc2V2ID09PSAnbG93JyB8fCBzZXYgPT09ICdjYXQgaWlpJykgcmV0dXJuICdDQVQgSUlJJztcclxuICAgIHJldHVybiAnQ0FUIElJJzsgLy8gZGVmYXVsdFxyXG4gIH07XHJcblxyXG4gIC8vIEV4dHJhY3QgQ0NJIHJlZmVyZW5jZXNcclxuICBjb25zdCBjY2lSZWZzID0gY3N2Um93LmNjaXMgPyBcclxuICAgIGNzdlJvdy5jY2lzLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLmluY2x1ZGVzKCdDQ0ktJykpLm1hcChsaW5lID0+IHtcclxuICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKC9DQ0ktXFxkKy8pO1xyXG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xyXG4gICAgfSkuZmlsdGVyKGNjaSA9PiBjY2kpIDogWydDQ0ktMDAwMzY2J107XHJcblxyXG4gIC8vIE5vcm1hbGl6ZSBzdGF0dXMgdmFsdWVzXHJcbiAgY29uc3Qgbm9ybWFsaXplU3RhdHVzID0gKHN0YXR1cz86IHN0cmluZyk6ICdOb3QgU3RhcnRlZCcgfCAnSW4gUHJvZ3Jlc3MnIHwgJ0NvbXBsZXRlZCcgfCAnRXhjZXB0aW9uIFJlcXVlc3RlZCcgPT4ge1xyXG4gICAgaWYgKCFzdGF0dXMpIHJldHVybiAnTm90IFN0YXJ0ZWQnO1xyXG4gICAgY29uc3Qgc3RhdCA9IHN0YXR1cy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKHN0YXQuaW5jbHVkZXMoJ3Byb2dyZXNzJykgfHwgc3RhdC5pbmNsdWRlcygnb25nb2luZycpKSByZXR1cm4gJ0luIFByb2dyZXNzJztcclxuICAgIGlmIChzdGF0LmluY2x1ZGVzKCdjb21wbGV0ZScpIHx8IHN0YXQuaW5jbHVkZXMoJ2RvbmUnKSkgcmV0dXJuICdDb21wbGV0ZWQnO1xyXG4gICAgaWYgKHN0YXQuaW5jbHVkZXMoJ2V4Y2VwdGlvbicpIHx8IHN0YXQuaW5jbHVkZXMoJ3dhaXZlcicpKSByZXR1cm4gJ0V4Y2VwdGlvbiBSZXF1ZXN0ZWQnO1xyXG4gICAgcmV0dXJuICdOb3QgU3RhcnRlZCc7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN0aWdJZDogY3N2Um93LnN0aWdJZCB8fCBjc3ZSb3cucnVsZUlkIHx8ICdVTktOT1dOJyxcclxuICAgIHZ1bG5JZDogY3N2Um93Lmdyb3VwSWQgfHwgdW5kZWZpbmVkLFxyXG4gICAgc2V2ZXJpdHk6IG5vcm1hbGl6ZVNldmVyaXR5KGNzdlJvdy5zZXZlcml0eSksXHJcbiAgICB0aXRsZTogY3N2Um93LnJ1bGVUaXRsZSB8fCAnVW50aXRsZWQgUmVxdWlyZW1lbnQnLFxyXG4gICAgZGVzY3JpcHRpb246IGNzdlJvdy5kaXNjdXNzaW9uIHx8ICdObyBkZXNjcmlwdGlvbiBwcm92aWRlZCcsXHJcbiAgICBjaGVja1RleHQ6IGNzdlJvdy5jaGVja0NvbnRlbnQgfHwgJ05vIGNoZWNrIHByb2NlZHVyZSBwcm92aWRlZCcsXHJcbiAgICBmaXhUZXh0OiBjc3ZSb3cuZml4VGV4dCB8fCAnTm8gZml4IHByb2NlZHVyZSBwcm92aWRlZCcsXHJcbiAgICBhcHBsaWNhYmlsaXR5OiAnQXBwbGljYWJsZScsXHJcbiAgICBzdGF0dXM6IG5vcm1hbGl6ZVN0YXR1cyhjc3ZSb3cuc3RhdHVzKSxcclxuICAgIGltcGxlbWVudGF0aW9uU3RhdHVzOiAnT3BlbicsXHJcbiAgICBjY2lSZWY6IGNjaVJlZnNcclxuICB9O1xyXG59XHJcblxyXG4vLyBQYXJzZSBDU1YgY29udGVudCBhbmQgcmV0dXJuIFNUSUcgcmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0aWdDc3YoY3N2Q29udGVudDogc3RyaW5nLCBmYW1pbHlJZD86IHN0cmluZyk6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10ge1xyXG4gIGNvbnN0IGxpbmVzID0gY3N2Q29udGVudC5zcGxpdCgnXFxuJyk7XHJcbiAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHJldHVybiBbXTtcclxuXHJcbiAgLy8gUGFyc2UgaGVhZGVyIHJvd1xyXG4gIGNvbnN0IGhlYWRlcnMgPSBsaW5lc1swXS5zcGxpdCgnLCcpLm1hcChoID0+IGgucmVwbGFjZSgvXCIvZywgJycpLnRyaW0oKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJycpKTtcclxuICBcclxuICBjb25zdCByZXF1aXJlbWVudHM6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcclxuICAgIGlmICghbGluZSkgY29udGludWU7XHJcblxyXG4gICAgLy8gUGFyc2UgQ1NWIHJvdyAoaGFuZGxpbmcgcXVvdGVkIGZpZWxkcylcclxuICAgIGNvbnN0IHZhbHVlczogc3RyaW5nW10gPSBbXTtcclxuICAgIGxldCBjdXJyZW50ID0gJyc7XHJcbiAgICBsZXQgaW5RdW90ZXMgPSBmYWxzZTtcclxuXHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgY29uc3QgY2hhciA9IGxpbmVbal07XHJcbiAgICAgIFxyXG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xyXG4gICAgICAgIGluUXVvdGVzID0gIWluUXVvdGVzO1xyXG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICcsJyAmJiAhaW5RdW90ZXMpIHtcclxuICAgICAgICB2YWx1ZXMucHVzaChjdXJyZW50LnRyaW0oKSk7XHJcbiAgICAgICAgY3VycmVudCA9ICcnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFsdWVzLnB1c2goY3VycmVudC50cmltKCkpOyAvLyBBZGQgdGhlIGxhc3QgdmFsdWVcclxuXHJcbiAgICAvLyBDcmVhdGUgQ1NWIFNUSUcgb2JqZWN0XHJcbiAgICBjb25zdCBjc3ZSb3c6IENzdlN0aWdSZXF1aXJlbWVudCA9IHtcclxuICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nIGFzIGNvbnN0LFxyXG4gICAgICBzdGlnSWQ6ICcnLFxyXG4gICAgICBydWxlVGl0bGU6ICcnLFxyXG4gICAgICBmaXhUZXh0OiAnJyxcclxuICAgICAgZGlzY3Vzc2lvbjogJycsXHJcbiAgICAgIGNoZWNrQ29udGVudDogJydcclxuICAgIH07XHJcblxyXG4gICAgLy8gTWFwIHZhbHVlcyB0byBDU1YgU1RJRyBvYmplY3QgYmFzZWQgb24gaGVhZGVyc1xyXG4gICAgaGVhZGVycy5mb3JFYWNoKChoZWFkZXIsIGluZGV4KSA9PiB7XHJcbiAgICAgIGlmICh2YWx1ZXNbaW5kZXhdKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdLnJlcGxhY2UoL15cInxcIiQvZywgJycpOyAvLyBSZW1vdmUgc3Vycm91bmRpbmcgcXVvdGVzXHJcbiAgICAgICAgXHJcbiAgICAgICAgc3dpdGNoIChoZWFkZXIpIHtcclxuICAgICAgICAgIGNhc2UgJ2JlbmNobWFya25hbWUnOlxyXG4gICAgICAgICAgICBjc3ZSb3cuYmVuY2htYXJrTmFtZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2JlbmNobWFya2lkJzpcclxuICAgICAgICAgICAgY3N2Um93LmJlbmNobWFya0lkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnc2V2ZXJpdHknOlxyXG4gICAgICAgICAgICBjc3ZSb3cuc2V2ZXJpdHkgPSB2YWx1ZSBhcyBhbnk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnc3RpZ2lkJzpcclxuICAgICAgICAgICAgY3N2Um93LnN0aWdJZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3J1bGV0aXRsZSc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5ydWxlVGl0bGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdmaXh0ZXh0JzpcclxuICAgICAgICAgICAgY3N2Um93LmZpeFRleHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdkaXNjdXNzaW9uJzpcclxuICAgICAgICAgICAgY3N2Um93LmRpc2N1c3Npb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdjaGVja2NvbnRlbnQnOlxyXG4gICAgICAgICAgICBjc3ZSb3cuY2hlY2tDb250ZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnY2Npcyc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5jY2lzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnZ3JvdXBpZCc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5ncm91cElkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAncnVsZWlkJzpcclxuICAgICAgICAgICAgY3N2Um93LnJ1bGVJZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3N0YXR1cyc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5zdGF0dXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDb252ZXJ0IHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcclxuICAgIGlmIChjc3ZSb3cuc3RpZ0lkICYmIGNzdlJvdy5ydWxlVGl0bGUpIHtcclxuICAgICAgY29uc3QgcmVxdWlyZW1lbnQgPSBjb252ZXJ0Q3N2VG9TdGlnUmVxdWlyZW1lbnQoY3N2Um93KTtcclxuICAgICAgaWYgKGZhbWlseUlkKSB7XHJcbiAgICAgICAgcmVxdWlyZW1lbnQuZmFtaWx5ID0gZmFtaWx5SWQ7XHJcbiAgICAgIH1cclxuICAgICAgcmVxdWlyZW1lbnRzLnB1c2gocmVxdWlyZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlcXVpcmVtZW50cztcclxufVxyXG5cclxuLy8gRGF0YWJhc2UgZm9yIG1hbmFnaW5nIHVwbG9hZGVkIFNUSUcgcmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBjb25zdCB1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHM6IHsgW2ZhbWlseUlkOiBzdHJpbmddOiBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudFtdIH0gPSB7fTtcclxuXHJcbi8vIEZ1bmN0aW9uIHRvIHN0b3JlIHVwbG9hZGVkIFNUSUcgcmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9yZVN0aWdSZXF1aXJlbWVudHMoZmFtaWx5SWQ6IHN0cmluZywgcmVxdWlyZW1lbnRzOiBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudFtdKSB7XHJcbiAgdXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzW2ZhbWlseUlkXSA9IHJlcXVpcmVtZW50cztcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gZ2V0IHN0b3JlZCBTVElHIHJlcXVpcmVtZW50c1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVkU3RpZ1JlcXVpcmVtZW50cyhmYW1pbHlJZDogc3RyaW5nKTogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSB7XHJcbiAgcmV0dXJuIHVwbG9hZGVkU3RpZ1JlcXVpcmVtZW50c1tmYW1pbHlJZF0gfHwgW107XHJcbn1cclxuXHJcbi8vIEZ1bmN0aW9uIHRvIGdldCBhbGwgc3RvcmVkIFNUSUcgcmVxdWlyZW1lbnRzIGFjcm9zcyBhbGwgZmFtaWxpZXNcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFN0b3JlZFN0aWdSZXF1aXJlbWVudHMoKTogU3RpZ1JlcXVpcmVtZW50W10ge1xyXG4gIGNvbnN0IGFsbFJlcXVpcmVtZW50czogU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuICBcclxuICBPYmplY3Qua2V5cyh1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHMpLmZvckVhY2goZmFtaWx5SWQgPT4ge1xyXG4gICAgY29uc3QgZmFtaWx5UmVxdWlyZW1lbnRzID0gdXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzW2ZhbWlseUlkXTtcclxuICAgIGZhbWlseVJlcXVpcmVtZW50cy5mb3JFYWNoKChyZXEsIGluZGV4KSA9PiB7XHJcbiAgICAgIGFsbFJlcXVpcmVtZW50cy5wdXNoKHtcclxuICAgICAgICBpZDogYCR7ZmFtaWx5SWR9LSR7RGF0ZS5ub3coKX0tJHtpbmRleH1gLFxyXG4gICAgICAgIGZhbWlseTogcmVxLmZhbWlseSB8fCBmYW1pbHlJZCwgLy8gVXNlIHRoZSBmYW1pbHkgZnJvbSByZXF1aXJlbWVudCBvciBmYWxsYmFjayB0byBmYW1pbHlJZFxyXG4gICAgICAgIC4uLnJlcSxcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIGFsbFJlcXVpcmVtZW50cztcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gY2xlYXIgc3RvcmVkIFNUSUcgcmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhclN0b3JlZFN0aWdSZXF1aXJlbWVudHMoZmFtaWx5SWQ/OiBzdHJpbmcpIHtcclxuICBpZiAoZmFtaWx5SWQpIHtcclxuICAgIGRlbGV0ZSB1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHNbZmFtaWx5SWRdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBDbGVhciBhbGxcclxuICAgIE9iamVjdC5rZXlzKHVwbG9hZGVkU3RpZ1JlcXVpcmVtZW50cykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBkZWxldGUgdXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzW2tleV07XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgZGV0YWlsZWQgU1RJRyByZXF1aXJlbWVudHMgZm9yIGEgZ2l2ZW4gU1RJRyBmYW1pbHkgSURcclxuICogTm93IHN1cHBvcnRzIHVwbG9hZGVkIENTViBkYXRhXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRzKHN0aWdGYW1pbHlJZDogc3RyaW5nKTogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSB7XHJcbiAgLy8gUmV0dXJuIHN0b3JlZCB1cGxvYWRlZCByZXF1aXJlbWVudHNcclxuICByZXR1cm4gZ2V0U3RvcmVkU3RpZ1JlcXVpcmVtZW50cyhzdGlnRmFtaWx5SWQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBTVElHIHJlcXVpcmVtZW50cyB0byB0aGUgZm9ybWF0IGV4cGVjdGVkIGJ5IHRoZSB0cmFjZWFiaWxpdHkgbWF0cml4XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFN0aWdSZXF1aXJlbWVudHNUb01hdHJpeChzdGlnRmFtaWx5SWRzOiBzdHJpbmdbXSk6IFN0aWdSZXF1aXJlbWVudFtdIHtcclxuICBjb25zb2xlLmxvZygnQ29udmVydGluZyBTVElHIHJlcXVpcmVtZW50cyBmb3IgZmFtaWxpZXM6Jywgc3RpZ0ZhbWlseUlkcyk7XHJcbiAgXHJcbiAgY29uc3QgYWxsUmVxdWlyZW1lbnRzOiBTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG4gIFxyXG4gIHN0aWdGYW1pbHlJZHMuZm9yRWFjaChmYW1pbHlJZCA9PiB7XHJcbiAgICBjb25zdCBkZXRhaWxlZFJlcXVpcmVtZW50cyA9IGdldFN0b3JlZFN0aWdSZXF1aXJlbWVudHMoZmFtaWx5SWQpO1xyXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7ZGV0YWlsZWRSZXF1aXJlbWVudHMubGVuZ3RofSByZXF1aXJlbWVudHMgZm9yIGZhbWlseTogJHtmYW1pbHlJZH1gKTtcclxuICAgIFxyXG4gICAgZGV0YWlsZWRSZXF1aXJlbWVudHMuZm9yRWFjaCgocmVxLCBpbmRleCkgPT4ge1xyXG4gICAgICBhbGxSZXF1aXJlbWVudHMucHVzaCh7XHJcbiAgICAgICAgaWQ6IGAke2ZhbWlseUlkfS0ke0RhdGUubm93KCl9LSR7aW5kZXh9YCxcclxuICAgICAgICAuLi5yZXEsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKGBUb3RhbCBjb252ZXJ0ZWQgcmVxdWlyZW1lbnRzOiAke2FsbFJlcXVpcmVtZW50cy5sZW5ndGh9YCk7XHJcbiAgcmV0dXJuIGFsbFJlcXVpcmVtZW50cztcclxufVxyXG5cclxuLy8gTmV3OiBGZXRjaCBTVElHIENTViBmcm9tIHN0aWd2aWV3ZXIgYW5kIGNvbnZlcnQgdG8gcmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEFuZENvbnZlcnRTdGlnUmVxdWlyZW1lbnRzKGZhbWlseUlkczogc3RyaW5nW10pOiBQcm9taXNlPERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10+IHtcclxuICBjb25zdCBhbGxSZXF1aXJlbWVudHM6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuICBmb3IgKGNvbnN0IGZhbWlseUlkIG9mIGZhbWlseUlkcykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ29uc3RydWN0IENTViBkb3dubG9hZCBVUkwgKENTViBlbmRwb2ludClcclxuICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vc3RpZ3ZpZXdlci5jb20vc3RpZ3MvZG93bmxvYWQvJHtmYW1pbHlJZH0uY3N2YDtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGZldGNoIFNUSUcgQ1NWIGZvciAke2ZhbWlseUlkfTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY3N2VGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgICAgY29uc3QgZGV0YWlsZWQgPSBwYXJzZVN0aWdDc3YoY3N2VGV4dCwgZmFtaWx5SWQpO1xyXG4gICAgICBhbGxSZXF1aXJlbWVudHMucHVzaCguLi5kZXRhaWxlZCk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgU1RJRyBmb3IgJHtmYW1pbHlJZH06YCwgZXJyKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGFsbFJlcXVpcmVtZW50cztcclxufVxyXG5cclxuLy8gTGVnYWN5IGZ1bmN0aW9uIG5hbWUgc3VwcG9ydFxyXG5leHBvcnQgY29uc3QgY29udmVydFRvU3RpZ1JlcXVpcmVtZW50cyA9IGNvbnZlcnRTdGlnUmVxdWlyZW1lbnRzVG9NYXRyaXg7XHJcblxyXG4vLyBFbXB0eSBkYXRhYmFzZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5leHBvcnQgY29uc3Qgc3RpZ1JlcXVpcmVtZW50c0RhdGFiYXNlOiB7IFtmYW1pbHlJZDogc3RyaW5nXTogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSB9ID0ge307Il0sIm5hbWVzIjpbImNvbnZlcnRDc3ZUb1N0aWdSZXF1aXJlbWVudCIsImNzdlJvdyIsIm5vcm1hbGl6ZVNldmVyaXR5Iiwic2V2ZXJpdHkiLCJzZXYiLCJ0b0xvd2VyQ2FzZSIsImNjaVJlZnMiLCJjY2lzIiwic3BsaXQiLCJmaWx0ZXIiLCJsaW5lIiwiaW5jbHVkZXMiLCJtYXAiLCJtYXRjaCIsImNjaSIsIm5vcm1hbGl6ZVN0YXR1cyIsInN0YXR1cyIsInN0YXQiLCJzdGlnSWQiLCJydWxlSWQiLCJ2dWxuSWQiLCJncm91cElkIiwidW5kZWZpbmVkIiwidGl0bGUiLCJydWxlVGl0bGUiLCJkZXNjcmlwdGlvbiIsImRpc2N1c3Npb24iLCJjaGVja1RleHQiLCJjaGVja0NvbnRlbnQiLCJmaXhUZXh0IiwiYXBwbGljYWJpbGl0eSIsImltcGxlbWVudGF0aW9uU3RhdHVzIiwiY2NpUmVmIiwicGFyc2VTdGlnQ3N2IiwiY3N2Q29udGVudCIsImZhbWlseUlkIiwibGluZXMiLCJsZW5ndGgiLCJoZWFkZXJzIiwiaCIsInJlcGxhY2UiLCJ0cmltIiwicmVxdWlyZW1lbnRzIiwiaSIsInZhbHVlcyIsImN1cnJlbnQiLCJpblF1b3RlcyIsImoiLCJjaGFyIiwicHVzaCIsImZvckVhY2giLCJoZWFkZXIiLCJpbmRleCIsInZhbHVlIiwiYmVuY2htYXJrTmFtZSIsImJlbmNobWFya0lkIiwicmVxdWlyZW1lbnQiLCJmYW1pbHkiLCJ1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHMiLCJzdG9yZVN0aWdSZXF1aXJlbWVudHMiLCJnZXRTdG9yZWRTdGlnUmVxdWlyZW1lbnRzIiwiZ2V0QWxsU3RvcmVkU3RpZ1JlcXVpcmVtZW50cyIsImFsbFJlcXVpcmVtZW50cyIsIk9iamVjdCIsImtleXMiLCJmYW1pbHlSZXF1aXJlbWVudHMiLCJyZXEiLCJpZCIsIkRhdGUiLCJub3ciLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJjbGVhclN0b3JlZFN0aWdSZXF1aXJlbWVudHMiLCJrZXkiLCJnZXREZXRhaWxlZFN0aWdSZXF1aXJlbWVudHMiLCJzdGlnRmFtaWx5SWQiLCJjb252ZXJ0U3RpZ1JlcXVpcmVtZW50c1RvTWF0cml4Iiwic3RpZ0ZhbWlseUlkcyIsImNvbnNvbGUiLCJsb2ciLCJkZXRhaWxlZFJlcXVpcmVtZW50cyIsImZldGNoQW5kQ29udmVydFN0aWdSZXF1aXJlbWVudHMiLCJmYW1pbHlJZHMiLCJ1cmwiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJlcnJvciIsImNzdlRleHQiLCJ0ZXh0IiwiZGV0YWlsZWQiLCJlcnIiLCJjb252ZXJ0VG9TdGlnUmVxdWlyZW1lbnRzIiwic3RpZ1JlcXVpcmVtZW50c0RhdGFiYXNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/detailedStigRequirements.ts\n"));

/***/ })

});