"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/detailedStigRequirements.ts":
/*!*******************************************!*\
  !*** ./utils/detailedStigRequirements.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearStoredStigRequirements: () => (/* binding */ clearStoredStigRequirements),\n/* harmony export */   convertCsvToStigRequirement: () => (/* binding */ convertCsvToStigRequirement),\n/* harmony export */   convertStigRequirementsToMatrix: () => (/* binding */ convertStigRequirementsToMatrix),\n/* harmony export */   convertToStigRequirements: () => (/* binding */ convertToStigRequirements),\n/* harmony export */   fetchAndConvertStigRequirements: () => (/* binding */ fetchAndConvertStigRequirements),\n/* harmony export */   fetchAndConvertStigRequirementsToMatrix: () => (/* binding */ fetchAndConvertStigRequirementsToMatrix),\n/* harmony export */   getAllStoredStigRequirements: () => (/* binding */ getAllStoredStigRequirements),\n/* harmony export */   getDetailedStigRequirements: () => (/* binding */ getDetailedStigRequirements),\n/* harmony export */   getStoredStigRequirements: () => (/* binding */ getStoredStigRequirements),\n/* harmony export */   getUniqueStigRequirementCount: () => (/* binding */ getUniqueStigRequirementCount),\n/* harmony export */   groupStigRequirementsByTitle: () => (/* binding */ groupStigRequirementsByTitle),\n/* harmony export */   parseStigCsv: () => (/* binding */ parseStigCsv),\n/* harmony export */   stigRequirementsDatabase: () => (/* binding */ stigRequirementsDatabase),\n/* harmony export */   storeStigRequirements: () => (/* binding */ storeStigRequirements),\n/* harmony export */   uploadedStigRequirements: () => (/* binding */ uploadedStigRequirements)\n/* harmony export */ });\n/**\r\n * STIG CSV Upload and Management\r\n * Handles parsing and processing of STIG CSV files\r\n */ /**\r\n * Mapping of internal STIG family IDs to stigviewer.com STIG IDs\r\n * Note: stigviewer.com uses different naming conventions\r\n * Format: stigviewer.com/stig/{stigviewerId}/\r\n */ const STIG_ID_MAPPING = {\n    // Application & Web\n    'application-security-dev': 'application_security_and_development',\n    'web-server-srg': 'web_server',\n    'application-server-srg': 'application_server',\n    // Database\n    'postgresql': 'postgresql_9-x',\n    'mysql': 'mysql',\n    'oracle': 'oracle_database_12c',\n    'mssql': 'ms_sql_server_2016',\n    'mongodb': 'mongodb',\n    // Operating Systems\n    'rhel-8': 'red_hat_enterprise_linux_8',\n    'rhel-9': 'red_hat_enterprise_linux_9',\n    'ubuntu': 'canonical_ubuntu_20.04_lts',\n    'windows-server-2019': 'windows_server_2019',\n    'windows-server-2022': 'windows_server_2022',\n    'windows-10': 'windows_10',\n    'windows-11': 'windows_11',\n    // Web Servers\n    'apache-2.4': 'apache_server_2.4_unix',\n    'nginx': 'nginx',\n    'iis-10': 'iis_10.0_server',\n    'iis-8.5': 'iis_8.5_server',\n    // Middleware\n    'docker': 'docker_enterprise',\n    'kubernetes': 'kubernetes',\n    // Network/Infrastructure\n    'firewall-srg': 'firewall',\n    'router-srg': 'router',\n    'switch-srg': 'network_switch',\n    // Cloud\n    'aws': 'amazon_web_services',\n    'azure': 'microsoft_azure',\n    'gcp': 'google_cloud_platform'\n};\n/**\r\n * Convert internal STIG family ID to stigviewer.com STIG ID\r\n */ function mapToStigViewerId(internalId) {\n    return STIG_ID_MAPPING[internalId] || internalId;\n}\n// Function to convert CSV STIG data to our internal format\nfunction convertCsvToStigRequirement(csvRow) {\n    // Normalize severity values\n    const normalizeSeverity = (severity)=>{\n        const sev = severity.toLowerCase();\n        if (sev === 'high' || sev === 'cat i') return 'CAT I';\n        if (sev === 'medium' || sev === 'cat ii') return 'CAT II';\n        if (sev === 'low' || sev === 'cat iii') return 'CAT III';\n        return 'CAT II'; // default\n    };\n    // Extract CCI references\n    const cciRefs = csvRow.ccis ? csvRow.ccis.split('\\n').filter((line)=>line.includes('CCI-')).map((line)=>{\n        const match = line.match(/CCI-\\d+/);\n        return match ? match[0] : '';\n    }).filter((cci)=>cci) : [\n        'CCI-000366'\n    ];\n    // Normalize status values\n    const normalizeStatus = (status)=>{\n        if (!status) return 'Not Started';\n        const stat = status.toLowerCase();\n        if (stat.includes('progress') || stat.includes('ongoing')) return 'In Progress';\n        if (stat.includes('complete') || stat.includes('done')) return 'Completed';\n        if (stat.includes('exception') || stat.includes('waiver')) return 'Exception Requested';\n        return 'Not Started';\n    };\n    return {\n        stigId: csvRow.stigId || csvRow.ruleId || 'UNKNOWN',\n        vulnId: csvRow.groupId || undefined,\n        severity: normalizeSeverity(csvRow.severity),\n        title: csvRow.ruleTitle || 'Untitled Requirement',\n        description: csvRow.discussion || 'No description provided',\n        checkText: csvRow.checkContent || 'No check procedure provided',\n        fixText: csvRow.fixText || 'No fix procedure provided',\n        applicability: 'Applicable',\n        status: normalizeStatus(csvRow.status),\n        implementationStatus: 'Open',\n        cciRef: cciRefs\n    };\n}\n// Parse CSV content and return STIG requirements\nfunction parseStigCsv(csvContent, familyId) {\n    const lines = csvContent.split('\\n');\n    if (lines.length < 2) return [];\n    // Parse header row\n    const headers = lines[0].split(',').map((h)=>h.replace(/\"/g, '').trim().toLowerCase().replace(/\\s+/g, ''));\n    const requirements = [];\n    for(let i = 1; i < lines.length; i++){\n        const line = lines[i].trim();\n        if (!line) continue;\n        // Parse CSV row (handling quoted fields)\n        const values = [];\n        let current = '';\n        let inQuotes = false;\n        for(let j = 0; j < line.length; j++){\n            const char = line[j];\n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                values.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        values.push(current.trim()); // Add the last value\n        // Create CSV STIG object\n        const csvRow = {\n            severity: 'medium',\n            stigId: '',\n            ruleTitle: '',\n            fixText: '',\n            discussion: '',\n            checkContent: ''\n        };\n        // Map values to CSV STIG object based on headers\n        headers.forEach((header, index)=>{\n            if (values[index]) {\n                const value = values[index].replace(/^\"|\"$/g, ''); // Remove surrounding quotes\n                switch(header){\n                    case 'benchmarkname':\n                        csvRow.benchmarkName = value;\n                        break;\n                    case 'benchmarkid':\n                        csvRow.benchmarkId = value;\n                        break;\n                    case 'severity':\n                        csvRow.severity = value;\n                        break;\n                    case 'stigid':\n                        csvRow.stigId = value;\n                        break;\n                    case 'ruletitle':\n                        csvRow.ruleTitle = value;\n                        break;\n                    case 'fixtext':\n                        csvRow.fixText = value;\n                        break;\n                    case 'discussion':\n                        csvRow.discussion = value;\n                        break;\n                    case 'checkcontent':\n                        csvRow.checkContent = value;\n                        break;\n                    case 'ccis':\n                        csvRow.ccis = value;\n                        break;\n                    case 'groupid':\n                        csvRow.groupId = value;\n                        break;\n                    case 'ruleid':\n                        csvRow.ruleId = value;\n                        break;\n                    case 'status':\n                        csvRow.status = value;\n                        break;\n                }\n            }\n        });\n        // Convert to our internal format\n        if (csvRow.stigId && csvRow.ruleTitle) {\n            const requirement = convertCsvToStigRequirement(csvRow);\n            if (familyId) {\n                requirement.family = familyId;\n            }\n            requirements.push(requirement);\n        }\n    }\n    return requirements;\n}\n// Database for managing uploaded STIG requirements\nconst uploadedStigRequirements = {};\n// Function to store uploaded STIG requirements\nfunction storeStigRequirements(familyId, requirements) {\n    uploadedStigRequirements[familyId] = requirements;\n}\n// Function to get stored STIG requirements\nfunction getStoredStigRequirements(familyId) {\n    return uploadedStigRequirements[familyId] || [];\n}\n// Function to get all stored STIG requirements across all families\nfunction getAllStoredStigRequirements() {\n    const allRequirements = [];\n    Object.keys(uploadedStigRequirements).forEach((familyId)=>{\n        const familyRequirements = uploadedStigRequirements[familyId];\n        familyRequirements.forEach((req, index)=>{\n            allRequirements.push({\n                id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n                family: req.family || familyId,\n                ...req,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n        });\n    });\n    return allRequirements;\n}\n// Function to clear stored STIG requirements\nfunction clearStoredStigRequirements(familyId) {\n    if (familyId) {\n        delete uploadedStigRequirements[familyId];\n    } else {\n        // Clear all\n        Object.keys(uploadedStigRequirements).forEach((key)=>{\n            delete uploadedStigRequirements[key];\n        });\n    }\n}\n/**\r\n * Get detailed STIG requirements for a given STIG family ID\r\n * Now supports uploaded CSV data\r\n */ function getDetailedStigRequirements(stigFamilyId) {\n    // Return stored uploaded requirements\n    return getStoredStigRequirements(stigFamilyId);\n}\n/**\r\n * Convert STIG requirements to the format expected by the traceability matrix\r\n */ function convertStigRequirementsToMatrix(stigFamilyIds) {\n    console.log('Converting STIG requirements for families:', stigFamilyIds);\n    const allRequirements = [];\n    stigFamilyIds.forEach((familyId)=>{\n        const detailedRequirements = getStoredStigRequirements(familyId);\n        console.log(\"Found \".concat(detailedRequirements.length, \" requirements for family: \").concat(familyId));\n        detailedRequirements.forEach((req, index)=>{\n            allRequirements.push({\n                id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n                ...req,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            });\n        });\n    });\n    console.log(\"Total converted requirements: \".concat(allRequirements.length));\n    return allRequirements;\n}\n// New: Fetch STIG from stigviewer and convert to requirements\nasync function fetchAndConvertStigRequirements(familyIds) {\n    // Use internal API route to fetch STIG data (avoids CORS/network errors)\n    const allRequirements = [];\n    const failedFetches = [];\n    for (const familyId of familyIds){\n        // Map internal ID to stigviewer.com ID\n        const stigviewerId = mapToStigViewerId(familyId);\n        const apiUrl =  true ? \"\".concat(window.location.origin, \"/api/import-stig?stigId=\").concat(encodeURIComponent(stigviewerId)) : 0;\n        console.log(\"\\uD83D\\uDD0D Fetching STIG: \".concat(familyId, \" → \").concat(stigviewerId));\n        try {\n            const apiRes = await fetch(apiUrl);\n            const result = await apiRes.json();\n            if (!apiRes.ok || !result.success) {\n                // API returned error (503 = stigviewer.com unavailable)\n                console.warn(\"⚠️ Could not fetch \".concat(familyId, \" (\").concat(stigviewerId, \"): \").concat(result.error || result.message));\n                failedFetches.push(\"\".concat(familyId, \" → \").concat(stigviewerId));\n                continue;\n            }\n            if (result.success && result.requirements) {\n                console.log(\"\\uD83D\\uDCCA API returned \".concat(result.requirements.length, \" requirements\"));\n                // Log severity distribution from API\n                const severityCounts = {};\n                result.requirements.forEach((req)=>{\n                    const sev = req.severity || 'unknown';\n                    severityCounts[sev] = (severityCounts[sev] || 0) + 1;\n                });\n                console.log(\"\\uD83D\\uDCCA Severity distribution from API:\", severityCounts);\n                // Convert the API format to DetailedStigRequirement format\n                const converted = result.requirements.map((req)=>{\n                    // Normalize severity - API returns 'high', 'medium', 'low'\n                    let severity = 'CAT II';\n                    const sevText = (req.severity || 'medium').toLowerCase();\n                    if (sevText === 'high' || sevText === 'cat i' || sevText.includes('cat i')) {\n                        severity = 'CAT I';\n                    } else if (sevText === 'low' || sevText === 'cat iii' || sevText.includes('cat iii')) {\n                        severity = 'CAT III';\n                    } else {\n                        severity = 'CAT II';\n                    }\n                    return {\n                        stigId: req.vulnId || req.ruleId || 'UNKNOWN',\n                        vulnId: req.vulnId,\n                        ruleId: req.ruleId,\n                        severity,\n                        title: req.title || 'Untitled Requirement',\n                        description: req.description || 'No description provided',\n                        checkText: req.checkText || 'No check procedure provided',\n                        fixText: req.fixText || 'No fix procedure provided',\n                        applicability: 'Applicable',\n                        status: 'Not Started',\n                        implementationStatus: 'Open',\n                        cciRef: req.cci && req.cci.length > 0 ? req.cci : [\n                            'CCI-000366'\n                        ],\n                        family: familyId\n                    };\n                });\n                // Log severity distribution after conversion\n                const convertedCounts = {};\n                converted.forEach((req)=>{\n                    convertedCounts[req.severity] = (convertedCounts[req.severity] || 0) + 1;\n                });\n                console.log(\"\\uD83D\\uDCCA Severity distribution after conversion:\", convertedCounts);\n                allRequirements.push(...converted);\n                console.log(\"✅ Successfully loaded \".concat(converted.length, \" requirements for \").concat(familyId));\n            }\n        } catch (err) {\n            console.error(\"❌ Error fetching STIG for \".concat(familyId, \":\"), err);\n            failedFetches.push(\"\".concat(familyId, \" → \").concat(stigviewerId));\n        }\n    }\n    // Show user-friendly message if fetches failed\n    if (failedFetches.length > 0 && \"object\" !== 'undefined') {\n        console.warn(\"\\n⚠️ STIG IMPORT ISSUE\\n\" + \"Failed to automatically fetch \".concat(failedFetches.length, \" STIG(s):\\n\") + failedFetches.map((f)=>\"  • \".concat(f)).join('\\n') + '\\n\\n' + \"Possible reasons:\\n\" + \"  • STIG ID mapping may be incorrect for stigviewer.com\\n\" + \"  • STIG may not be available on stigviewer.com\\n\" + \"  • Network connectivity issues\\n\\n\" + \"MANUAL UPLOAD OPTIONS:\\n\" + \"  1. Download STIG XML from DISA: https://public.cyber.mil/stigs/downloads/\\n\" + \"  2. Or browse STIGs: https://stigviewer.com/stigs\\n\" + \"  3. Use the STIG Import component to upload the XCCDF XML file\\n\");\n    }\n    return allRequirements;\n}\n// New: Fetch and convert STIG CSVs directly to the matrix format (StigRequirement[])\nasync function fetchAndConvertStigRequirementsToMatrix(familyIds) {\n    const detailed = await fetchAndConvertStigRequirements(familyIds);\n    const all = [];\n    detailed.forEach((req, index)=>{\n        const familyId = req.family || 'unknown';\n        all.push({\n            id: \"\".concat(familyId, \"-\").concat(Date.now(), \"-\").concat(index),\n            ...req,\n            createdAt: new Date(),\n            updatedAt: new Date()\n        });\n    });\n    return all;\n}\n// Legacy function name support\nconst convertToStigRequirements = convertStigRequirementsToMatrix;\n// Empty database for backward compatibility\nconst stigRequirementsDatabase = {};\n/**\r\n * Group STIG requirements by title to avoid duplicate display\r\n * Requirements with the same title are grouped together with a count\r\n */ function groupStigRequirementsByTitle(requirements) {\n    const groupedMap = new Map();\n    requirements.forEach((req)=>{\n        const key = req.title.trim();\n        if (groupedMap.has(key)) {\n            const existing = groupedMap.get(key);\n            existing.count += 1;\n            existing.stigIds.push(req.stigId);\n            existing.requirements.push(req);\n            // Update status to highest priority status\n            if (req.status === 'Completed' && existing.status !== 'Completed') {\n                existing.status = 'Completed';\n            } else if (req.status === 'In Progress' && existing.status === 'Not Started') {\n                existing.status = 'In Progress';\n            } else if (req.status === 'Exception Requested') {\n                existing.status = 'Exception Requested';\n            }\n            // Update implementation status to most severe\n            if (req.implementationStatus === 'Open' && existing.implementationStatus !== 'Open') {\n                existing.implementationStatus = 'Open';\n            } else if (req.implementationStatus === 'NotAFinding' && existing.implementationStatus === 'Not_Applicable') {\n                existing.implementationStatus = 'NotAFinding';\n            }\n        } else {\n            groupedMap.set(key, {\n                title: req.title,\n                count: 1,\n                family: req.family,\n                severity: req.severity,\n                description: req.description,\n                checkText: req.checkText,\n                fixText: req.fixText,\n                stigIds: [\n                    req.stigId\n                ],\n                requirements: [\n                    req\n                ],\n                status: req.status,\n                implementationStatus: req.implementationStatus\n            });\n        }\n    });\n    return Array.from(groupedMap.values()).sort((a, b)=>{\n        // Sort by severity first (CAT I > CAT II > CAT III), then by title\n        const severityOrder = {\n            'CAT I': 1,\n            'CAT II': 2,\n            'CAT III': 3\n        };\n        const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];\n        if (severityDiff !== 0) return severityDiff;\n        return a.title.localeCompare(b.title);\n    });\n}\n/**\r\n * Get unique count of STIG requirements by title for a family\r\n */ function getUniqueStigRequirementCount(familyId) {\n    const requirements = getStoredStigRequirements(familyId);\n    const titleSet = new Set(requirements.map((req)=>{\n        var _req_title;\n        return (_req_title = req.title) === null || _req_title === void 0 ? void 0 : _req_title.trim();\n    }).filter(Boolean));\n    return titleSet.size;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2RldGFpbGVkU3RpZ1JlcXVpcmVtZW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FTRDs7OztDQUlDLEdBQ0QsTUFBTUEsa0JBQTBDO0lBQzlDLG9CQUFvQjtJQUNwQiw0QkFBNEI7SUFDNUIsa0JBQWtCO0lBQ2xCLDBCQUEwQjtJQUUxQixXQUFXO0lBQ1gsY0FBYztJQUNkLFNBQVM7SUFDVCxVQUFVO0lBQ1YsU0FBUztJQUNULFdBQVc7SUFFWCxvQkFBb0I7SUFDcEIsVUFBVTtJQUNWLFVBQVU7SUFDVixVQUFVO0lBQ1YsdUJBQXVCO0lBQ3ZCLHVCQUF1QjtJQUN2QixjQUFjO0lBQ2QsY0FBYztJQUVkLGNBQWM7SUFDZCxjQUFjO0lBQ2QsU0FBUztJQUNULFVBQVU7SUFDVixXQUFXO0lBRVgsYUFBYTtJQUNiLFVBQVU7SUFDVixjQUFjO0lBRWQseUJBQXlCO0lBQ3pCLGdCQUFnQjtJQUNoQixjQUFjO0lBQ2QsY0FBYztJQUVkLFFBQVE7SUFDUixPQUFPO0lBQ1AsU0FBUztJQUNULE9BQU87QUFDVDtBQUVBOztDQUVDLEdBQ0QsU0FBU0Msa0JBQWtCQyxVQUFrQjtJQUMzQyxPQUFPRixlQUFlLENBQUNFLFdBQVcsSUFBSUE7QUFDeEM7QUE2Q0EsMkRBQTJEO0FBQ3BELFNBQVNDLDRCQUE0QkMsTUFBMEI7SUFDcEUsNEJBQTRCO0lBQzVCLE1BQU1DLG9CQUFvQixDQUFDQztRQUN6QixNQUFNQyxNQUFNRCxTQUFTRSxXQUFXO1FBQ2hDLElBQUlELFFBQVEsVUFBVUEsUUFBUSxTQUFTLE9BQU87UUFDOUMsSUFBSUEsUUFBUSxZQUFZQSxRQUFRLFVBQVUsT0FBTztRQUNqRCxJQUFJQSxRQUFRLFNBQVNBLFFBQVEsV0FBVyxPQUFPO1FBQy9DLE9BQU8sVUFBVSxVQUFVO0lBQzdCO0lBRUEseUJBQXlCO0lBQ3pCLE1BQU1FLFVBQVVMLE9BQU9NLElBQUksR0FDekJOLE9BQU9N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SUFBSSxDQUFDVCxXQUFXcEUsTUFBTSxJQUFJOEUsSUFBSSxDQUFDLENBQUNDLEdBQUdDO1FBQzlDLG1FQUFtRTtRQUNuRSxNQUFNQyxnQkFBZ0I7WUFBRSxTQUFTO1lBQUcsVUFBVTtZQUFHLFdBQVc7UUFBRTtRQUM5RCxNQUFNQyxlQUFlRCxhQUFhLENBQUNGLEVBQUV4SCxRQUFRLENBQUMsR0FBRzBILGFBQWEsQ0FBQ0QsRUFBRXpILFFBQVEsQ0FBQztRQUMxRSxJQUFJMkgsaUJBQWlCLEdBQUcsT0FBT0E7UUFDL0IsT0FBT0gsRUFBRXBHLEtBQUssQ0FBQ3dHLGFBQWEsQ0FBQ0gsRUFBRXJHLEtBQUs7SUFDdEM7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU3lHLDhCQUE4QjdGLFFBQWdCO0lBQzVELE1BQU1PLGVBQWVrQiwwQkFBMEJ6QjtJQUMvQyxNQUFNOEYsV0FBVyxJQUFJQyxJQUFJeEYsYUFBYTlCLEdBQUcsQ0FBQ3NELENBQUFBO1lBQU9BO2dCQUFBQSxhQUFBQSxJQUFJM0MsS0FBSyxjQUFUMkMsaUNBQUFBLFdBQVd6QixJQUFJO09BQUloQyxNQUFNLENBQUMwSDtJQUMzRSxPQUFPRixTQUFTRyxJQUFJO0FBQ3RCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHJvbm5pXFxPbmVEcml2ZVxcRGVza3RvcFxcUHJvamVjdHNcXFNSVE0tdG9vbFxcdXRpbHNcXGRldGFpbGVkU3RpZ1JlcXVpcmVtZW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU1RJRyBDU1YgVXBsb2FkIGFuZCBNYW5hZ2VtZW50XHJcbiAqIEhhbmRsZXMgcGFyc2luZyBhbmQgcHJvY2Vzc2luZyBvZiBTVElHIENTViBmaWxlc1xyXG4gKi9cclxuXHJcbmltcG9ydCB7IFN0aWdSZXF1aXJlbWVudCwgR3JvdXBlZFN0aWdSZXF1aXJlbWVudCB9IGZyb20gJy4uL3R5cGVzL3NydG0nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudCBleHRlbmRzIE9taXQ8U3RpZ1JlcXVpcmVtZW50LCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAndXBkYXRlZEF0Jz4ge1xyXG4gIC8vIEFsbCBvdGhlciBmaWVsZHMgZnJvbSBTdGlnUmVxdWlyZW1lbnQgaW50ZXJmYWNlXHJcbiAgZmFtaWx5Pzogc3RyaW5nOyAvLyBBZGQgZmFtaWx5IHRyYWNraW5nXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXBwaW5nIG9mIGludGVybmFsIFNUSUcgZmFtaWx5IElEcyB0byBzdGlndmlld2VyLmNvbSBTVElHIElEc1xyXG4gKiBOb3RlOiBzdGlndmlld2VyLmNvbSB1c2VzIGRpZmZlcmVudCBuYW1pbmcgY29udmVudGlvbnNcclxuICogRm9ybWF0OiBzdGlndmlld2VyLmNvbS9zdGlnL3tzdGlndmlld2VySWR9L1xyXG4gKi9cclxuY29uc3QgU1RJR19JRF9NQVBQSU5HOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gIC8vIEFwcGxpY2F0aW9uICYgV2ViXHJcbiAgJ2FwcGxpY2F0aW9uLXNlY3VyaXR5LWRldic6ICdhcHBsaWNhdGlvbl9zZWN1cml0eV9hbmRfZGV2ZWxvcG1lbnQnLFxyXG4gICd3ZWItc2VydmVyLXNyZyc6ICd3ZWJfc2VydmVyJyxcclxuICAnYXBwbGljYXRpb24tc2VydmVyLXNyZyc6ICdhcHBsaWNhdGlvbl9zZXJ2ZXInLFxyXG4gIFxyXG4gIC8vIERhdGFiYXNlXHJcbiAgJ3Bvc3RncmVzcWwnOiAncG9zdGdyZXNxbF85LXgnLFxyXG4gICdteXNxbCc6ICdteXNxbCcsXHJcbiAgJ29yYWNsZSc6ICdvcmFjbGVfZGF0YWJhc2VfMTJjJyxcclxuICAnbXNzcWwnOiAnbXNfc3FsX3NlcnZlcl8yMDE2JyxcclxuICAnbW9uZ29kYic6ICdtb25nb2RiJyxcclxuICBcclxuICAvLyBPcGVyYXRpbmcgU3lzdGVtc1xyXG4gICdyaGVsLTgnOiAncmVkX2hhdF9lbnRlcnByaXNlX2xpbnV4XzgnLFxyXG4gICdyaGVsLTknOiAncmVkX2hhdF9lbnRlcnByaXNlX2xpbnV4XzknLCBcclxuICAndWJ1bnR1JzogJ2Nhbm9uaWNhbF91YnVudHVfMjAuMDRfbHRzJyxcclxuICAnd2luZG93cy1zZXJ2ZXItMjAxOSc6ICd3aW5kb3dzX3NlcnZlcl8yMDE5JyxcclxuICAnd2luZG93cy1zZXJ2ZXItMjAyMic6ICd3aW5kb3dzX3NlcnZlcl8yMDIyJyxcclxuICAnd2luZG93cy0xMCc6ICd3aW5kb3dzXzEwJyxcclxuICAnd2luZG93cy0xMSc6ICd3aW5kb3dzXzExJyxcclxuICBcclxuICAvLyBXZWIgU2VydmVyc1xyXG4gICdhcGFjaGUtMi40JzogJ2FwYWNoZV9zZXJ2ZXJfMi40X3VuaXgnLFxyXG4gICduZ2lueCc6ICduZ2lueCcsXHJcbiAgJ2lpcy0xMCc6ICdpaXNfMTAuMF9zZXJ2ZXInLFxyXG4gICdpaXMtOC41JzogJ2lpc184LjVfc2VydmVyJyxcclxuICBcclxuICAvLyBNaWRkbGV3YXJlXHJcbiAgJ2RvY2tlcic6ICdkb2NrZXJfZW50ZXJwcmlzZScsXHJcbiAgJ2t1YmVybmV0ZXMnOiAna3ViZXJuZXRlcycsXHJcbiAgXHJcbiAgLy8gTmV0d29yay9JbmZyYXN0cnVjdHVyZVxyXG4gICdmaXJld2FsbC1zcmcnOiAnZmlyZXdhbGwnLFxyXG4gICdyb3V0ZXItc3JnJzogJ3JvdXRlcicsXHJcbiAgJ3N3aXRjaC1zcmcnOiAnbmV0d29ya19zd2l0Y2gnLFxyXG4gIFxyXG4gIC8vIENsb3VkXHJcbiAgJ2F3cyc6ICdhbWF6b25fd2ViX3NlcnZpY2VzJyxcclxuICAnYXp1cmUnOiAnbWljcm9zb2Z0X2F6dXJlJyxcclxuICAnZ2NwJzogJ2dvb2dsZV9jbG91ZF9wbGF0Zm9ybScsXHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydCBpbnRlcm5hbCBTVElHIGZhbWlseSBJRCB0byBzdGlndmlld2VyLmNvbSBTVElHIElEXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBUb1N0aWdWaWV3ZXJJZChpbnRlcm5hbElkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIHJldHVybiBTVElHX0lEX01BUFBJTkdbaW50ZXJuYWxJZF0gfHwgaW50ZXJuYWxJZDtcclxufVxyXG5cclxuLy8gQ1NWIFVwbG9hZCBTdXBwb3J0IGZvciBTVElHIFJlcXVpcmVtZW50c1xyXG5leHBvcnQgaW50ZXJmYWNlIENzdlN0aWdSZXF1aXJlbWVudCB7XHJcbiAgYmVuY2htYXJrTmFtZT86IHN0cmluZztcclxuICBiZW5jaG1hcmtJZD86IHN0cmluZztcclxuICByZWxlYXNlSW5mbz86IHN0cmluZztcclxuICB2ZXJzaW9uPzogc3RyaW5nO1xyXG4gIGdyb3VwSWQ/OiBzdHJpbmc7XHJcbiAgc2V2ZXJpdHk6ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdycgfCAnQ0FUIEknIHwgJ0NBVCBJSScgfCAnQ0FUIElJSSc7XHJcbiAgcnVsZUlkPzogc3RyaW5nO1xyXG4gIHN0aWdJZDogc3RyaW5nO1xyXG4gIGNsYXNzaWZpY2F0aW9uPzogc3RyaW5nO1xyXG4gIGFzc2V0UG9zdHVyZT86IHN0cmluZztcclxuICBzcmdJZD86IHN0cmluZztcclxuICBydWxlVGl0bGU6IHN0cmluZztcclxuICBmaXhUZXh0OiBzdHJpbmc7XHJcbiAgZGlzY3Vzc2lvbjogc3RyaW5nO1xyXG4gIGNjaXM/OiBzdHJpbmc7XHJcbiAgbGVnYWN5SWRzPzogc3RyaW5nO1xyXG4gIGNoZWNrQ29udGVudDogc3RyaW5nO1xyXG4gIGNoZWNrQ29udGVudFJlZj86IHN0cmluZztcclxuICBpYUNvbnRyb2xzPzogc3RyaW5nO1xyXG4gIHdlaWdodD86IHN0cmluZztcclxuICBmYWxzZVBvc2l0aXZlcz86IHN0cmluZztcclxuICBmYWxzZU5lZ2F0aXZlcz86IHN0cmluZztcclxuICBkb2N1bWVudGFibGU/OiBzdHJpbmc7XHJcbiAgc2VjdXJpdHlPdmVycmlkZUd1aWRhbmNlPzogc3RyaW5nO1xyXG4gIHBvdGVudGlhbEltcGFjdHM/OiBzdHJpbmc7XHJcbiAgdGhpcmRQYXJ0eVRvb2xzPzogc3RyaW5nO1xyXG4gIHJlc3BvbnNpYmlsaXR5Pzogc3RyaW5nO1xyXG4gIG1pdGlnYXRpb25zPzogc3RyaW5nO1xyXG4gIG1pdGlnYXRpb25Db250cm9sPzogc3RyaW5nO1xyXG4gIHN0YXR1cz86IHN0cmluZztcclxuICBjb21tZW50cz86IHN0cmluZztcclxuICBmaW5kaW5nRGV0YWlscz86IHN0cmluZztcclxuICBzZXZlcml0eU92ZXJyaWRlPzogc3RyaW5nO1xyXG4gIHNldmVyaXR5T3ZlcnJpZGVSZWFzb24/OiBzdHJpbmc7XHJcbiAgZnFkbj86IHN0cmluZztcclxuICBpcEFkZHJlc3M/OiBzdHJpbmc7XHJcbiAgbWFjQWRkcmVzcz86IHN0cmluZztcclxuICBuYW1lPzogc3RyaW5nO1xyXG4gIHRlY2hub2xvZ3lBcmVhPzogc3RyaW5nO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBjb252ZXJ0IENTViBTVElHIGRhdGEgdG8gb3VyIGludGVybmFsIGZvcm1hdFxyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydENzdlRvU3RpZ1JlcXVpcmVtZW50KGNzdlJvdzogQ3N2U3RpZ1JlcXVpcmVtZW50KTogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnQge1xyXG4gIC8vIE5vcm1hbGl6ZSBzZXZlcml0eSB2YWx1ZXNcclxuICBjb25zdCBub3JtYWxpemVTZXZlcml0eSA9IChzZXZlcml0eTogc3RyaW5nKTogJ0NBVCBJJyB8ICdDQVQgSUknIHwgJ0NBVCBJSUknID0+IHtcclxuICAgIGNvbnN0IHNldiA9IHNldmVyaXR5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoc2V2ID09PSAnaGlnaCcgfHwgc2V2ID09PSAnY2F0IGknKSByZXR1cm4gJ0NBVCBJJztcclxuICAgIGlmIChzZXYgPT09ICdtZWRpdW0nIHx8IHNldiA9PT0gJ2NhdCBpaScpIHJldHVybiAnQ0FUIElJJztcclxuICAgIGlmIChzZXYgPT09ICdsb3cnIHx8IHNldiA9PT0gJ2NhdCBpaWknKSByZXR1cm4gJ0NBVCBJSUknO1xyXG4gICAgcmV0dXJuICdDQVQgSUknOyAvLyBkZWZhdWx0XHJcbiAgfTtcclxuXHJcbiAgLy8gRXh0cmFjdCBDQ0kgcmVmZXJlbmNlc1xyXG4gIGNvbnN0IGNjaVJlZnMgPSBjc3ZSb3cuY2NpcyA/IFxyXG4gICAgY3N2Um93LmNjaXMuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUuaW5jbHVkZXMoJ0NDSS0nKSkubWFwKGxpbmUgPT4ge1xyXG4gICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2goL0NDSS1cXGQrLyk7XHJcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzBdIDogJyc7XHJcbiAgICB9KS5maWx0ZXIoY2NpID0+IGNjaSkgOiBbJ0NDSS0wMDAzNjYnXTtcclxuXHJcbiAgLy8gTm9ybWFsaXplIHN0YXR1cyB2YWx1ZXNcclxuICBjb25zdCBub3JtYWxpemVTdGF0dXMgPSAoc3RhdHVzPzogc3RyaW5nKTogJ05vdCBTdGFydGVkJyB8ICdJbiBQcm9ncmVzcycgfCAnQ29tcGxldGVkJyB8ICdFeGNlcHRpb24gUmVxdWVzdGVkJyA9PiB7XHJcbiAgICBpZiAoIXN0YXR1cykgcmV0dXJuICdOb3QgU3RhcnRlZCc7XHJcbiAgICBjb25zdCBzdGF0ID0gc3RhdHVzLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoc3RhdC5pbmNsdWRlcygncHJvZ3Jlc3MnKSB8fCBzdGF0LmluY2x1ZGVzKCdvbmdvaW5nJykpIHJldHVybiAnSW4gUHJvZ3Jlc3MnO1xyXG4gICAgaWYgKHN0YXQuaW5jbHVkZXMoJ2NvbXBsZXRlJykgfHwgc3RhdC5pbmNsdWRlcygnZG9uZScpKSByZXR1cm4gJ0NvbXBsZXRlZCc7XHJcbiAgICBpZiAoc3RhdC5pbmNsdWRlcygnZXhjZXB0aW9uJykgfHwgc3RhdC5pbmNsdWRlcygnd2FpdmVyJykpIHJldHVybiAnRXhjZXB0aW9uIFJlcXVlc3RlZCc7XHJcbiAgICByZXR1cm4gJ05vdCBTdGFydGVkJztcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3RpZ0lkOiBjc3ZSb3cuc3RpZ0lkIHx8IGNzdlJvdy5ydWxlSWQgfHwgJ1VOS05PV04nLFxyXG4gICAgdnVsbklkOiBjc3ZSb3cuZ3JvdXBJZCB8fCB1bmRlZmluZWQsXHJcbiAgICBzZXZlcml0eTogbm9ybWFsaXplU2V2ZXJpdHkoY3N2Um93LnNldmVyaXR5KSxcclxuICAgIHRpdGxlOiBjc3ZSb3cucnVsZVRpdGxlIHx8ICdVbnRpdGxlZCBSZXF1aXJlbWVudCcsXHJcbiAgICBkZXNjcmlwdGlvbjogY3N2Um93LmRpc2N1c3Npb24gfHwgJ05vIGRlc2NyaXB0aW9uIHByb3ZpZGVkJyxcclxuICAgIGNoZWNrVGV4dDogY3N2Um93LmNoZWNrQ29udGVudCB8fCAnTm8gY2hlY2sgcHJvY2VkdXJlIHByb3ZpZGVkJyxcclxuICAgIGZpeFRleHQ6IGNzdlJvdy5maXhUZXh0IHx8ICdObyBmaXggcHJvY2VkdXJlIHByb3ZpZGVkJyxcclxuICAgIGFwcGxpY2FiaWxpdHk6ICdBcHBsaWNhYmxlJyxcclxuICAgIHN0YXR1czogbm9ybWFsaXplU3RhdHVzKGNzdlJvdy5zdGF0dXMpLFxyXG4gICAgaW1wbGVtZW50YXRpb25TdGF0dXM6ICdPcGVuJyxcclxuICAgIGNjaVJlZjogY2NpUmVmc1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIFBhcnNlIENTViBjb250ZW50IGFuZCByZXR1cm4gU1RJRyByZXF1aXJlbWVudHNcclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3RpZ0Nzdihjc3ZDb250ZW50OiBzdHJpbmcsIGZhbWlseUlkPzogc3RyaW5nKTogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSB7XHJcbiAgY29uc3QgbGluZXMgPSBjc3ZDb250ZW50LnNwbGl0KCdcXG4nKTtcclxuICBpZiAobGluZXMubGVuZ3RoIDwgMikgcmV0dXJuIFtdO1xyXG5cclxuICAvLyBQYXJzZSBoZWFkZXIgcm93XHJcbiAgY29uc3QgaGVhZGVycyA9IGxpbmVzWzBdLnNwbGl0KCcsJykubWFwKGggPT4gaC5yZXBsYWNlKC9cIi9nLCAnJykudHJpbSgpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnJykpO1xyXG4gIFxyXG4gIGNvbnN0IHJlcXVpcmVtZW50czogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG5cclxuICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xyXG4gICAgaWYgKCFsaW5lKSBjb250aW51ZTtcclxuXHJcbiAgICAvLyBQYXJzZSBDU1Ygcm93IChoYW5kbGluZyBxdW90ZWQgZmllbGRzKVxyXG4gICAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnQgPSAnJztcclxuICAgIGxldCBpblF1b3RlcyA9IGZhbHNlO1xyXG5cclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xyXG4gICAgICBjb25zdCBjaGFyID0gbGluZVtqXTtcclxuICAgICAgXHJcbiAgICAgIGlmIChjaGFyID09PSAnXCInKSB7XHJcbiAgICAgICAgaW5RdW90ZXMgPSAhaW5RdW90ZXM7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJywnICYmICFpblF1b3Rlcykge1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKGN1cnJlbnQudHJpbSgpKTtcclxuICAgICAgICBjdXJyZW50ID0gJyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3VycmVudCArPSBjaGFyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB2YWx1ZXMucHVzaChjdXJyZW50LnRyaW0oKSk7IC8vIEFkZCB0aGUgbGFzdCB2YWx1ZVxyXG5cclxuICAgIC8vIENyZWF0ZSBDU1YgU1RJRyBvYmplY3RcclxuICAgIGNvbnN0IGNzdlJvdzogQ3N2U3RpZ1JlcXVpcmVtZW50ID0ge1xyXG4gICAgICBzZXZlcml0eTogJ21lZGl1bScgYXMgY29uc3QsXHJcbiAgICAgIHN0aWdJZDogJycsXHJcbiAgICAgIHJ1bGVUaXRsZTogJycsXHJcbiAgICAgIGZpeFRleHQ6ICcnLFxyXG4gICAgICBkaXNjdXNzaW9uOiAnJyxcclxuICAgICAgY2hlY2tDb250ZW50OiAnJ1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBNYXAgdmFsdWVzIHRvIENTViBTVElHIG9iamVjdCBiYXNlZCBvbiBoZWFkZXJzXHJcbiAgICBoZWFkZXJzLmZvckVhY2goKGhlYWRlciwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKHZhbHVlc1tpbmRleF0pIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF0ucmVwbGFjZSgvXlwifFwiJC9nLCAnJyk7IC8vIFJlbW92ZSBzdXJyb3VuZGluZyBxdW90ZXNcclxuICAgICAgICBcclxuICAgICAgICBzd2l0Y2ggKGhlYWRlcikge1xyXG4gICAgICAgICAgY2FzZSAnYmVuY2htYXJrbmFtZSc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5iZW5jaG1hcmtOYW1lID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnYmVuY2htYXJraWQnOlxyXG4gICAgICAgICAgICBjc3ZSb3cuYmVuY2htYXJrSWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdzZXZlcml0eSc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5zZXZlcml0eSA9IHZhbHVlIGFzIGFueTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdzdGlnaWQnOlxyXG4gICAgICAgICAgICBjc3ZSb3cuc3RpZ0lkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAncnVsZXRpdGxlJzpcclxuICAgICAgICAgICAgY3N2Um93LnJ1bGVUaXRsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2ZpeHRleHQnOlxyXG4gICAgICAgICAgICBjc3ZSb3cuZml4VGV4dCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2Rpc2N1c3Npb24nOlxyXG4gICAgICAgICAgICBjc3ZSb3cuZGlzY3Vzc2lvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2NoZWNrY29udGVudCc6XHJcbiAgICAgICAgICAgIGNzdlJvdy5jaGVja0NvbnRlbnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdjY2lzJzpcclxuICAgICAgICAgICAgY3N2Um93LmNjaXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdncm91cGlkJzpcclxuICAgICAgICAgICAgY3N2Um93Lmdyb3VwSWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdydWxlaWQnOlxyXG4gICAgICAgICAgICBjc3ZSb3cucnVsZUlkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnc3RhdHVzJzpcclxuICAgICAgICAgICAgY3N2Um93LnN0YXR1cyA9IHZhbHVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENvbnZlcnQgdG8gb3VyIGludGVybmFsIGZvcm1hdFxyXG4gICAgaWYgKGNzdlJvdy5zdGlnSWQgJiYgY3N2Um93LnJ1bGVUaXRsZSkge1xyXG4gICAgICBjb25zdCByZXF1aXJlbWVudCA9IGNvbnZlcnRDc3ZUb1N0aWdSZXF1aXJlbWVudChjc3ZSb3cpO1xyXG4gICAgICBpZiAoZmFtaWx5SWQpIHtcclxuICAgICAgICByZXF1aXJlbWVudC5mYW1pbHkgPSBmYW1pbHlJZDtcclxuICAgICAgfVxyXG4gICAgICByZXF1aXJlbWVudHMucHVzaChyZXF1aXJlbWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVxdWlyZW1lbnRzO1xyXG59XHJcblxyXG4vLyBEYXRhYmFzZSBmb3IgbWFuYWdpbmcgdXBsb2FkZWQgU1RJRyByZXF1aXJlbWVudHNcclxuZXhwb3J0IGNvbnN0IHVwbG9hZGVkU3RpZ1JlcXVpcmVtZW50czogeyBbZmFtaWx5SWQ6IHN0cmluZ106IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10gfSA9IHt9O1xyXG5cclxuLy8gRnVuY3Rpb24gdG8gc3RvcmUgdXBsb2FkZWQgU1RJRyByZXF1aXJlbWVudHNcclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlU3RpZ1JlcXVpcmVtZW50cyhmYW1pbHlJZDogc3RyaW5nLCByZXF1aXJlbWVudHM6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50W10pIHtcclxuICB1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHNbZmFtaWx5SWRdID0gcmVxdWlyZW1lbnRzO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBnZXQgc3RvcmVkIFNUSUcgcmVxdWlyZW1lbnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9yZWRTdGlnUmVxdWlyZW1lbnRzKGZhbWlseUlkOiBzdHJpbmcpOiBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudFtdIHtcclxuICByZXR1cm4gdXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzW2ZhbWlseUlkXSB8fCBbXTtcclxufVxyXG5cclxuLy8gRnVuY3Rpb24gdG8gZ2V0IGFsbCBzdG9yZWQgU1RJRyByZXF1aXJlbWVudHMgYWNyb3NzIGFsbCBmYW1pbGllc1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsU3RvcmVkU3RpZ1JlcXVpcmVtZW50cygpOiBTdGlnUmVxdWlyZW1lbnRbXSB7XHJcbiAgY29uc3QgYWxsUmVxdWlyZW1lbnRzOiBTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG4gIFxyXG4gIE9iamVjdC5rZXlzKHVwbG9hZGVkU3RpZ1JlcXVpcmVtZW50cykuZm9yRWFjaChmYW1pbHlJZCA9PiB7XHJcbiAgICBjb25zdCBmYW1pbHlSZXF1aXJlbWVudHMgPSB1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHNbZmFtaWx5SWRdO1xyXG4gICAgZmFtaWx5UmVxdWlyZW1lbnRzLmZvckVhY2goKHJlcSwgaW5kZXgpID0+IHtcclxuICAgICAgYWxsUmVxdWlyZW1lbnRzLnB1c2goe1xyXG4gICAgICAgIGlkOiBgJHtmYW1pbHlJZH0tJHtEYXRlLm5vdygpfS0ke2luZGV4fWAsXHJcbiAgICAgICAgZmFtaWx5OiByZXEuZmFtaWx5IHx8IGZhbWlseUlkLCAvLyBVc2UgdGhlIGZhbWlseSBmcm9tIHJlcXVpcmVtZW50IG9yIGZhbGxiYWNrIHRvIGZhbWlseUlkXHJcbiAgICAgICAgLi4ucmVxLFxyXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcclxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICBcclxuICByZXR1cm4gYWxsUmVxdWlyZW1lbnRzO1xyXG59XHJcblxyXG4vLyBGdW5jdGlvbiB0byBjbGVhciBzdG9yZWQgU1RJRyByZXF1aXJlbWVudHNcclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyU3RvcmVkU3RpZ1JlcXVpcmVtZW50cyhmYW1pbHlJZD86IHN0cmluZykge1xyXG4gIGlmIChmYW1pbHlJZCkge1xyXG4gICAgZGVsZXRlIHVwbG9hZGVkU3RpZ1JlcXVpcmVtZW50c1tmYW1pbHlJZF07XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIENsZWFyIGFsbFxyXG4gICAgT2JqZWN0LmtleXModXBsb2FkZWRTdGlnUmVxdWlyZW1lbnRzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGRlbGV0ZSB1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHNba2V5XTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBkZXRhaWxlZCBTVElHIHJlcXVpcmVtZW50cyBmb3IgYSBnaXZlbiBTVElHIGZhbWlseSBJRFxyXG4gKiBOb3cgc3VwcG9ydHMgdXBsb2FkZWQgQ1NWIGRhdGFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZXRhaWxlZFN0aWdSZXF1aXJlbWVudHMoc3RpZ0ZhbWlseUlkOiBzdHJpbmcpOiBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudFtdIHtcclxuICAvLyBSZXR1cm4gc3RvcmVkIHVwbG9hZGVkIHJlcXVpcmVtZW50c1xyXG4gIHJldHVybiBnZXRTdG9yZWRTdGlnUmVxdWlyZW1lbnRzKHN0aWdGYW1pbHlJZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IFNUSUcgcmVxdWlyZW1lbnRzIHRvIHRoZSBmb3JtYXQgZXhwZWN0ZWQgYnkgdGhlIHRyYWNlYWJpbGl0eSBtYXRyaXhcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0U3RpZ1JlcXVpcmVtZW50c1RvTWF0cml4KHN0aWdGYW1pbHlJZHM6IHN0cmluZ1tdKTogU3RpZ1JlcXVpcmVtZW50W10ge1xyXG4gIGNvbnNvbGUubG9nKCdDb252ZXJ0aW5nIFNUSUcgcmVxdWlyZW1lbnRzIGZvciBmYW1pbGllczonLCBzdGlnRmFtaWx5SWRzKTtcclxuICBcclxuICBjb25zdCBhbGxSZXF1aXJlbWVudHM6IFN0aWdSZXF1aXJlbWVudFtdID0gW107XHJcbiAgXHJcbiAgc3RpZ0ZhbWlseUlkcy5mb3JFYWNoKGZhbWlseUlkID0+IHtcclxuICAgIGNvbnN0IGRldGFpbGVkUmVxdWlyZW1lbnRzID0gZ2V0U3RvcmVkU3RpZ1JlcXVpcmVtZW50cyhmYW1pbHlJZCk7XHJcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtkZXRhaWxlZFJlcXVpcmVtZW50cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmb3IgZmFtaWx5OiAke2ZhbWlseUlkfWApO1xyXG4gICAgXHJcbiAgICBkZXRhaWxlZFJlcXVpcmVtZW50cy5mb3JFYWNoKChyZXEsIGluZGV4KSA9PiB7XHJcbiAgICAgIGFsbFJlcXVpcmVtZW50cy5wdXNoKHtcclxuICAgICAgICBpZDogYCR7ZmFtaWx5SWR9LSR7RGF0ZS5ub3coKX0tJHtpbmRleH1gLFxyXG4gICAgICAgIC4uLnJlcSxcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgY29uc29sZS5sb2coYFRvdGFsIGNvbnZlcnRlZCByZXF1aXJlbWVudHM6ICR7YWxsUmVxdWlyZW1lbnRzLmxlbmd0aH1gKTtcclxuICByZXR1cm4gYWxsUmVxdWlyZW1lbnRzO1xyXG59XHJcblxyXG4vLyBOZXc6IEZldGNoIFNUSUcgZnJvbSBzdGlndmlld2VyIGFuZCBjb252ZXJ0IHRvIHJlcXVpcmVtZW50c1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hBbmRDb252ZXJ0U3RpZ1JlcXVpcmVtZW50cyhmYW1pbHlJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxEZXRhaWxlZFN0aWdSZXF1aXJlbWVudFtdPiB7XHJcbiAgLy8gVXNlIGludGVybmFsIEFQSSByb3V0ZSB0byBmZXRjaCBTVElHIGRhdGEgKGF2b2lkcyBDT1JTL25ldHdvcmsgZXJyb3JzKVxyXG4gIGNvbnN0IGFsbFJlcXVpcmVtZW50czogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG4gIGNvbnN0IGZhaWxlZEZldGNoZXM6IHN0cmluZ1tdID0gW107XHJcbiAgXHJcbiAgZm9yIChjb25zdCBmYW1pbHlJZCBvZiBmYW1pbHlJZHMpIHtcclxuICAgIC8vIE1hcCBpbnRlcm5hbCBJRCB0byBzdGlndmlld2VyLmNvbSBJRFxyXG4gICAgY29uc3Qgc3RpZ3ZpZXdlcklkID0gbWFwVG9TdGlnVmlld2VySWQoZmFtaWx5SWQpO1xyXG4gICAgXHJcbiAgICBjb25zdCBhcGlVcmwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgPyBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9hcGkvaW1wb3J0LXN0aWc/c3RpZ0lkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHN0aWd2aWV3ZXJJZCl9YFxyXG4gICAgICA6IGAvYXBpL2ltcG9ydC1zdGlnP3N0aWdJZD0ke2VuY29kZVVSSUNvbXBvbmVudChzdGlndmlld2VySWQpfWApO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBGZXRjaGluZyBTVElHOiAke2ZhbWlseUlkfSDihpIgJHtzdGlndmlld2VySWR9YCk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGFwaVJlcyA9IGF3YWl0IGZldGNoKGFwaVVybCk7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwaVJlcy5qc29uKCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWFwaVJlcy5vayB8fCAhcmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgICAvLyBBUEkgcmV0dXJuZWQgZXJyb3IgKDUwMyA9IHN0aWd2aWV3ZXIuY29tIHVuYXZhaWxhYmxlKVxyXG4gICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIENvdWxkIG5vdCBmZXRjaCAke2ZhbWlseUlkfSAoJHtzdGlndmlld2VySWR9KTogJHtyZXN1bHQuZXJyb3IgfHwgcmVzdWx0Lm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgZmFpbGVkRmV0Y2hlcy5wdXNoKGAke2ZhbWlseUlkfSDihpIgJHtzdGlndmlld2VySWR9YCk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQucmVxdWlyZW1lbnRzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfk4ogQVBJIHJldHVybmVkICR7cmVzdWx0LnJlcXVpcmVtZW50cy5sZW5ndGh9IHJlcXVpcmVtZW50c2ApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIExvZyBzZXZlcml0eSBkaXN0cmlidXRpb24gZnJvbSBBUElcclxuICAgICAgICBjb25zdCBzZXZlcml0eUNvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gICAgICAgIHJlc3VsdC5yZXF1aXJlbWVudHMuZm9yRWFjaCgocmVxOiBhbnkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHNldiA9IHJlcS5zZXZlcml0eSB8fCAndW5rbm93bic7XHJcbiAgICAgICAgICBzZXZlcml0eUNvdW50c1tzZXZdID0gKHNldmVyaXR5Q291bnRzW3Nldl0gfHwgMCkgKyAxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFNldmVyaXR5IGRpc3RyaWJ1dGlvbiBmcm9tIEFQSTpgLCBzZXZlcml0eUNvdW50cyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgQVBJIGZvcm1hdCB0byBEZXRhaWxlZFN0aWdSZXF1aXJlbWVudCBmb3JtYXRcclxuICAgICAgICBjb25zdCBjb252ZXJ0ZWQgPSByZXN1bHQucmVxdWlyZW1lbnRzLm1hcCgocmVxOiBhbnkpID0+IHtcclxuICAgICAgICAgIC8vIE5vcm1hbGl6ZSBzZXZlcml0eSAtIEFQSSByZXR1cm5zICdoaWdoJywgJ21lZGl1bScsICdsb3cnXHJcbiAgICAgICAgICBsZXQgc2V2ZXJpdHk6ICdDQVQgSScgfCAnQ0FUIElJJyB8ICdDQVQgSUlJJyA9ICdDQVQgSUknO1xyXG4gICAgICAgICAgY29uc3Qgc2V2VGV4dCA9IChyZXEuc2V2ZXJpdHkgfHwgJ21lZGl1bScpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChzZXZUZXh0ID09PSAnaGlnaCcgfHwgc2V2VGV4dCA9PT0gJ2NhdCBpJyB8fCBzZXZUZXh0LmluY2x1ZGVzKCdjYXQgaScpKSB7XHJcbiAgICAgICAgICAgIHNldmVyaXR5ID0gJ0NBVCBJJztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc2V2VGV4dCA9PT0gJ2xvdycgfHwgc2V2VGV4dCA9PT0gJ2NhdCBpaWknIHx8IHNldlRleHQuaW5jbHVkZXMoJ2NhdCBpaWknKSkge1xyXG4gICAgICAgICAgICBzZXZlcml0eSA9ICdDQVQgSUlJJztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNldmVyaXR5ID0gJ0NBVCBJSSc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0aWdJZDogcmVxLnZ1bG5JZCB8fCByZXEucnVsZUlkIHx8ICdVTktOT1dOJyxcclxuICAgICAgICAgICAgdnVsbklkOiByZXEudnVsbklkLFxyXG4gICAgICAgICAgICBydWxlSWQ6IHJlcS5ydWxlSWQsXHJcbiAgICAgICAgICAgIHNldmVyaXR5LFxyXG4gICAgICAgICAgICB0aXRsZTogcmVxLnRpdGxlIHx8ICdVbnRpdGxlZCBSZXF1aXJlbWVudCcsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiByZXEuZGVzY3JpcHRpb24gfHwgJ05vIGRlc2NyaXB0aW9uIHByb3ZpZGVkJyxcclxuICAgICAgICAgICAgY2hlY2tUZXh0OiByZXEuY2hlY2tUZXh0IHx8ICdObyBjaGVjayBwcm9jZWR1cmUgcHJvdmlkZWQnLFxyXG4gICAgICAgICAgICBmaXhUZXh0OiByZXEuZml4VGV4dCB8fCAnTm8gZml4IHByb2NlZHVyZSBwcm92aWRlZCcsXHJcbiAgICAgICAgICAgIGFwcGxpY2FiaWxpdHk6ICdBcHBsaWNhYmxlJyBhcyBjb25zdCxcclxuICAgICAgICAgICAgc3RhdHVzOiAnTm90IFN0YXJ0ZWQnIGFzIGNvbnN0LFxyXG4gICAgICAgICAgICBpbXBsZW1lbnRhdGlvblN0YXR1czogJ09wZW4nIGFzIGNvbnN0LFxyXG4gICAgICAgICAgICBjY2lSZWY6IHJlcS5jY2kgJiYgcmVxLmNjaS5sZW5ndGggPiAwID8gcmVxLmNjaSA6IFsnQ0NJLTAwMDM2NiddLFxyXG4gICAgICAgICAgICBmYW1pbHk6IGZhbWlseUlkXHJcbiAgICAgICAgICB9IGFzIERldGFpbGVkU3RpZ1JlcXVpcmVtZW50O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIExvZyBzZXZlcml0eSBkaXN0cmlidXRpb24gYWZ0ZXIgY29udmVyc2lvblxyXG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZENvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gICAgICAgIGNvbnZlcnRlZC5mb3JFYWNoKChyZXE6IERldGFpbGVkU3RpZ1JlcXVpcmVtZW50KSA9PiB7XHJcbiAgICAgICAgICBjb252ZXJ0ZWRDb3VudHNbcmVxLnNldmVyaXR5XSA9IChjb252ZXJ0ZWRDb3VudHNbcmVxLnNldmVyaXR5XSB8fCAwKSArIDE7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfk4ogU2V2ZXJpdHkgZGlzdHJpYnV0aW9uIGFmdGVyIGNvbnZlcnNpb246YCwgY29udmVydGVkQ291bnRzKTtcclxuICAgICAgICBcclxuICAgICAgICBhbGxSZXF1aXJlbWVudHMucHVzaCguLi5jb252ZXJ0ZWQpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IGxvYWRlZCAke2NvbnZlcnRlZC5sZW5ndGh9IHJlcXVpcmVtZW50cyBmb3IgJHtmYW1pbHlJZH1gKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBmZXRjaGluZyBTVElHIGZvciAke2ZhbWlseUlkfTpgLCBlcnIpO1xyXG4gICAgICBmYWlsZWRGZXRjaGVzLnB1c2goYCR7ZmFtaWx5SWR9IOKGkiAke3N0aWd2aWV3ZXJJZH1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gU2hvdyB1c2VyLWZyaWVuZGx5IG1lc3NhZ2UgaWYgZmV0Y2hlcyBmYWlsZWRcclxuICBpZiAoZmFpbGVkRmV0Y2hlcy5sZW5ndGggPiAwICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYFxcbuKaoO+4jyBTVElHIElNUE9SVCBJU1NVRVxcbmAgK1xyXG4gICAgICBgRmFpbGVkIHRvIGF1dG9tYXRpY2FsbHkgZmV0Y2ggJHtmYWlsZWRGZXRjaGVzLmxlbmd0aH0gU1RJRyhzKTpcXG5gICtcclxuICAgICAgZmFpbGVkRmV0Y2hlcy5tYXAoZiA9PiBgICDigKIgJHtmfWApLmpvaW4oJ1xcbicpICsgJ1xcblxcbicgK1xyXG4gICAgICBgUG9zc2libGUgcmVhc29uczpcXG5gICtcclxuICAgICAgYCAg4oCiIFNUSUcgSUQgbWFwcGluZyBtYXkgYmUgaW5jb3JyZWN0IGZvciBzdGlndmlld2VyLmNvbVxcbmAgK1xyXG4gICAgICBgICDigKIgU1RJRyBtYXkgbm90IGJlIGF2YWlsYWJsZSBvbiBzdGlndmlld2VyLmNvbVxcbmAgK1xyXG4gICAgICBgICDigKIgTmV0d29yayBjb25uZWN0aXZpdHkgaXNzdWVzXFxuXFxuYCArXHJcbiAgICAgIGBNQU5VQUwgVVBMT0FEIE9QVElPTlM6XFxuYCArXHJcbiAgICAgIGAgIDEuIERvd25sb2FkIFNUSUcgWE1MIGZyb20gRElTQTogaHR0cHM6Ly9wdWJsaWMuY3liZXIubWlsL3N0aWdzL2Rvd25sb2Fkcy9cXG5gICtcclxuICAgICAgYCAgMi4gT3IgYnJvd3NlIFNUSUdzOiBodHRwczovL3N0aWd2aWV3ZXIuY29tL3N0aWdzXFxuYCArXHJcbiAgICAgIGAgIDMuIFVzZSB0aGUgU1RJRyBJbXBvcnQgY29tcG9uZW50IHRvIHVwbG9hZCB0aGUgWENDREYgWE1MIGZpbGVcXG5gKTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGFsbFJlcXVpcmVtZW50cztcclxufVxyXG4vLyBOZXc6IEZldGNoIGFuZCBjb252ZXJ0IFNUSUcgQ1NWcyBkaXJlY3RseSB0byB0aGUgbWF0cml4IGZvcm1hdCAoU3RpZ1JlcXVpcmVtZW50W10pXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEFuZENvbnZlcnRTdGlnUmVxdWlyZW1lbnRzVG9NYXRyaXgoZmFtaWx5SWRzOiBzdHJpbmdbXSk6IFByb21pc2U8U3RpZ1JlcXVpcmVtZW50W10+IHtcclxuICBjb25zdCBkZXRhaWxlZCA9IGF3YWl0IGZldGNoQW5kQ29udmVydFN0aWdSZXF1aXJlbWVudHMoZmFtaWx5SWRzKTtcclxuICBjb25zdCBhbGw6IFN0aWdSZXF1aXJlbWVudFtdID0gW107XHJcbiAgZGV0YWlsZWQuZm9yRWFjaCgocmVxLCBpbmRleCkgPT4ge1xyXG4gICAgY29uc3QgZmFtaWx5SWQgPSByZXEuZmFtaWx5IHx8ICd1bmtub3duJztcclxuICAgIGFsbC5wdXNoKHtcclxuICAgICAgaWQ6IGAke2ZhbWlseUlkfS0ke0RhdGUubm93KCl9LSR7aW5kZXh9YCxcclxuICAgICAgLi4ucmVxLFxyXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGFsbDtcclxufVxyXG5cclxuLy8gTGVnYWN5IGZ1bmN0aW9uIG5hbWUgc3VwcG9ydFxyXG5leHBvcnQgY29uc3QgY29udmVydFRvU3RpZ1JlcXVpcmVtZW50cyA9IGNvbnZlcnRTdGlnUmVxdWlyZW1lbnRzVG9NYXRyaXg7XHJcblxyXG4vLyBFbXB0eSBkYXRhYmFzZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5leHBvcnQgY29uc3Qgc3RpZ1JlcXVpcmVtZW50c0RhdGFiYXNlOiB7IFtmYW1pbHlJZDogc3RyaW5nXTogRGV0YWlsZWRTdGlnUmVxdWlyZW1lbnRbXSB9ID0ge307XHJcblxyXG4vKipcclxuICogR3JvdXAgU1RJRyByZXF1aXJlbWVudHMgYnkgdGl0bGUgdG8gYXZvaWQgZHVwbGljYXRlIGRpc3BsYXlcclxuICogUmVxdWlyZW1lbnRzIHdpdGggdGhlIHNhbWUgdGl0bGUgYXJlIGdyb3VwZWQgdG9nZXRoZXIgd2l0aCBhIGNvdW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBTdGlnUmVxdWlyZW1lbnRzQnlUaXRsZShyZXF1aXJlbWVudHM6IFN0aWdSZXF1aXJlbWVudFtdKTogR3JvdXBlZFN0aWdSZXF1aXJlbWVudFtdIHtcclxuICBjb25zdCBncm91cGVkTWFwID0gbmV3IE1hcDxzdHJpbmcsIEdyb3VwZWRTdGlnUmVxdWlyZW1lbnQ+KCk7XHJcblxyXG4gIHJlcXVpcmVtZW50cy5mb3JFYWNoKHJlcSA9PiB7XHJcbiAgICBjb25zdCBrZXkgPSByZXEudGl0bGUudHJpbSgpO1xyXG4gICAgXHJcbiAgICBpZiAoZ3JvdXBlZE1hcC5oYXMoa2V5KSkge1xyXG4gICAgICBjb25zdCBleGlzdGluZyA9IGdyb3VwZWRNYXAuZ2V0KGtleSkhO1xyXG4gICAgICBleGlzdGluZy5jb3VudCArPSAxO1xyXG4gICAgICBleGlzdGluZy5zdGlnSWRzLnB1c2gocmVxLnN0aWdJZCk7XHJcbiAgICAgIGV4aXN0aW5nLnJlcXVpcmVtZW50cy5wdXNoKHJlcSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgc3RhdHVzIHRvIGhpZ2hlc3QgcHJpb3JpdHkgc3RhdHVzXHJcbiAgICAgIGlmIChyZXEuc3RhdHVzID09PSAnQ29tcGxldGVkJyAmJiBleGlzdGluZy5zdGF0dXMgIT09ICdDb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgZXhpc3Rpbmcuc3RhdHVzID0gJ0NvbXBsZXRlZCc7XHJcbiAgICAgIH0gZWxzZSBpZiAocmVxLnN0YXR1cyA9PT0gJ0luIFByb2dyZXNzJyAmJiBleGlzdGluZy5zdGF0dXMgPT09ICdOb3QgU3RhcnRlZCcpIHtcclxuICAgICAgICBleGlzdGluZy5zdGF0dXMgPSAnSW4gUHJvZ3Jlc3MnO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlcS5zdGF0dXMgPT09ICdFeGNlcHRpb24gUmVxdWVzdGVkJykge1xyXG4gICAgICAgIGV4aXN0aW5nLnN0YXR1cyA9ICdFeGNlcHRpb24gUmVxdWVzdGVkJztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGltcGxlbWVudGF0aW9uIHN0YXR1cyB0byBtb3N0IHNldmVyZVxyXG4gICAgICBpZiAocmVxLmltcGxlbWVudGF0aW9uU3RhdHVzID09PSAnT3BlbicgJiYgZXhpc3RpbmcuaW1wbGVtZW50YXRpb25TdGF0dXMgIT09ICdPcGVuJykge1xyXG4gICAgICAgIGV4aXN0aW5nLmltcGxlbWVudGF0aW9uU3RhdHVzID0gJ09wZW4nO1xyXG4gICAgICB9IGVsc2UgaWYgKHJlcS5pbXBsZW1lbnRhdGlvblN0YXR1cyA9PT0gJ05vdEFGaW5kaW5nJyAmJiBleGlzdGluZy5pbXBsZW1lbnRhdGlvblN0YXR1cyA9PT0gJ05vdF9BcHBsaWNhYmxlJykge1xyXG4gICAgICAgIGV4aXN0aW5nLmltcGxlbWVudGF0aW9uU3RhdHVzID0gJ05vdEFGaW5kaW5nJztcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZ3JvdXBlZE1hcC5zZXQoa2V5LCB7XHJcbiAgICAgICAgdGl0bGU6IHJlcS50aXRsZSxcclxuICAgICAgICBjb3VudDogMSxcclxuICAgICAgICBmYW1pbHk6IHJlcS5mYW1pbHksXHJcbiAgICAgICAgc2V2ZXJpdHk6IHJlcS5zZXZlcml0eSxcclxuICAgICAgICBkZXNjcmlwdGlvbjogcmVxLmRlc2NyaXB0aW9uLFxyXG4gICAgICAgIGNoZWNrVGV4dDogcmVxLmNoZWNrVGV4dCxcclxuICAgICAgICBmaXhUZXh0OiByZXEuZml4VGV4dCxcclxuICAgICAgICBzdGlnSWRzOiBbcmVxLnN0aWdJZF0sXHJcbiAgICAgICAgcmVxdWlyZW1lbnRzOiBbcmVxXSxcclxuICAgICAgICBzdGF0dXM6IHJlcS5zdGF0dXMsXHJcbiAgICAgICAgaW1wbGVtZW50YXRpb25TdGF0dXM6IHJlcS5pbXBsZW1lbnRhdGlvblN0YXR1c1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIEFycmF5LmZyb20oZ3JvdXBlZE1hcC52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgLy8gU29ydCBieSBzZXZlcml0eSBmaXJzdCAoQ0FUIEkgPiBDQVQgSUkgPiBDQVQgSUlJKSwgdGhlbiBieSB0aXRsZVxyXG4gICAgY29uc3Qgc2V2ZXJpdHlPcmRlciA9IHsgJ0NBVCBJJzogMSwgJ0NBVCBJSSc6IDIsICdDQVQgSUlJJzogMyB9O1xyXG4gICAgY29uc3Qgc2V2ZXJpdHlEaWZmID0gc2V2ZXJpdHlPcmRlclthLnNldmVyaXR5XSAtIHNldmVyaXR5T3JkZXJbYi5zZXZlcml0eV07XHJcbiAgICBpZiAoc2V2ZXJpdHlEaWZmICE9PSAwKSByZXR1cm4gc2V2ZXJpdHlEaWZmO1xyXG4gICAgcmV0dXJuIGEudGl0bGUubG9jYWxlQ29tcGFyZShiLnRpdGxlKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB1bmlxdWUgY291bnQgb2YgU1RJRyByZXF1aXJlbWVudHMgYnkgdGl0bGUgZm9yIGEgZmFtaWx5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pcXVlU3RpZ1JlcXVpcmVtZW50Q291bnQoZmFtaWx5SWQ6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgY29uc3QgcmVxdWlyZW1lbnRzID0gZ2V0U3RvcmVkU3RpZ1JlcXVpcmVtZW50cyhmYW1pbHlJZCk7XHJcbiAgY29uc3QgdGl0bGVTZXQgPSBuZXcgU2V0KHJlcXVpcmVtZW50cy5tYXAocmVxID0+IHJlcS50aXRsZT8udHJpbSgpKS5maWx0ZXIoQm9vbGVhbikpO1xyXG4gIHJldHVybiB0aXRsZVNldC5zaXplO1xyXG59Il0sIm5hbWVzIjpbIlNUSUdfSURfTUFQUElORyIsIm1hcFRvU3RpZ1ZpZXdlcklkIiwiaW50ZXJuYWxJZCIsImNvbnZlcnRDc3ZUb1N0aWdSZXF1aXJlbWVudCIsImNzdlJvdyIsIm5vcm1hbGl6ZVNldmVyaXR5Iiwic2V2ZXJpdHkiLCJzZXYiLCJ0b0xvd2VyQ2FzZSIsImNjaVJlZnMiLCJjY2lzIiwic3BsaXQiLCJmaWx0ZXIiLCJsaW5lIiwiaW5jbHVkZXMiLCJtYXAiLCJtYXRjaCIsImNjaSIsIm5vcm1hbGl6ZVN0YXR1cyIsInN0YXR1cyIsInN0YXQiLCJzdGlnSWQiLCJydWxlSWQiLCJ2dWxuSWQiLCJncm91cElkIiwidW5kZWZpbmVkIiwidGl0bGUiLCJydWxlVGl0bGUiLCJkZXNjcmlwdGlvbiIsImRpc2N1c3Npb24iLCJjaGVja1RleHQiLCJjaGVja0NvbnRlbnQiLCJmaXhUZXh0IiwiYXBwbGljYWJpbGl0eSIsImltcGxlbWVudGF0aW9uU3RhdHVzIiwiY2NpUmVmIiwicGFyc2VTdGlnQ3N2IiwiY3N2Q29udGVudCIsImZhbWlseUlkIiwibGluZXMiLCJsZW5ndGgiLCJoZWFkZXJzIiwiaCIsInJlcGxhY2UiLCJ0cmltIiwicmVxdWlyZW1lbnRzIiwiaSIsInZhbHVlcyIsImN1cnJlbnQiLCJpblF1b3RlcyIsImoiLCJjaGFyIiwicHVzaCIsImZvckVhY2giLCJoZWFkZXIiLCJpbmRleCIsInZhbHVlIiwiYmVuY2htYXJrTmFtZSIsImJlbmNobWFya0lkIiwicmVxdWlyZW1lbnQiLCJmYW1pbHkiLCJ1cGxvYWRlZFN0aWdSZXF1aXJlbWVudHMiLCJzdG9yZVN0aWdSZXF1aXJlbWVudHMiLCJnZXRTdG9yZWRTdGlnUmVxdWlyZW1lbnRzIiwiZ2V0QWxsU3RvcmVkU3RpZ1JlcXVpcmVtZW50cyIsImFsbFJlcXVpcmVtZW50cyIsIk9iamVjdCIsImtleXMiLCJmYW1pbHlSZXF1aXJlbWVudHMiLCJyZXEiLCJpZCIsIkRhdGUiLCJub3ciLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJjbGVhclN0b3JlZFN0aWdSZXF1aXJlbWVudHMiLCJrZXkiLCJnZXREZXRhaWxlZFN0aWdSZXF1aXJlbWVudHMiLCJzdGlnRmFtaWx5SWQiLCJjb252ZXJ0U3RpZ1JlcXVpcmVtZW50c1RvTWF0cml4Iiwic3RpZ0ZhbWlseUlkcyIsImNvbnNvbGUiLCJsb2ciLCJkZXRhaWxlZFJlcXVpcmVtZW50cyIsImZldGNoQW5kQ29udmVydFN0aWdSZXF1aXJlbWVudHMiLCJmYW1pbHlJZHMiLCJmYWlsZWRGZXRjaGVzIiwic3RpZ3ZpZXdlcklkIiwiYXBpVXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJhcGlSZXMiLCJmZXRjaCIsInJlc3VsdCIsImpzb24iLCJvayIsInN1Y2Nlc3MiLCJ3YXJuIiwiZXJyb3IiLCJtZXNzYWdlIiwic2V2ZXJpdHlDb3VudHMiLCJjb252ZXJ0ZWQiLCJzZXZUZXh0IiwiY29udmVydGVkQ291bnRzIiwiZXJyIiwiZiIsImpvaW4iLCJmZXRjaEFuZENvbnZlcnRTdGlnUmVxdWlyZW1lbnRzVG9NYXRyaXgiLCJkZXRhaWxlZCIsImFsbCIsImNvbnZlcnRUb1N0aWdSZXF1aXJlbWVudHMiLCJzdGlnUmVxdWlyZW1lbnRzRGF0YWJhc2UiLCJncm91cFN0aWdSZXF1aXJlbWVudHNCeVRpdGxlIiwiZ3JvdXBlZE1hcCIsIk1hcCIsImhhcyIsImV4aXN0aW5nIiwiZ2V0IiwiY291bnQiLCJzdGlnSWRzIiwic2V0IiwiQXJyYXkiLCJmcm9tIiwic29ydCIsImEiLCJiIiwic2V2ZXJpdHlPcmRlciIsInNldmVyaXR5RGlmZiIsImxvY2FsZUNvbXBhcmUiLCJnZXRVbmlxdWVTdGlnUmVxdWlyZW1lbnRDb3VudCIsInRpdGxlU2V0IiwiU2V0IiwiQm9vbGVhbiIsInNpemUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/detailedStigRequirements.ts\n"));

/***/ })

});