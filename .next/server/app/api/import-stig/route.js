/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/import-stig/route";
exports.ids = ["app/api/import-stig/route"];
exports.modules = {

/***/ "(rsc)/./app/api/import-stig/route.ts":
/*!**************************************!*\
  !*** ./app/api/import-stig/route.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_localStigLibrary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/localStigLibrary */ \"(rsc)/./utils/localStigLibrary.ts\");\n\n\n\n/**\r\n * GET - Fetch STIG from local library or stigviewer.com\r\n * Query params: stigId (e.g., 'apache_server_2.4_unix')\r\n */ async function GET(request) {\n    try {\n        const { searchParams } = new URL(request.url);\n        const stigId = searchParams.get('stigId');\n        if (!stigId) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'stigId parameter is required'\n            }, {\n                status: 400\n            });\n        }\n        // üéØ PRIORITY 1: Check local STIG library first\n        console.log(`üîç Checking local STIG library for: ${stigId}`);\n        if ((0,_utils_localStigLibrary__WEBPACK_IMPORTED_MODULE_2__.hasLocalStig)(stigId)) {\n            console.log(`‚úÖ Found STIG in local library: ${stigId}`);\n            try {\n                const metadata = (0,_utils_localStigLibrary__WEBPACK_IMPORTED_MODULE_2__.getLocalStigMetadata)(stigId);\n                const content = (0,_utils_localStigLibrary__WEBPACK_IMPORTED_MODULE_2__.getLocalStigContent)(stigId);\n                if (content && metadata) {\n                    console.log(`üìÑ Reading local STIG file: ${metadata.filename}`);\n                    // Determine format and parse accordingly\n                    const isXml = metadata.format === 'xml' || metadata.filename.toLowerCase().endsWith('.xml');\n                    if (isXml) {\n                        console.log(`üîÑ Parsing local XML file...`);\n                        const stigData = parseXccdfXml(content, stigId);\n                        if (stigData.requirements.length > 0) {\n                            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                                success: true,\n                                ...stigData,\n                                version: metadata.version,\n                                releaseDate: metadata.releaseDate,\n                                source: 'local',\n                                message: `‚úÖ Successfully imported ${stigData.requirements.length} requirements from local library (${metadata.filename})`\n                            });\n                        }\n                    } else {\n                        console.log(`üîÑ Parsing local CSV file...`);\n                        const stigData = parseStigCsv(content, stigId);\n                        if (stigData.requirements.length > 0) {\n                            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                                success: true,\n                                ...stigData,\n                                stigName: metadata.name,\n                                version: metadata.version,\n                                releaseDate: metadata.releaseDate,\n                                source: 'local',\n                                message: `‚úÖ Successfully imported ${stigData.requirements.length} requirements from local library (${metadata.filename})`\n                            });\n                        }\n                    }\n                }\n            } catch (localError) {\n                console.error(`‚ùå Error reading local STIG: ${localError.message}`);\n            // STIG not found in local library\n            }\n        } else {\n            console.log(`‚ùå STIG not found in local library: ${stigId}`);\n        }\n        // üö´ EXTERNAL API DISABLED: No stigviewer.com fallback\n        // All STIGs must be in local library (/public/stigs/)\n        console.log(`‚ùå STIG \"${stigId}\" not found in local library`);\n        // Return error with instructions for manual upload or local library extraction\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            stigId,\n            error: 'STIG not found in local library',\n            message: `STIG \"${stigId}\" not found in local library. All external API calls are disabled for security.`,\n            instructions: {\n                step1: 'Check available STIGs: Run list-stigs.ps1 to see what\\'s in your local library',\n                step2: 'Browse local library: Use the \"Local Library\" button in the STIG Requirements tab',\n                step3: 'Extract more STIGs: Run extract-stigs.ps1 with the DISA STIG Library ZIP',\n                step4: 'Manual upload: Use the \"Upload STIG\" button to upload XML/CSV files directly',\n                note: 'External API calls to stigviewer.com and DISA websites are disabled'\n            }\n        }, {\n            status: 404\n        });\n    } catch (error) {\n        console.error('‚ùå Error in STIG import:', error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error.message,\n            message: 'An error occurred while importing STIG'\n        }, {\n            status: 500\n        });\n    }\n}\n/**\r\n * Parse DISA STIG CSV file\r\n * CSV format from DISA Cyber Exchange\r\n */ function parseStigCsv(csvContent, fileName) {\n    const requirements = [];\n    // Properly split CSV content into lines, handling multi-line quoted fields\n    const lines = [];\n    let currentLine = '';\n    let insideQuotes = false;\n    for(let i = 0; i < csvContent.length; i++){\n        const char = csvContent[i];\n        const nextChar = csvContent[i + 1];\n        if (char === '\"') {\n            // Check if it's an escaped quote\n            if (nextChar === '\"') {\n                currentLine += char + nextChar;\n                i++; // Skip next quote\n            } else {\n                insideQuotes = !insideQuotes;\n                currentLine += char;\n            }\n        } else if (char === '\\n' && !insideQuotes) {\n            if (currentLine.trim()) {\n                lines.push(currentLine);\n            }\n            currentLine = '';\n        } else if (char === '\\r') {\n            continue;\n        } else {\n            currentLine += char;\n        }\n    }\n    // Add the last line if not empty\n    if (currentLine.trim()) {\n        lines.push(currentLine);\n    }\n    console.log(`üìÑ Split CSV into ${lines.length} lines`);\n    if (lines.length < 2) {\n        return {\n            stigId: fileName.replace(/\\.csv$/i, ''),\n            stigName: 'Imported STIG',\n            version: 'Unknown',\n            releaseDate: new Date().toISOString().split('T')[0],\n            requirements: [],\n            totalRequirements: 0\n        };\n    }\n    // Parse header row - handle quoted CSV fields\n    const parseCSVLine = (line)=>{\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        for(let i = 0; i < line.length; i++){\n            const char = line[i];\n            const nextChar = line[i + 1];\n            if (char === '\"') {\n                if (inQuotes && nextChar === '\"') {\n                    // Escaped quote\n                    current += '\"';\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                }\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        return result;\n    };\n    // Find the header row (skip classification banners like \"~~~~~~~ Unclassified ~~~~~~\")\n    let headerLineIndex = 0;\n    let headers = [];\n    for(let i = 0; i < Math.min(5, lines.length); i++){\n        const parsedLine = parseCSVLine(lines[i]);\n        const lineText = parsedLine.join('').toLowerCase();\n        // Skip classification banners and empty lines\n        if (lineText.includes('unclassified') || lineText.includes('~~~~~') || parsedLine.length < 5) {\n            continue;\n        }\n        // Check if this looks like a header row (has common STIG column names)\n        if (lineText.includes('stig') || lineText.includes('severity') || lineText.includes('rule')) {\n            headerLineIndex = i;\n            headers = parsedLine.map((h)=>h.toLowerCase().trim());\n            console.log(`üìã Found header row at line ${i + 1}`);\n            break;\n        }\n    }\n    if (headers.length === 0) {\n        console.error('‚ùå Could not find valid header row in CSV');\n        return {\n            stigId: fileName.replace(/\\.csv$/i, ''),\n            stigName: 'Imported STIG',\n            version: 'Unknown',\n            releaseDate: new Date().toISOString().split('T')[0],\n            requirements: [],\n            totalRequirements: 0\n        };\n    }\n    console.log(`üìã CSV Headers found: ${headers.slice(0, 10).join(', ')}...`);\n    console.log(`üìã All headers (first 15):`, headers.slice(0, 15));\n    // Find column indices\n    const getIndex = (names)=>{\n        for (const name of names){\n            const idx = headers.findIndex((h)=>h.includes(name));\n            if (idx !== -1) {\n                console.log(`‚úÖ Found \"${name}\" at index ${idx}: \"${headers[idx]}\"`);\n                return idx;\n            }\n        }\n        console.log(`‚ùå Could not find any of: ${names.join(', ')}`);\n        return -1;\n    };\n    const stigIdIdx = getIndex([\n        'stig id',\n        'stigid'\n    ]);\n    const severityIdx = getIndex([\n        'severity'\n    ]);\n    const titleIdx = getIndex([\n        'rule title',\n        'ruletitle'\n    ]);\n    const discussionIdx = getIndex([\n        'discussion'\n    ]);\n    const checkIdx = getIndex([\n        'check content',\n        'checkcontent'\n    ]);\n    const fixIdx = getIndex([\n        'fix text',\n        'fixtext'\n    ]);\n    const cciIdx = getIndex([\n        'ccis',\n        'cci'\n    ]);\n    const ruleIdIdx = getIndex([\n        'rule id',\n        'ruleid'\n    ]);\n    console.log(`üìä Column indices:`, {\n        stigId: stigIdIdx,\n        severity: severityIdx,\n        title: titleIdx,\n        discussion: discussionIdx,\n        check: checkIdx,\n        fix: fixIdx,\n        cci: cciIdx,\n        ruleId: ruleIdIdx\n    });\n    let stigName = 'Imported STIG';\n    let version = 'Unknown';\n    console.log(`üìÑ Processing ${lines.length - headerLineIndex - 1} data rows from CSV`);\n    // Parse data rows (start after header row)\n    for(let i = headerLineIndex + 1; i < lines.length; i++){\n        const line = lines[i].trim();\n        if (!line) continue;\n        const values = parseCSVLine(line);\n        if (i === headerLineIndex + 1) {\n            console.log(`üìù First data row has ${values.length} values`);\n        }\n        // Extract STIG name from first data row if available\n        if (i === headerLineIndex + 1 && values.length > 0) {\n            const benchmarkIdx = headers.findIndex((h)=>h.includes('benchmark'));\n            if (benchmarkIdx !== -1 && values[benchmarkIdx]) {\n                stigName = values[benchmarkIdx];\n            }\n            const versionIdx = headers.findIndex((h)=>h.includes('version') || h.includes('release'));\n            if (versionIdx !== -1 && values[versionIdx]) {\n                version = values[versionIdx];\n            }\n        }\n        const vulnId = stigIdIdx !== -1 ? values[stigIdIdx] : '';\n        const ruleId = ruleIdIdx !== -1 ? values[ruleIdIdx] : vulnId;\n        if (!vulnId) {\n            if (i <= headerLineIndex + 3) {\n                console.log(`‚ö†Ô∏è Line ${i}: No STIG ID found`);\n            }\n            continue;\n        }\n        if (i === headerLineIndex + 1) {\n            console.log(`‚úÖ First requirement found: ${vulnId}`);\n        }\n        // Parse severity - handle multiple formats\n        const severityValue = severityIdx !== -1 ? values[severityIdx].toLowerCase().trim() : 'medium';\n        let severity = 'medium';\n        // Direct severity values\n        if (severityValue === 'high' || severityValue.includes('cat i') || severityValue.includes('cat 1') || severityValue.includes('cati')) {\n            severity = 'high';\n        } else if (severityValue === 'low' || severityValue.includes('cat iii') || severityValue.includes('cat 3') || severityValue.includes('catiii')) {\n            severity = 'low';\n        } else if (severityValue === 'medium' || severityValue.includes('cat ii') || severityValue.includes('cat 2') || severityValue.includes('catii')) {\n            severity = 'medium';\n        }\n        // Log first few for debugging\n        if (i <= headerLineIndex + 3) {\n            console.log(`üìä Row ${i - headerLineIndex}: vulnId=\"${vulnId}\", severity=\"${severityValue}\" ‚Üí ${severity}`);\n        }\n        // Extract CCI references\n        const cciText = cciIdx !== -1 ? values[cciIdx] : '';\n        const cciMatches = cciText.match(/CCI-\\d+/g);\n        const cci = cciMatches || [\n            'CCI-000366'\n        ];\n        requirements.push({\n            vulnId,\n            ruleId,\n            severity,\n            title: titleIdx !== -1 ? values[titleIdx] : `Requirement ${vulnId}`,\n            description: discussionIdx !== -1 ? values[discussionIdx] : 'No description provided',\n            checkText: checkIdx !== -1 ? values[checkIdx] : 'Review system configuration per STIG guidance.',\n            fixText: fixIdx !== -1 ? values[fixIdx] : 'Configure system per STIG guidance.',\n            cci,\n            nistControls: []\n        });\n    }\n    console.log(`‚úÖ CSV parsing complete: ${requirements.length} requirements found`);\n    return {\n        stigId: fileName.replace(/\\.csv$/i, ''),\n        stigName,\n        version,\n        releaseDate: new Date().toISOString().split('T')[0],\n        requirements,\n        totalRequirements: requirements.length\n    };\n}\n/**\r\n * POST - Manual STIG upload (XML or CSV file)\r\n * Body: FormData with 'file' field containing XCCDF XML or DISA CSV\r\n */ async function POST(request) {\n    try {\n        const formData = await request.formData();\n        const file = formData.get('file');\n        if (!file) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'No file provided'\n            }, {\n                status: 400\n            });\n        }\n        // Validate file type\n        const fileName = file.name.toLowerCase();\n        const isXml = fileName.endsWith('.xml') || fileName.endsWith('.xccdf');\n        const isCsv = fileName.endsWith('.csv');\n        if (!isXml && !isCsv) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Invalid file type. Please upload an XCCDF XML file or DISA CSV file.'\n            }, {\n                status: 400\n            });\n        }\n        console.log(`üìÅ Processing manual STIG upload: ${file.name}`);\n        // Read file content\n        const fileContent = await file.text();\n        let stigData;\n        if (isCsv) {\n            // Parse CSV file\n            stigData = parseStigCsv(fileContent, fileName);\n        } else {\n            // Parse XCCDF XML\n            stigData = parseXccdfXml(fileContent, fileName);\n        }\n        if (stigData.requirements.length === 0) {\n            throw new Error(`No requirements found in ${isCsv ? 'CSV' : 'XML'} file. Please ensure this is a valid DISA STIG file.`);\n        }\n        console.log(`‚úÖ Successfully parsed ${stigData.requirements.length} requirements from manual upload`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            ...stigData,\n            source: 'manual',\n            message: `Successfully imported ${stigData.requirements.length} requirements from ${file.name}`\n        });\n    } catch (error) {\n        console.error('‚ùå Error processing manual upload:', error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error.message,\n            message: 'Failed to parse STIG file. Please ensure this is a valid XCCDF XML file.'\n        }, {\n            status: 500\n        });\n    }\n}\n/**\r\n * Fetch detailed requirement page from stigviewer.com\r\n * Returns check and fix text for a specific vulnerability\r\n */ async function fetchRequirementDetails(stigId, vulnId) {\n    try {\n        const agent = new (https__WEBPACK_IMPORTED_MODULE_1___default().Agent)({\n            rejectUnauthorized: false\n        });\n        const url = `https://stigviewer.com/stig/${stigId}/requirement/${vulnId}`;\n        const response = await fetch(url, {\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            },\n            // @ts-ignore\n            agent,\n            signal: AbortSignal.timeout(10000)\n        });\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}`);\n        }\n        const html = await response.text();\n        // Extract check text\n        const checkMatch = html.match(/<div[^>]*(?:id|class)=\"[^\"]*check[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i) || html.match(/Check Text[:\\s]*<[^>]*>([\\s\\S]*?)<\\/(?:div|pre|p)>/i) || html.match(/<pre[^>]*>([\\s\\S]*?)<\\/pre>/i);\n        const checkText = checkMatch ? checkMatch[1].replace(/<[^>]+>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '\"').replace(/\\s+/g, ' ').trim() : 'Review the system configuration to verify compliance with the security requirement.';\n        // Extract fix text  \n        const fixMatch = html.match(/<div[^>]*(?:id|class)=\"[^\"]*fix[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i) || html.match(/Fix Text[:\\s]*<[^>]*>([\\s\\S]*?)<\\/(?:div|pre|p)>/i);\n        const fixText = fixMatch ? fixMatch[1].replace(/<[^>]+>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '\"').replace(/\\s+/g, ' ').trim() : 'Configure the system to meet the security requirement as specified in the STIG documentation.';\n        return {\n            checkText,\n            fixText\n        };\n    } catch (error) {\n        // Return defaults if fetch fails\n        return {\n            checkText: 'Review the system configuration to verify compliance with the security requirement. Detailed check procedure available in the full STIG documentation.',\n            fixText: 'Configure the system to meet the security requirement. Detailed fix procedure available in the full STIG documentation.'\n        };\n    }\n}\n/**\r\n * Parse stig viewer.com JSON API response\r\n * JSON format has complete data including severity for each requirement\r\n */ function parseStigViewerJson(jsonData, stigId) {\n    const requirements = [];\n    try {\n        const stig = jsonData.stig || jsonData;\n        const stigName = stig.title || stigId;\n        const version = stig.version || 'Unknown';\n        const releaseDate = stig.date || new Date().toISOString().split('T')[0];\n        console.log(`üìã Parsing JSON: ${stigName}, Version: ${version}, Release: ${releaseDate}`);\n        const findings = stig.findings || {};\n        const vulnIds = Object.keys(findings);\n        console.log(`üîç Found ${vulnIds.length} requirements in JSON`);\n        vulnIds.forEach((vulnId)=>{\n            const finding = findings[vulnId];\n            if (!finding) return;\n            // Extract severity from finding\n            // JSON might have severity as \"high\", \"medium\", \"low\" or \"CAT I\", \"CAT II\", \"CAT III\"\n            let severity = 'medium';\n            const sevText = (finding.severity || finding.cat || 'medium').toString().toLowerCase();\n            if (sevText.includes('high') || sevText.includes('cat i') || sevText === 'i' || sevText === '1') {\n                severity = 'high';\n            } else if (sevText.includes('low') || sevText.includes('cat iii') || sevText === 'iii' || sevText === '3') {\n                severity = 'low';\n            } else {\n                severity = 'medium';\n            }\n            requirements.push({\n                vulnId,\n                ruleId: finding.ruleId || finding.rule_id || finding.ruleid || `${vulnId}-rule`,\n                severity,\n                title: finding.title || finding.ruleTitle || finding.ruletitle || `Requirement ${vulnId}`,\n                description: finding.discussion || finding.description || finding.title || '',\n                checkText: finding.checktext || finding.checkText || finding.check_text || finding.check || 'Review system configuration per STIG guidance.',\n                fixText: finding.fixtext || finding.fixText || finding.fix_text || finding.fix || 'Configure system per STIG guidance.',\n                cci: finding.cci || finding.ccis || [\n                    'CCI-000366'\n                ],\n                nistControls: finding.nistControls || finding.nist || []\n            });\n        });\n        console.log(`‚úÖ Successfully parsed ${requirements.length} requirements from JSON`);\n        // Log severity distribution\n        const severityDist = {};\n        requirements.forEach((req)=>{\n            severityDist[req.severity] = (severityDist[req.severity] || 0) + 1;\n        });\n        console.log(`üìä JSON Severity Distribution:`, severityDist);\n        return {\n            stigId,\n            stigName,\n            version,\n            releaseDate,\n            requirements,\n            totalRequirements: requirements.length\n        };\n    } catch (error) {\n        console.error('Error parsing stigviewer.com JSON:', error);\n        throw new Error(`Failed to parse stigviewer.com JSON: ${error.message}`);\n    }\n}\n/**\r\n * Parse stigviewer.com HTML to extract STIG requirements\r\n * Fetches full requirement details including check and fix text\r\n */ async function parseStigViewerHtml(html, stigId) {\n    const requirements = [];\n    try {\n        // Extract STIG metadata from page title and headers\n        const titleMatch = html.match(/<title>([^<]+)<\\/title>/i);\n        const stigName = titleMatch ? titleMatch[1].replace(' | STIGViewer', '').trim() : stigId;\n        // Extract version from page\n        const versionMatch = html.match(/Version[:\\s]+([VvRr\\d.]+)/i) || html.match(/class=\"[^\"]*version[^\"]*\"[^>]*>([^<]+)</i);\n        const version = versionMatch ? versionMatch[1].trim() : 'Unknown';\n        // Extract release date\n        const dateMatch = html.match(/Release[:\\s]+(\\d{1,2}\\s+\\w+\\s+\\d{4})/i) || html.match(/Date[:\\s]+(\\d{4}-\\d{2}-\\d{2})/i) || html.match(/(\\d{4}-\\d{2}-\\d{2})/);\n        const releaseDate = dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0];\n        console.log(`üìã Parsing STIG: ${stigName}, Version: ${version}, Release: ${releaseDate}`);\n        // Method 1: Extract complete requirement entries with all details\n        // stigviewer.com has links like: href=\"/stig/{stigId}/requirement/V-#####\"\n        // Pattern to match entire requirement sections with severity info\n        const reqSectionPattern = /(?:CAT\\s+(I{1,3})|severity[^>]*?(high|medium|low))[^V]*(V-\\d+)[^<]*<a[^>]*href=\"[^\"]*\\/requirement\\/\\3\"[^>]*>([^<]+)</gi;\n        let match;\n        const detailedReqs = [];\n        while((match = reqSectionPattern.exec(html)) !== null){\n            const severity = match[1] || match[2]; // CAT I/II/III or high/medium/low\n            const vulnId = match[3];\n            const title = match[4].trim();\n            detailedReqs.push({\n                vulnId,\n                severity,\n                title\n            });\n        }\n        console.log(`üîç Method 1: Found ${detailedReqs.length} requirements with severity info`);\n        // Method 2: Extract from table rows if available\n        const tableRows = [];\n        const rowPattern = /<tr[^>]*>([\\s\\S]*?)<\\/tr>/gi;\n        let rowMatch;\n        while((rowMatch = rowPattern.exec(html)) !== null){\n            const rowHtml = rowMatch[1];\n            // Check if this row has a vuln ID\n            const vulnMatch = rowHtml.match(/>(V-\\d+)</);\n            if (!vulnMatch) continue;\n            const vulnId = vulnMatch[1];\n            // Extract severity from this row\n            const catMatch = rowHtml.match(/CAT\\s+(I{1,3})/i);\n            const sevMatch = rowHtml.match(/>(high|medium|low)</i);\n            const severity = catMatch ? catMatch[1] : sevMatch ? sevMatch[1] : 'II';\n            // Extract title\n            const titleMatch = rowHtml.match(/<a[^>]*href=\"[^\"]*\\/requirement\\/[^\"]*\"[^>]*>([^<]+)</i);\n            const title = titleMatch ? titleMatch[1].trim() : `Requirement ${vulnId}`;\n            tableRows.push({\n                vulnId,\n                severity,\n                title\n            });\n        }\n        console.log(`üîç Method 2: Found ${tableRows.length} requirements from table rows`);\n        // Method 3: Fallback - extract all V-#### with default data\n        const vulnIdPattern = /V-\\d+/g;\n        const allVulnIds = [\n            ...new Set(html.match(vulnIdPattern) || [])\n        ];\n        console.log(`üîç Method 3: Found ${allVulnIds.length} total V-#### patterns`);\n        // Use the method that found the most requirements\n        let reqData = [];\n        if (detailedReqs.length >= tableRows.length && detailedReqs.length > 0) {\n            reqData = detailedReqs;\n            console.log(`‚úì Using Method 1: ${detailedReqs.length} requirements with severity`);\n        } else if (tableRows.length > 0) {\n            reqData = tableRows;\n            console.log(`‚úì Using Method 2: ${tableRows.length} requirements from tables`);\n        } else {\n            // Fallback: create basic entries\n            reqData = allVulnIds.map((vulnId)=>({\n                    vulnId,\n                    severity: 'II',\n                    title: `${stigName} - ${vulnId}`\n                }));\n            console.log(`‚úì Using Method 3: ${allVulnIds.length} basic requirements`);\n        }\n        console.log(`üìù Processing ${reqData.length} requirements...`);\n        let requirementCount = 0;\n        for (const req of reqData){\n            const { vulnId, severity: rawSeverity, title } = req;\n            // Extract Rule ID if available\n            const rulePattern = new RegExp(`${vulnId}[^S]*?(SV-\\\\d+r\\\\d+_rule)`, 'i');\n            const ruleMatch = html.match(rulePattern);\n            const ruleId = ruleMatch ? ruleMatch[1] : `${vulnId}-rule`;\n            // Normalize severity\n            let severity = 'medium';\n            const sevText = rawSeverity.toLowerCase();\n            if (sevText.includes('i') && !sevText.includes('ii') || sevText === 'high' || sevText === '1') {\n                severity = 'high';\n            } else if (sevText.includes('iii') || sevText === 'low' || sevText === '3') {\n                severity = 'low';\n            } else {\n                severity = 'medium';\n            }\n            // Description defaults to title\n            const description = title;\n            // Extract CCI references - search for this vulnId in HTML\n            const vulnContext = html.substring(Math.max(0, html.indexOf(vulnId) - 300), Math.min(html.length, html.indexOf(vulnId) + 300));\n            const cciMatches = vulnContext.match(/CCI-\\d+/g);\n            const cci = cciMatches && cciMatches.length > 0 ? [\n                ...new Set(cciMatches)\n            ] : [\n                'CCI-000366'\n            ];\n            // Default check and fix text with note about full documentation\n            const checkText = `Review the system configuration to verify compliance with ${vulnId}. Refer to the full STIG documentation for detailed check procedures.`;\n            const fixText = `Configure the system to meet the requirements specified in ${vulnId}. Refer to the full STIG documentation for detailed fix procedures.`;\n            // Extract NIST controls from context\n            const nistMatches = vulnContext.match(/([A-Z]{2}-\\d+(?:\\s*\\([a-z0-9]+\\))?)/g);\n            const nistControls = nistMatches ? [\n                ...new Set(nistMatches)\n            ] : [];\n            requirements.push({\n                vulnId,\n                ruleId,\n                severity,\n                title,\n                description,\n                checkText,\n                fixText,\n                cci,\n                nistControls\n            });\n            requirementCount++;\n        }\n        console.log(`‚úÖ Successfully parsed ${requirementCount} requirements from HTML`);\n        // Log severity distribution\n        const severityDist = {};\n        requirements.forEach((req)=>{\n            severityDist[req.severity] = (severityDist[req.severity] || 0) + 1;\n        });\n        console.log(`üìä API Severity Distribution:`, severityDist);\n        // If we didn't find any requirements in table format, try alternative parsing\n        if (requirements.length === 0) {\n            console.warn('‚ö†Ô∏è No requirements found in table format, trying alternative parsing...');\n            // Try to find all V-#### patterns and create basic requirements\n            const vulnIdPattern = /V-\\d+/g;\n            const vulnIds = [\n                ...new Set(html.match(vulnIdPattern) || [])\n            ];\n            vulnIds.forEach((vulnId, index)=>{\n                requirements.push({\n                    vulnId,\n                    ruleId: `${vulnId}-rule`,\n                    severity: 'medium',\n                    title: `${stigName} - ${vulnId}`,\n                    description: `Security requirement ${vulnId} from ${stigName}`,\n                    checkText: 'Review the system configuration to verify compliance. Detailed check procedure available in the full STIG documentation.',\n                    fixText: 'Configure the system to meet the security requirement. Detailed fix procedure available in the full STIG documentation.',\n                    cci: [\n                        'CCI-000366'\n                    ],\n                    nistControls: []\n                });\n            });\n            console.log(`üìù Created ${requirements.length} basic requirements from Vuln IDs`);\n        }\n        return {\n            stigId,\n            stigName,\n            version,\n            releaseDate,\n            requirements,\n            totalRequirements: requirements.length\n        };\n    } catch (error) {\n        console.error('Error parsing stigviewer.com HTML:', error);\n        throw new Error(`Failed to parse stigviewer.com page: ${error.message}`);\n    }\n}\n/**\r\n * Parse XCCDF XML file to extract STIG requirements\r\n */ function parseXccdfXml(xmlContent, fileName) {\n    const requirements = [];\n    try {\n        // Extract STIG ID from filename\n        const stigId = fileName.replace(/\\.xml|\\.xccdf/gi, '').toLowerCase().replace(/\\s+/g, '_');\n        // Parse XML using regex (simplified - in production use a proper XML parser)\n        // Extract Benchmark title\n        const titleMatch = xmlContent.match(/<title[^>]*>([^<]+)<\\/title>/i);\n        const stigName = titleMatch ? titleMatch[1].trim() : stigId;\n        // Extract version\n        const versionMatch = xmlContent.match(/<version[^>]*>([^<]+)<\\/version>/i) || xmlContent.match(/Version[:\\s]+([VvRr\\d.]+)/i);\n        const version = versionMatch ? versionMatch[1] : 'Unknown';\n        // Extract release date\n        const dateMatch = xmlContent.match(/release-date[^>]*>([^<]+)</i) || xmlContent.match(/(\\d{1,2}\\s+\\w+\\s+\\d{4})/);\n        const releaseDate = dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0];\n        // Extract all Group elements (requirements)\n        const groupPattern = /<Group[^>]*id=\"([^\"]+)\"[^>]*>([\\s\\S]*?)<\\/Group>/gi;\n        let groupMatch;\n        while((groupMatch = groupPattern.exec(xmlContent)) !== null){\n            const groupId = groupMatch[1];\n            const groupContent = groupMatch[2];\n            // Extract Rule from Group\n            const ruleMatch = groupContent.match(/<Rule[^>]*id=\"([^\"]+)\"[^>]*severity=\"([^\"]+)\"[^>]*>([\\s\\S]*?)<\\/Rule>/i);\n            if (ruleMatch) {\n                const ruleId = ruleMatch[1];\n                const severity = ruleMatch[2].toLowerCase();\n                const ruleContent = ruleMatch[3];\n                // Extract title\n                const titleMatch = ruleContent.match(/<title[^>]*>([^<]+)<\\/title>/i);\n                const title = titleMatch ? titleMatch[1].trim() : `Requirement ${groupId}`;\n                // Extract description\n                const descMatch = ruleContent.match(/<description[^>]*>([\\s\\S]*?)<\\/description>/i);\n                const description = descMatch ? stripHtml(descMatch[1]) : '';\n                // Extract check text\n                const checkMatch = ruleContent.match(/<check-content[^>]*>([\\s\\S]*?)<\\/check-content>/i);\n                const checkText = checkMatch ? stripHtml(checkMatch[1]) : 'No check procedure provided';\n                // Extract fix text\n                const fixMatch = ruleContent.match(/<fixtext[^>]*>([\\s\\S]*?)<\\/fixtext>/i);\n                const fixText = fixMatch ? stripHtml(fixMatch[1]) : 'No fix procedure provided';\n                // Extract CCI references\n                const cciPattern = /<ident[^>]*system=\"http:\\/\\/cyber\\.mil\\/legacy\\/cci\"[^>]*>([^<]+)<\\/ident>/gi;\n                const cci = [];\n                let cciMatch;\n                while((cciMatch = cciPattern.exec(ruleContent)) !== null){\n                    cci.push(cciMatch[1]);\n                }\n                // Extract NIST controls\n                const nistPattern = /<reference[^>]*>([\\s\\S]*?)NIST[^<]*([A-Z]{2}-\\d+(?:\\s*\\(\\d+\\))?(?:\\s*[a-z])?)[^<]*([\\s\\S]*?)<\\/reference>/gi;\n                const nistControls = [];\n                let nistMatch;\n                while((nistMatch = nistPattern.exec(ruleContent)) !== null){\n                    const control = nistMatch[2].trim();\n                    if (control && !nistControls.includes(control)) {\n                        nistControls.push(control);\n                    }\n                }\n                requirements.push({\n                    vulnId: groupId,\n                    ruleId,\n                    severity,\n                    title,\n                    description: description.substring(0, 500),\n                    checkText: checkText.substring(0, 1000),\n                    fixText: fixText.substring(0, 1000),\n                    cci: cci.length > 0 ? cci : [\n                        'CCI-000000'\n                    ],\n                    nistControls: nistControls.length > 0 ? nistControls : [\n                        'AC-1'\n                    ]\n                });\n            }\n        }\n        if (requirements.length === 0) {\n            throw new Error('No requirements found in XML. The file may not be a valid XCCDF STIG file.');\n        }\n        return {\n            stigId,\n            stigName,\n            version,\n            releaseDate,\n            requirements,\n            totalRequirements: requirements.length\n        };\n    } catch (error) {\n        console.error('Error parsing XCCDF XML:', error);\n        throw new Error(`Failed to parse XCCDF XML: ${error.message}`);\n    }\n}\n/**\r\n * Strip HTML tags and decode entities\r\n */ function stripHtml(html) {\n    return html.replace(/<[^>]+>/g, '') // Remove HTML tags\n    .replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '\"').replace(/&#39;/g, \"'\").replace(/&nbsp;/g, ' ').replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxNQUFNO3dCQUFDO3FCQUFhO29CQUMxQ2EsY0FBY0EsYUFBYTdFLE1BQU0sR0FBRyxJQUFJNkUsZUFBZTt3QkFBQztxQkFBTztnQkFDakU7WUFDRjtRQUNGO1FBRUEsSUFBSTlFLGFBQWFDLE1BQU0sS0FBSyxHQUFHO1lBQzdCLE1BQU0sSUFBSW9GLE1BQU07UUFDbEI7UUFFQSxPQUFPO1lBQ0xyRztZQUNBd0I7WUFDQUw7WUFDQUM7WUFDQUo7WUFDQStCLG1CQUFtQi9CLGFBQWFDLE1BQU07UUFDeEM7SUFFRixFQUFFLE9BQU9kLE9BQVk7UUFDbkJFLFFBQVFGLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE1BQU0sSUFBSWtHLE1BQU0sQ0FBQywyQkFBMkIsRUFBRWxHLE1BQU1tQixPQUFPLEVBQUU7SUFDL0Q7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBUzJKLFVBQVVqRSxJQUFZO0lBQzdCLE9BQU9BLEtBQ0pyRSxPQUFPLENBQUMsWUFBWSxJQUFJLG1CQUFtQjtLQUMzQ0EsT0FBTyxDQUFDLFNBQVMsS0FDakJBLE9BQU8sQ0FBQyxTQUFTLEtBQ2pCQSxPQUFPLENBQUMsVUFBVSxLQUNsQkEsT0FBTyxDQUFDLFdBQVcsS0FDbkJBLE9BQU8sQ0FBQyxVQUFVLEtBQ2xCQSxPQUFPLENBQUMsV0FBVyxLQUNuQkEsT0FBTyxDQUFDLFFBQVEsS0FBSyx1QkFBdUI7S0FDNUNGLElBQUk7QUFDVCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxyb25uaVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2plY3RzXFxTUlRNLXRvb2xcXGFwcFxcYXBpXFxpbXBvcnQtc3RpZ1xccm91dGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcclxuaW1wb3J0IHsgaGFzTG9jYWxTdGlnLCBnZXRMb2NhbFN0aWdDb250ZW50LCBnZXRMb2NhbFN0aWdNZXRhZGF0YSB9IGZyb20gJ0AvdXRpbHMvbG9jYWxTdGlnTGlicmFyeSc7XHJcblxyXG4vKipcclxuICogU1RJRyBJbXBvcnQgQVBJXHJcbiAqIFByaW9yaXR5IG9yZGVyOlxyXG4gKiAxLiBDaGVjayBsb2NhbCBTVElHIGxpYnJhcnkgKC9wdWJsaWMvc3RpZ3MvKVxyXG4gKiAyLiBGYWxsYmFjayB0byBzdGlndmlld2VyLmNvbVxyXG4gKiAzLiBBY2NlcHQgbWFudWFsIHVwbG9hZFxyXG4gKiBcclxuICogTm90ZTogc3RpZ3ZpZXdlci5jb20gaGFzIFNTTCBjZXJ0aWZpY2F0ZSBpc3N1ZXMsIHNvIHdlIGJ5cGFzcyBjZXJ0IHZhbGlkYXRpb25cclxuICovXHJcblxyXG5pbnRlcmZhY2UgU3RpZ1JlcXVpcmVtZW50IHtcclxuICB2dWxuSWQ6IHN0cmluZztcclxuICBydWxlSWQ6IHN0cmluZztcclxuICBzZXZlcml0eTogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgY2hlY2tUZXh0OiBzdHJpbmc7XHJcbiAgZml4VGV4dDogc3RyaW5nO1xyXG4gIGNjaTogc3RyaW5nW107XHJcbiAgbmlzdENvbnRyb2xzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFN0aWdJbXBvcnRSZXN1bHQge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgc3RpZ0lkOiBzdHJpbmc7XHJcbiAgc3RpZ05hbWU6IHN0cmluZztcclxuICB2ZXJzaW9uOiBzdHJpbmc7XHJcbiAgcmVsZWFzZURhdGU6IHN0cmluZztcclxuICByZXF1aXJlbWVudHM6IFN0aWdSZXF1aXJlbWVudFtdO1xyXG4gIHRvdGFsUmVxdWlyZW1lbnRzOiBudW1iZXI7XHJcbiAgc291cmNlOiAnc3RpZ3ZpZXdlcicgfCAnbWFudWFsJyB8ICdjYWNoZScgfCAnbG9jYWwnO1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbiAgZXJyb3I/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHRVQgLSBGZXRjaCBTVElHIGZyb20gbG9jYWwgbGlicmFyeSBvciBzdGlndmlld2VyLmNvbVxyXG4gKiBRdWVyeSBwYXJhbXM6IHN0aWdJZCAoZS5nLiwgJ2FwYWNoZV9zZXJ2ZXJfMi40X3VuaXgnKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XHJcbiAgICBjb25zdCBzdGlnSWQgPSBzZWFyY2hQYXJhbXMuZ2V0KCdzdGlnSWQnKTtcclxuXHJcbiAgICBpZiAoIXN0aWdJZCkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBlcnJvcjogJ3N0aWdJZCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g8J+OryBQUklPUklUWSAxOiBDaGVjayBsb2NhbCBTVElHIGxpYnJhcnkgZmlyc3RcclxuICAgIGNvbnNvbGUubG9nKGDwn5SNIENoZWNraW5nIGxvY2FsIFNUSUcgbGlicmFyeSBmb3I6ICR7c3RpZ0lkfWApO1xyXG4gICAgXHJcbiAgICBpZiAoaGFzTG9jYWxTdGlnKHN0aWdJZCkpIHtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBTVElHIGluIGxvY2FsIGxpYnJhcnk6ICR7c3RpZ0lkfWApO1xyXG4gICAgICBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGdldExvY2FsU3RpZ01ldGFkYXRhKHN0aWdJZCk7XHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IGdldExvY2FsU3RpZ0NvbnRlbnQoc3RpZ0lkKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY29udGVudCAmJiBtZXRhZGF0YSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfk4QgUmVhZGluZyBsb2NhbCBTVElHIGZpbGU6ICR7bWV0YWRhdGEuZmlsZW5hbWV9YCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIERldGVybWluZSBmb3JtYXQgYW5kIHBhcnNlIGFjY29yZGluZ2x5XHJcbiAgICAgICAgICBjb25zdCBpc1htbCA9IG1ldGFkYXRhLmZvcm1hdCA9PT0gJ3htbCcgfHwgbWV0YWRhdGEuZmlsZW5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLnhtbCcpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoaXNYbWwpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflIQgUGFyc2luZyBsb2NhbCBYTUwgZmlsZS4uLmApO1xyXG4gICAgICAgICAgICBjb25zdCBzdGlnRGF0YSA9IHBhcnNlWGNjZGZYbWwoY29udGVudCwgc3RpZ0lkKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChzdGlnRGF0YS5yZXF1aXJlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgLi4uc3RpZ0RhdGEsXHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBtZXRhZGF0YS52ZXJzaW9uLFxyXG4gICAgICAgICAgICAgICAgcmVsZWFzZURhdGU6IG1ldGFkYXRhLnJlbGVhc2VEYXRlLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiAnbG9jYWwnLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYOKchSBTdWNjZXNzZnVsbHkgaW1wb3J0ZWQgJHtzdGlnRGF0YS5yZXF1aXJlbWVudHMubGVuZ3RofSByZXF1aXJlbWVudHMgZnJvbSBsb2NhbCBsaWJyYXJ5ICgke21ldGFkYXRhLmZpbGVuYW1lfSlgXHJcbiAgICAgICAgICAgICAgfSBhcyBTdGlnSW1wb3J0UmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflIQgUGFyc2luZyBsb2NhbCBDU1YgZmlsZS4uLmApO1xyXG4gICAgICAgICAgICBjb25zdCBzdGlnRGF0YSA9IHBhcnNlU3RpZ0Nzdihjb250ZW50LCBzdGlnSWQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHN0aWdEYXRhLnJlcXVpcmVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAuLi5zdGlnRGF0YSxcclxuICAgICAgICAgICAgICAgIHN0aWdOYW1lOiBtZXRhZGF0YS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogbWV0YWRhdGEudmVyc2lvbixcclxuICAgICAgICAgICAgICAgIHJlbGVhc2VEYXRlOiBtZXRhZGF0YS5yZWxlYXNlRGF0ZSxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogJ2xvY2FsJyxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGDinIUgU3VjY2Vzc2Z1bGx5IGltcG9ydGVkICR7c3RpZ0RhdGEucmVxdWlyZW1lbnRzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZyb20gbG9jYWwgbGlicmFyeSAoJHttZXRhZGF0YS5maWxlbmFtZX0pYFxyXG4gICAgICAgICAgICAgIH0gYXMgU3RpZ0ltcG9ydFJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGxvY2FsRXJyb3I6IGFueSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciByZWFkaW5nIGxvY2FsIFNUSUc6ICR7bG9jYWxFcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAgIC8vIFNUSUcgbm90IGZvdW5kIGluIGxvY2FsIGxpYnJhcnlcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5sb2coYOKdjCBTVElHIG5vdCBmb3VuZCBpbiBsb2NhbCBsaWJyYXJ5OiAke3N0aWdJZH1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDwn5qrIEVYVEVSTkFMIEFQSSBESVNBQkxFRDogTm8gc3RpZ3ZpZXdlci5jb20gZmFsbGJhY2tcclxuICAgIC8vIEFsbCBTVElHcyBtdXN0IGJlIGluIGxvY2FsIGxpYnJhcnkgKC9wdWJsaWMvc3RpZ3MvKVxyXG4gICAgY29uc29sZS5sb2coYOKdjCBTVElHIFwiJHtzdGlnSWR9XCIgbm90IGZvdW5kIGluIGxvY2FsIGxpYnJhcnlgKTtcclxuICAgIFxyXG4gICAgLy8gUmV0dXJuIGVycm9yIHdpdGggaW5zdHJ1Y3Rpb25zIGZvciBtYW51YWwgdXBsb2FkIG9yIGxvY2FsIGxpYnJhcnkgZXh0cmFjdGlvblxyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIHN0aWdJZCxcclxuICAgICAgZXJyb3I6ICdTVElHIG5vdCBmb3VuZCBpbiBsb2NhbCBsaWJyYXJ5JyxcclxuICAgICAgbWVzc2FnZTogYFNUSUcgXCIke3N0aWdJZH1cIiBub3QgZm91bmQgaW4gbG9jYWwgbGlicmFyeS4gQWxsIGV4dGVybmFsIEFQSSBjYWxscyBhcmUgZGlzYWJsZWQgZm9yIHNlY3VyaXR5LmAsXHJcbiAgICAgIGluc3RydWN0aW9uczoge1xyXG4gICAgICAgIHN0ZXAxOiAnQ2hlY2sgYXZhaWxhYmxlIFNUSUdzOiBSdW4gbGlzdC1zdGlncy5wczEgdG8gc2VlIHdoYXRcXCdzIGluIHlvdXIgbG9jYWwgbGlicmFyeScsXHJcbiAgICAgICAgc3RlcDI6ICdCcm93c2UgbG9jYWwgbGlicmFyeTogVXNlIHRoZSBcIkxvY2FsIExpYnJhcnlcIiBidXR0b24gaW4gdGhlIFNUSUcgUmVxdWlyZW1lbnRzIHRhYicsXHJcbiAgICAgICAgc3RlcDM6ICdFeHRyYWN0IG1vcmUgU1RJR3M6IFJ1biBleHRyYWN0LXN0aWdzLnBzMSB3aXRoIHRoZSBESVNBIFNUSUcgTGlicmFyeSBaSVAnLFxyXG4gICAgICAgIHN0ZXA0OiAnTWFudWFsIHVwbG9hZDogVXNlIHRoZSBcIlVwbG9hZCBTVElHXCIgYnV0dG9uIHRvIHVwbG9hZCBYTUwvQ1NWIGZpbGVzIGRpcmVjdGx5JyxcclxuICAgICAgICBub3RlOiAnRXh0ZXJuYWwgQVBJIGNhbGxzIHRvIHN0aWd2aWV3ZXIuY29tIGFuZCBESVNBIHdlYnNpdGVzIGFyZSBkaXNhYmxlZCdcclxuICAgICAgfVxyXG4gICAgfSwgeyBzdGF0dXM6IDQwNCB9KTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGluIFNUSUcgaW1wb3J0OicsIGVycm9yKTtcclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgeyBcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBtZXNzYWdlOiAnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgaW1wb3J0aW5nIFNUSUcnXHJcbiAgICAgIH0sXHJcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBESVNBIFNUSUcgQ1NWIGZpbGVcclxuICogQ1NWIGZvcm1hdCBmcm9tIERJU0EgQ3liZXIgRXhjaGFuZ2VcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlU3RpZ0Nzdihjc3ZDb250ZW50OiBzdHJpbmcsIGZpbGVOYW1lOiBzdHJpbmcpOiBPbWl0PFN0aWdJbXBvcnRSZXN1bHQsICdzdWNjZXNzJyB8ICdzb3VyY2UnIHwgJ21lc3NhZ2UnPiB7XHJcbiAgY29uc3QgcmVxdWlyZW1lbnRzOiBTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG4gIFxyXG4gIC8vIFByb3Blcmx5IHNwbGl0IENTViBjb250ZW50IGludG8gbGluZXMsIGhhbmRsaW5nIG11bHRpLWxpbmUgcXVvdGVkIGZpZWxkc1xyXG4gIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGxldCBjdXJyZW50TGluZSA9ICcnO1xyXG4gIGxldCBpbnNpZGVRdW90ZXMgPSBmYWxzZTtcclxuICBcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNzdkNvbnRlbnQubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNoYXIgPSBjc3ZDb250ZW50W2ldO1xyXG4gICAgY29uc3QgbmV4dENoYXIgPSBjc3ZDb250ZW50W2kgKyAxXTtcclxuICAgIFxyXG4gICAgaWYgKGNoYXIgPT09ICdcIicpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBlc2NhcGVkIHF1b3RlXHJcbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gJ1wiJykge1xyXG4gICAgICAgIGN1cnJlbnRMaW5lICs9IGNoYXIgKyBuZXh0Q2hhcjtcclxuICAgICAgICBpKys7IC8vIFNraXAgbmV4dCBxdW90ZVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluc2lkZVF1b3RlcyA9ICFpbnNpZGVRdW90ZXM7XHJcbiAgICAgICAgY3VycmVudExpbmUgKz0gY2hhcjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChjaGFyID09PSAnXFxuJyAmJiAhaW5zaWRlUXVvdGVzKSB7XHJcbiAgICAgIGlmIChjdXJyZW50TGluZS50cmltKCkpIHtcclxuICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcclxuICAgICAgfVxyXG4gICAgICBjdXJyZW50TGluZSA9ICcnO1xyXG4gICAgfSBlbHNlIGlmIChjaGFyID09PSAnXFxyJykge1xyXG4gICAgICAvLyBTa2lwIGNhcnJpYWdlIHJldHVybnNcclxuICAgICAgY29udGludWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdXJyZW50TGluZSArPSBjaGFyO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICAvLyBBZGQgdGhlIGxhc3QgbGluZSBpZiBub3QgZW1wdHlcclxuICBpZiAoY3VycmVudExpbmUudHJpbSgpKSB7XHJcbiAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcclxuICB9XHJcbiAgXHJcbiAgY29uc29sZS5sb2coYPCfk4QgU3BsaXQgQ1NWIGludG8gJHtsaW5lcy5sZW5ndGh9IGxpbmVzYCk7XHJcbiAgXHJcbiAgaWYgKGxpbmVzLmxlbmd0aCA8IDIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0aWdJZDogZmlsZU5hbWUucmVwbGFjZSgvXFwuY3N2JC9pLCAnJyksXHJcbiAgICAgIHN0aWdOYW1lOiAnSW1wb3J0ZWQgU1RJRycsXHJcbiAgICAgIHZlcnNpb246ICdVbmtub3duJyxcclxuICAgICAgcmVsZWFzZURhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxyXG4gICAgICByZXF1aXJlbWVudHM6IFtdLFxyXG4gICAgICB0b3RhbFJlcXVpcmVtZW50czogMFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFBhcnNlIGhlYWRlciByb3cgLSBoYW5kbGUgcXVvdGVkIENTViBmaWVsZHNcclxuICBjb25zdCBwYXJzZUNTVkxpbmUgPSAobGluZTogc3RyaW5nKTogc3RyaW5nW10gPT4ge1xyXG4gICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnQgPSAnJztcclxuICAgIGxldCBpblF1b3RlcyA9IGZhbHNlO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBjaGFyID0gbGluZVtpXTtcclxuICAgICAgY29uc3QgbmV4dENoYXIgPSBsaW5lW2kgKyAxXTtcclxuICAgICAgXHJcbiAgICAgIGlmIChjaGFyID09PSAnXCInKSB7XHJcbiAgICAgICAgaWYgKGluUXVvdGVzICYmIG5leHRDaGFyID09PSAnXCInKSB7XHJcbiAgICAgICAgICAvLyBFc2NhcGVkIHF1b3RlXHJcbiAgICAgICAgICBjdXJyZW50ICs9ICdcIic7XHJcbiAgICAgICAgICBpKys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGluUXVvdGVzID0gIWluUXVvdGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnLCcgJiYgIWluUXVvdGVzKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudC50cmltKCkpO1xyXG4gICAgICAgIGN1cnJlbnQgPSAnJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyZW50ICs9IGNoYXI7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudHJpbSgpKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gRmluZCB0aGUgaGVhZGVyIHJvdyAoc2tpcCBjbGFzc2lmaWNhdGlvbiBiYW5uZXJzIGxpa2UgXCJ+fn5+fn5+IFVuY2xhc3NpZmllZCB+fn5+fn5cIilcclxuICBsZXQgaGVhZGVyTGluZUluZGV4ID0gMDtcclxuICBsZXQgaGVhZGVyczogc3RyaW5nW10gPSBbXTtcclxuICBcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKDUsIGxpbmVzLmxlbmd0aCk7IGkrKykge1xyXG4gICAgY29uc3QgcGFyc2VkTGluZSA9IHBhcnNlQ1NWTGluZShsaW5lc1tpXSk7XHJcbiAgICBjb25zdCBsaW5lVGV4dCA9IHBhcnNlZExpbmUuam9pbignJykudG9Mb3dlckNhc2UoKTtcclxuICAgIFxyXG4gICAgLy8gU2tpcCBjbGFzc2lmaWNhdGlvbiBiYW5uZXJzIGFuZCBlbXB0eSBsaW5lc1xyXG4gICAgaWYgKGxpbmVUZXh0LmluY2x1ZGVzKCd1bmNsYXNzaWZpZWQnKSB8fCBsaW5lVGV4dC5pbmNsdWRlcygnfn5+fn4nKSB8fCBwYXJzZWRMaW5lLmxlbmd0aCA8IDUpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIHRoaXMgbG9va3MgbGlrZSBhIGhlYWRlciByb3cgKGhhcyBjb21tb24gU1RJRyBjb2x1bW4gbmFtZXMpXHJcbiAgICBpZiAobGluZVRleHQuaW5jbHVkZXMoJ3N0aWcnKSB8fCBsaW5lVGV4dC5pbmNsdWRlcygnc2V2ZXJpdHknKSB8fCBsaW5lVGV4dC5pbmNsdWRlcygncnVsZScpKSB7XHJcbiAgICAgIGhlYWRlckxpbmVJbmRleCA9IGk7XHJcbiAgICAgIGhlYWRlcnMgPSBwYXJzZWRMaW5lLm1hcChoID0+IGgudG9Mb3dlckNhc2UoKS50cmltKCkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiyBGb3VuZCBoZWFkZXIgcm93IGF0IGxpbmUgJHtpICsgMX1gKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChoZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIENvdWxkIG5vdCBmaW5kIHZhbGlkIGhlYWRlciByb3cgaW4gQ1NWJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGlnSWQ6IGZpbGVOYW1lLnJlcGxhY2UoL1xcLmNzdiQvaSwgJycpLFxyXG4gICAgICBzdGlnTmFtZTogJ0ltcG9ydGVkIFNUSUcnLFxyXG4gICAgICB2ZXJzaW9uOiAnVW5rbm93bicsXHJcbiAgICAgIHJlbGVhc2VEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcclxuICAgICAgcmVxdWlyZW1lbnRzOiBbXSxcclxuICAgICAgdG90YWxSZXF1aXJlbWVudHM6IDBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhg8J+TiyBDU1YgSGVhZGVycyBmb3VuZDogJHtoZWFkZXJzLnNsaWNlKDAsIDEwKS5qb2luKCcsICcpfS4uLmApO1xyXG4gIGNvbnNvbGUubG9nKGDwn5OLIEFsbCBoZWFkZXJzIChmaXJzdCAxNSk6YCwgaGVhZGVycy5zbGljZSgwLCAxNSkpO1xyXG4gIFxyXG4gIC8vIEZpbmQgY29sdW1uIGluZGljZXNcclxuICBjb25zdCBnZXRJbmRleCA9IChuYW1lczogc3RyaW5nW10pID0+IHtcclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xyXG4gICAgICBjb25zdCBpZHggPSBoZWFkZXJzLmZpbmRJbmRleChoID0+IGguaW5jbHVkZXMobmFtZSkpO1xyXG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgXCIke25hbWV9XCIgYXQgaW5kZXggJHtpZHh9OiBcIiR7aGVhZGVyc1tpZHhdfVwiYCk7XHJcbiAgICAgICAgcmV0dXJuIGlkeDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coYOKdjCBDb3VsZCBub3QgZmluZCBhbnkgb2Y6ICR7bmFtZXMuam9pbignLCAnKX1gKTtcclxuICAgIHJldHVybiAtMTtcclxuICB9O1xyXG5cclxuICBjb25zdCBzdGlnSWRJZHggPSBnZXRJbmRleChbJ3N0aWcgaWQnLCAnc3RpZ2lkJ10pO1xyXG4gIGNvbnN0IHNldmVyaXR5SWR4ID0gZ2V0SW5kZXgoWydzZXZlcml0eSddKTtcclxuICBjb25zdCB0aXRsZUlkeCA9IGdldEluZGV4KFsncnVsZSB0aXRsZScsICdydWxldGl0bGUnXSk7XHJcbiAgY29uc3QgZGlzY3Vzc2lvbklkeCA9IGdldEluZGV4KFsnZGlzY3Vzc2lvbiddKTtcclxuICBjb25zdCBjaGVja0lkeCA9IGdldEluZGV4KFsnY2hlY2sgY29udGVudCcsICdjaGVja2NvbnRlbnQnXSk7XHJcbiAgY29uc3QgZml4SWR4ID0gZ2V0SW5kZXgoWydmaXggdGV4dCcsICdmaXh0ZXh0J10pO1xyXG4gIGNvbnN0IGNjaUlkeCA9IGdldEluZGV4KFsnY2NpcycsICdjY2knXSk7XHJcbiAgY29uc3QgcnVsZUlkSWR4ID0gZ2V0SW5kZXgoWydydWxlIGlkJywgJ3J1bGVpZCddKTtcclxuICBcclxuICBjb25zb2xlLmxvZyhg8J+TiiBDb2x1bW4gaW5kaWNlczpgLCB7XHJcbiAgICBzdGlnSWQ6IHN0aWdJZElkeCxcclxuICAgIHNldmVyaXR5OiBzZXZlcml0eUlkeCxcclxuICAgIHRpdGxlOiB0aXRsZUlkeCxcclxuICAgIGRpc2N1c3Npb246IGRpc2N1c3Npb25JZHgsXHJcbiAgICBjaGVjazogY2hlY2tJZHgsXHJcbiAgICBmaXg6IGZpeElkeCxcclxuICAgIGNjaTogY2NpSWR4LFxyXG4gICAgcnVsZUlkOiBydWxlSWRJZHhcclxuICB9KTtcclxuXHJcbiAgbGV0IHN0aWdOYW1lID0gJ0ltcG9ydGVkIFNUSUcnO1xyXG4gIGxldCB2ZXJzaW9uID0gJ1Vua25vd24nO1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKGDwn5OEIFByb2Nlc3NpbmcgJHtsaW5lcy5sZW5ndGggLSBoZWFkZXJMaW5lSW5kZXggLSAxfSBkYXRhIHJvd3MgZnJvbSBDU1ZgKTtcclxuICBcclxuICAvLyBQYXJzZSBkYXRhIHJvd3MgKHN0YXJ0IGFmdGVyIGhlYWRlciByb3cpXHJcbiAgZm9yIChsZXQgaSA9IGhlYWRlckxpbmVJbmRleCArIDE7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcclxuICAgIGlmICghbGluZSkgY29udGludWU7XHJcblxyXG4gICAgY29uc3QgdmFsdWVzID0gcGFyc2VDU1ZMaW5lKGxpbmUpO1xyXG4gICAgXHJcbiAgICBpZiAoaSA9PT0gaGVhZGVyTGluZUluZGV4ICsgMSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TnSBGaXJzdCBkYXRhIHJvdyBoYXMgJHt2YWx1ZXMubGVuZ3RofSB2YWx1ZXNgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBTVElHIG5hbWUgZnJvbSBmaXJzdCBkYXRhIHJvdyBpZiBhdmFpbGFibGVcclxuICAgIGlmIChpID09PSBoZWFkZXJMaW5lSW5kZXggKyAxICYmIHZhbHVlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGJlbmNobWFya0lkeCA9IGhlYWRlcnMuZmluZEluZGV4KGggPT4gaC5pbmNsdWRlcygnYmVuY2htYXJrJykpO1xyXG4gICAgICBpZiAoYmVuY2htYXJrSWR4ICE9PSAtMSAmJiB2YWx1ZXNbYmVuY2htYXJrSWR4XSkge1xyXG4gICAgICAgIHN0aWdOYW1lID0gdmFsdWVzW2JlbmNobWFya0lkeF07XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdmVyc2lvbklkeCA9IGhlYWRlcnMuZmluZEluZGV4KGggPT4gaC5pbmNsdWRlcygndmVyc2lvbicpIHx8IGguaW5jbHVkZXMoJ3JlbGVhc2UnKSk7XHJcbiAgICAgIGlmICh2ZXJzaW9uSWR4ICE9PSAtMSAmJiB2YWx1ZXNbdmVyc2lvbklkeF0pIHtcclxuICAgICAgICB2ZXJzaW9uID0gdmFsdWVzW3ZlcnNpb25JZHhdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdnVsbklkID0gc3RpZ0lkSWR4ICE9PSAtMSA/IHZhbHVlc1tzdGlnSWRJZHhdIDogJyc7XHJcbiAgICBjb25zdCBydWxlSWQgPSBydWxlSWRJZHggIT09IC0xID8gdmFsdWVzW3J1bGVJZElkeF0gOiB2dWxuSWQ7XHJcbiAgICBcclxuICAgIGlmICghdnVsbklkKSB7XHJcbiAgICAgIGlmIChpIDw9IGhlYWRlckxpbmVJbmRleCArIDMpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIExpbmUgJHtpfTogTm8gU1RJRyBJRCBmb3VuZGApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoaSA9PT0gaGVhZGVyTGluZUluZGV4ICsgMSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIEZpcnN0IHJlcXVpcmVtZW50IGZvdW5kOiAke3Z1bG5JZH1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSBzZXZlcml0eSAtIGhhbmRsZSBtdWx0aXBsZSBmb3JtYXRzXHJcbiAgICBjb25zdCBzZXZlcml0eVZhbHVlID0gc2V2ZXJpdHlJZHggIT09IC0xID8gdmFsdWVzW3NldmVyaXR5SWR4XS50b0xvd2VyQ2FzZSgpLnRyaW0oKSA6ICdtZWRpdW0nO1xyXG4gICAgbGV0IHNldmVyaXR5OiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnID0gJ21lZGl1bSc7XHJcbiAgICBcclxuICAgIC8vIERpcmVjdCBzZXZlcml0eSB2YWx1ZXNcclxuICAgIGlmIChzZXZlcml0eVZhbHVlID09PSAnaGlnaCcgfHwgc2V2ZXJpdHlWYWx1ZS5pbmNsdWRlcygnY2F0IGknKSB8fCBzZXZlcml0eVZhbHVlLmluY2x1ZGVzKCdjYXQgMScpIHx8IHNldmVyaXR5VmFsdWUuaW5jbHVkZXMoJ2NhdGknKSkge1xyXG4gICAgICBzZXZlcml0eSA9ICdoaWdoJztcclxuICAgIH0gZWxzZSBpZiAoc2V2ZXJpdHlWYWx1ZSA9PT0gJ2xvdycgfHwgc2V2ZXJpdHlWYWx1ZS5pbmNsdWRlcygnY2F0IGlpaScpIHx8IHNldmVyaXR5VmFsdWUuaW5jbHVkZXMoJ2NhdCAzJykgfHwgc2V2ZXJpdHlWYWx1ZS5pbmNsdWRlcygnY2F0aWlpJykpIHtcclxuICAgICAgc2V2ZXJpdHkgPSAnbG93JztcclxuICAgIH0gZWxzZSBpZiAoc2V2ZXJpdHlWYWx1ZSA9PT0gJ21lZGl1bScgfHwgc2V2ZXJpdHlWYWx1ZS5pbmNsdWRlcygnY2F0IGlpJykgfHwgc2V2ZXJpdHlWYWx1ZS5pbmNsdWRlcygnY2F0IDInKSB8fCBzZXZlcml0eVZhbHVlLmluY2x1ZGVzKCdjYXRpaScpKSB7XHJcbiAgICAgIHNldmVyaXR5ID0gJ21lZGl1bSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIExvZyBmaXJzdCBmZXcgZm9yIGRlYnVnZ2luZ1xyXG4gICAgaWYgKGkgPD0gaGVhZGVyTGluZUluZGV4ICsgMykge1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBSb3cgJHtpIC0gaGVhZGVyTGluZUluZGV4fTogdnVsbklkPVwiJHt2dWxuSWR9XCIsIHNldmVyaXR5PVwiJHtzZXZlcml0eVZhbHVlfVwiIOKGkiAke3NldmVyaXR5fWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dHJhY3QgQ0NJIHJlZmVyZW5jZXNcclxuICAgIGNvbnN0IGNjaVRleHQgPSBjY2lJZHggIT09IC0xID8gdmFsdWVzW2NjaUlkeF0gOiAnJztcclxuICAgIGNvbnN0IGNjaU1hdGNoZXMgPSBjY2lUZXh0Lm1hdGNoKC9DQ0ktXFxkKy9nKTtcclxuICAgIGNvbnN0IGNjaSA9IGNjaU1hdGNoZXMgfHwgWydDQ0ktMDAwMzY2J107XHJcblxyXG4gICAgcmVxdWlyZW1lbnRzLnB1c2goe1xyXG4gICAgICB2dWxuSWQsXHJcbiAgICAgIHJ1bGVJZCxcclxuICAgICAgc2V2ZXJpdHksXHJcbiAgICAgIHRpdGxlOiB0aXRsZUlkeCAhPT0gLTEgPyB2YWx1ZXNbdGl0bGVJZHhdIDogYFJlcXVpcmVtZW50ICR7dnVsbklkfWAsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBkaXNjdXNzaW9uSWR4ICE9PSAtMSA/IHZhbHVlc1tkaXNjdXNzaW9uSWR4XSA6ICdObyBkZXNjcmlwdGlvbiBwcm92aWRlZCcsXHJcbiAgICAgIGNoZWNrVGV4dDogY2hlY2tJZHggIT09IC0xID8gdmFsdWVzW2NoZWNrSWR4XSA6ICdSZXZpZXcgc3lzdGVtIGNvbmZpZ3VyYXRpb24gcGVyIFNUSUcgZ3VpZGFuY2UuJyxcclxuICAgICAgZml4VGV4dDogZml4SWR4ICE9PSAtMSA/IHZhbHVlc1tmaXhJZHhdIDogJ0NvbmZpZ3VyZSBzeXN0ZW0gcGVyIFNUSUcgZ3VpZGFuY2UuJyxcclxuICAgICAgY2NpLFxyXG4gICAgICBuaXN0Q29udHJvbHM6IFtdXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNvbnNvbGUubG9nKGDinIUgQ1NWIHBhcnNpbmcgY29tcGxldGU6ICR7cmVxdWlyZW1lbnRzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZvdW5kYCk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzdGlnSWQ6IGZpbGVOYW1lLnJlcGxhY2UoL1xcLmNzdiQvaSwgJycpLFxyXG4gICAgc3RpZ05hbWUsXHJcbiAgICB2ZXJzaW9uLFxyXG4gICAgcmVsZWFzZURhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxyXG4gICAgcmVxdWlyZW1lbnRzLFxyXG4gICAgdG90YWxSZXF1aXJlbWVudHM6IHJlcXVpcmVtZW50cy5sZW5ndGhcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogUE9TVCAtIE1hbnVhbCBTVElHIHVwbG9hZCAoWE1MIG9yIENTViBmaWxlKVxyXG4gKiBCb2R5OiBGb3JtRGF0YSB3aXRoICdmaWxlJyBmaWVsZCBjb250YWluaW5nIFhDQ0RGIFhNTCBvciBESVNBIENTVlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XHJcbiAgICBjb25zdCBmaWxlID0gZm9ybURhdGEuZ2V0KCdmaWxlJykgYXMgRmlsZTtcclxuXHJcbiAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICAgIHsgZXJyb3I6ICdObyBmaWxlIHByb3ZpZGVkJyB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkYXRlIGZpbGUgdHlwZVxyXG4gICAgY29uc3QgZmlsZU5hbWUgPSBmaWxlLm5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IGlzWG1sID0gZmlsZU5hbWUuZW5kc1dpdGgoJy54bWwnKSB8fCBmaWxlTmFtZS5lbmRzV2l0aCgnLnhjY2RmJyk7XHJcbiAgICBjb25zdCBpc0NzdiA9IGZpbGVOYW1lLmVuZHNXaXRoKCcuY3N2Jyk7XHJcbiAgICBcclxuICAgIGlmICghaXNYbWwgJiYgIWlzQ3N2KSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IGVycm9yOiAnSW52YWxpZCBmaWxlIHR5cGUuIFBsZWFzZSB1cGxvYWQgYW4gWENDREYgWE1MIGZpbGUgb3IgRElTQSBDU1YgZmlsZS4nIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYPCfk4EgUHJvY2Vzc2luZyBtYW51YWwgU1RJRyB1cGxvYWQ6ICR7ZmlsZS5uYW1lfWApO1xyXG5cclxuICAgIC8vIFJlYWQgZmlsZSBjb250ZW50XHJcbiAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IGZpbGUudGV4dCgpO1xyXG5cclxuICAgIGxldCBzdGlnRGF0YTtcclxuICAgIFxyXG4gICAgaWYgKGlzQ3N2KSB7XHJcbiAgICAgIC8vIFBhcnNlIENTViBmaWxlXHJcbiAgICAgIHN0aWdEYXRhID0gcGFyc2VTdGlnQ3N2KGZpbGVDb250ZW50LCBmaWxlTmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBQYXJzZSBYQ0NERiBYTUxcclxuICAgICAgc3RpZ0RhdGEgPSBwYXJzZVhjY2RmWG1sKGZpbGVDb250ZW50LCBmaWxlTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0aWdEYXRhLnJlcXVpcmVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyByZXF1aXJlbWVudHMgZm91bmQgaW4gJHtpc0NzdiA/ICdDU1YnIDogJ1hNTCd9IGZpbGUuIFBsZWFzZSBlbnN1cmUgdGhpcyBpcyBhIHZhbGlkIERJU0EgU1RJRyBmaWxlLmApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IHBhcnNlZCAke3N0aWdEYXRhLnJlcXVpcmVtZW50cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmcm9tIG1hbnVhbCB1cGxvYWRgKTtcclxuXHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAuLi5zdGlnRGF0YSxcclxuICAgICAgc291cmNlOiAnbWFudWFsJyxcclxuICAgICAgbWVzc2FnZTogYFN1Y2Nlc3NmdWxseSBpbXBvcnRlZCAke3N0aWdEYXRhLnJlcXVpcmVtZW50cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmcm9tICR7ZmlsZS5uYW1lfWBcclxuICAgIH0gYXMgU3RpZ0ltcG9ydFJlc3VsdCk7XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBwcm9jZXNzaW5nIG1hbnVhbCB1cGxvYWQ6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICB7IFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gcGFyc2UgU1RJRyBmaWxlLiBQbGVhc2UgZW5zdXJlIHRoaXMgaXMgYSB2YWxpZCBYQ0NERiBYTUwgZmlsZS4nXHJcbiAgICAgIH0sXHJcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGZXRjaCBkZXRhaWxlZCByZXF1aXJlbWVudCBwYWdlIGZyb20gc3RpZ3ZpZXdlci5jb21cclxuICogUmV0dXJucyBjaGVjayBhbmQgZml4IHRleHQgZm9yIGEgc3BlY2lmaWMgdnVsbmVyYWJpbGl0eVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXF1aXJlbWVudERldGFpbHMoc3RpZ0lkOiBzdHJpbmcsIHZ1bG5JZDogc3RyaW5nKTogUHJvbWlzZTx7Y2hlY2tUZXh0OiBzdHJpbmcsIGZpeFRleHQ6IHN0cmluZ30+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgYWdlbnQgPSBuZXcgaHR0cHMuQWdlbnQoeyByZWplY3RVbmF1dGhvcml6ZWQ6IGZhbHNlIH0pO1xyXG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vc3RpZ3ZpZXdlci5jb20vc3RpZy8ke3N0aWdJZH0vcmVxdWlyZW1lbnQvJHt2dWxuSWR9YDtcclxuICAgIFxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdVc2VyLUFnZW50JzogJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNicsXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgYWdlbnQsXHJcbiAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCgxMDAwMCksXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGh0bWwgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgY2hlY2sgdGV4dFxyXG4gICAgY29uc3QgY2hlY2tNYXRjaCA9IGh0bWwubWF0Y2goLzxkaXZbXj5dKig/OmlkfGNsYXNzKT1cIlteXCJdKmNoZWNrW15cIl0qXCJbXj5dKj4oW1xcc1xcU10qPyk8XFwvZGl2Pi9pKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgaHRtbC5tYXRjaCgvQ2hlY2sgVGV4dFs6XFxzXSo8W14+XSo+KFtcXHNcXFNdKj8pPFxcLyg/OmRpdnxwcmV8cCk+L2kpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICBodG1sLm1hdGNoKC88cHJlW14+XSo+KFtcXHNcXFNdKj8pPFxcL3ByZT4vaSk7XHJcbiAgICBcclxuICAgIGNvbnN0IGNoZWNrVGV4dCA9IGNoZWNrTWF0Y2ggPyBcclxuICAgICAgY2hlY2tNYXRjaFsxXVxyXG4gICAgICAgIC5yZXBsYWNlKC88W14+XSs+L2csICcnKVxyXG4gICAgICAgIC5yZXBsYWNlKC8mbHQ7L2csICc8JylcclxuICAgICAgICAucmVwbGFjZSgvJmd0Oy9nLCAnPicpXHJcbiAgICAgICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJylcclxuICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKVxyXG4gICAgICAgIC50cmltKCkgOiBcclxuICAgICAgJ1JldmlldyB0aGUgc3lzdGVtIGNvbmZpZ3VyYXRpb24gdG8gdmVyaWZ5IGNvbXBsaWFuY2Ugd2l0aCB0aGUgc2VjdXJpdHkgcmVxdWlyZW1lbnQuJztcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBmaXggdGV4dCAgXHJcbiAgICBjb25zdCBmaXhNYXRjaCA9IGh0bWwubWF0Y2goLzxkaXZbXj5dKig/OmlkfGNsYXNzKT1cIlteXCJdKmZpeFteXCJdKlwiW14+XSo+KFtcXHNcXFNdKj8pPFxcL2Rpdj4vaSkgfHxcclxuICAgICAgICAgICAgICAgICAgICBodG1sLm1hdGNoKC9GaXggVGV4dFs6XFxzXSo8W14+XSo+KFtcXHNcXFNdKj8pPFxcLyg/OmRpdnxwcmV8cCk+L2kpO1xyXG4gICAgXHJcbiAgICBjb25zdCBmaXhUZXh0ID0gZml4TWF0Y2ggPyBcclxuICAgICAgZml4TWF0Y2hbMV1cclxuICAgICAgICAucmVwbGFjZSgvPFtePl0rPi9nLCAnJylcclxuICAgICAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpXHJcbiAgICAgICAgLnJlcGxhY2UoLyZndDsvZywgJz4nKVxyXG4gICAgICAgIC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpXHJcbiAgICAgICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJylcclxuICAgICAgICAudHJpbSgpIDogXHJcbiAgICAgICdDb25maWd1cmUgdGhlIHN5c3RlbSB0byBtZWV0IHRoZSBzZWN1cml0eSByZXF1aXJlbWVudCBhcyBzcGVjaWZpZWQgaW4gdGhlIFNUSUcgZG9jdW1lbnRhdGlvbi4nO1xyXG4gICAgXHJcbiAgICByZXR1cm4geyBjaGVja1RleHQsIGZpeFRleHQgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgLy8gUmV0dXJuIGRlZmF1bHRzIGlmIGZldGNoIGZhaWxzXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjaGVja1RleHQ6ICdSZXZpZXcgdGhlIHN5c3RlbSBjb25maWd1cmF0aW9uIHRvIHZlcmlmeSBjb21wbGlhbmNlIHdpdGggdGhlIHNlY3VyaXR5IHJlcXVpcmVtZW50LiBEZXRhaWxlZCBjaGVjayBwcm9jZWR1cmUgYXZhaWxhYmxlIGluIHRoZSBmdWxsIFNUSUcgZG9jdW1lbnRhdGlvbi4nLFxyXG4gICAgICBmaXhUZXh0OiAnQ29uZmlndXJlIHRoZSBzeXN0ZW0gdG8gbWVldCB0aGUgc2VjdXJpdHkgcmVxdWlyZW1lbnQuIERldGFpbGVkIGZpeCBwcm9jZWR1cmUgYXZhaWxhYmxlIGluIHRoZSBmdWxsIFNUSUcgZG9jdW1lbnRhdGlvbi4nXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHN0aWcgdmlld2VyLmNvbSBKU09OIEFQSSByZXNwb25zZVxyXG4gKiBKU09OIGZvcm1hdCBoYXMgY29tcGxldGUgZGF0YSBpbmNsdWRpbmcgc2V2ZXJpdHkgZm9yIGVhY2ggcmVxdWlyZW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlU3RpZ1ZpZXdlckpzb24oanNvbkRhdGE6IGFueSwgc3RpZ0lkOiBzdHJpbmcpOiBPbWl0PFN0aWdJbXBvcnRSZXN1bHQsICdzdWNjZXNzJyB8ICdzb3VyY2UnIHwgJ21lc3NhZ2UnPiB7XHJcbiAgY29uc3QgcmVxdWlyZW1lbnRzOiBTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG5cclxuICB0cnkge1xyXG4gICAgY29uc3Qgc3RpZyA9IGpzb25EYXRhLnN0aWcgfHwganNvbkRhdGE7XHJcbiAgICBjb25zdCBzdGlnTmFtZSA9IHN0aWcudGl0bGUgfHwgc3RpZ0lkO1xyXG4gICAgY29uc3QgdmVyc2lvbiA9IHN0aWcudmVyc2lvbiB8fCAnVW5rbm93bic7XHJcbiAgICBjb25zdCByZWxlYXNlRGF0ZSA9IHN0aWcuZGF0ZSB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCfk4sgUGFyc2luZyBKU09OOiAke3N0aWdOYW1lfSwgVmVyc2lvbjogJHt2ZXJzaW9ufSwgUmVsZWFzZTogJHtyZWxlYXNlRGF0ZX1gKTtcclxuXHJcbiAgICBjb25zdCBmaW5kaW5ncyA9IHN0aWcuZmluZGluZ3MgfHwge307XHJcbiAgICBjb25zdCB2dWxuSWRzID0gT2JqZWN0LmtleXMoZmluZGluZ3MpO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBGb3VuZCAke3Z1bG5JZHMubGVuZ3RofSByZXF1aXJlbWVudHMgaW4gSlNPTmApO1xyXG5cclxuICAgIHZ1bG5JZHMuZm9yRWFjaCgodnVsbklkKSA9PiB7XHJcbiAgICAgIGNvbnN0IGZpbmRpbmcgPSBmaW5kaW5nc1t2dWxuSWRdO1xyXG4gICAgICBpZiAoIWZpbmRpbmcpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIEV4dHJhY3Qgc2V2ZXJpdHkgZnJvbSBmaW5kaW5nXHJcbiAgICAgIC8vIEpTT04gbWlnaHQgaGF2ZSBzZXZlcml0eSBhcyBcImhpZ2hcIiwgXCJtZWRpdW1cIiwgXCJsb3dcIiBvciBcIkNBVCBJXCIsIFwiQ0FUIElJXCIsIFwiQ0FUIElJSVwiXHJcbiAgICAgIGxldCBzZXZlcml0eTogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JyA9ICdtZWRpdW0nO1xyXG4gICAgICBjb25zdCBzZXZUZXh0ID0gKGZpbmRpbmcuc2V2ZXJpdHkgfHwgZmluZGluZy5jYXQgfHwgJ21lZGl1bScpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChzZXZUZXh0LmluY2x1ZGVzKCdoaWdoJykgfHwgc2V2VGV4dC5pbmNsdWRlcygnY2F0IGknKSB8fCBzZXZUZXh0ID09PSAnaScgfHwgc2V2VGV4dCA9PT0gJzEnKSB7XHJcbiAgICAgICAgc2V2ZXJpdHkgPSAnaGlnaCc7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2V2VGV4dC5pbmNsdWRlcygnbG93JykgfHwgc2V2VGV4dC5pbmNsdWRlcygnY2F0IGlpaScpIHx8IHNldlRleHQgPT09ICdpaWknIHx8IHNldlRleHQgPT09ICczJykge1xyXG4gICAgICAgIHNldmVyaXR5ID0gJ2xvdyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2V2ZXJpdHkgPSAnbWVkaXVtJztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVxdWlyZW1lbnRzLnB1c2goe1xyXG4gICAgICAgIHZ1bG5JZCxcclxuICAgICAgICBydWxlSWQ6IGZpbmRpbmcucnVsZUlkIHx8IGZpbmRpbmcucnVsZV9pZCB8fCBmaW5kaW5nLnJ1bGVpZCB8fCBgJHt2dWxuSWR9LXJ1bGVgLFxyXG4gICAgICAgIHNldmVyaXR5LFxyXG4gICAgICAgIHRpdGxlOiBmaW5kaW5nLnRpdGxlIHx8IGZpbmRpbmcucnVsZVRpdGxlIHx8IGZpbmRpbmcucnVsZXRpdGxlIHx8IGBSZXF1aXJlbWVudCAke3Z1bG5JZH1gLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBmaW5kaW5nLmRpc2N1c3Npb24gfHwgZmluZGluZy5kZXNjcmlwdGlvbiB8fCBmaW5kaW5nLnRpdGxlIHx8ICcnLFxyXG4gICAgICAgIGNoZWNrVGV4dDogZmluZGluZy5jaGVja3RleHQgfHwgZmluZGluZy5jaGVja1RleHQgfHwgZmluZGluZy5jaGVja190ZXh0IHx8IGZpbmRpbmcuY2hlY2sgfHwgJ1JldmlldyBzeXN0ZW0gY29uZmlndXJhdGlvbiBwZXIgU1RJRyBndWlkYW5jZS4nLFxyXG4gICAgICAgIGZpeFRleHQ6IGZpbmRpbmcuZml4dGV4dCB8fCBmaW5kaW5nLmZpeFRleHQgfHwgZmluZGluZy5maXhfdGV4dCB8fCBmaW5kaW5nLmZpeCB8fCAnQ29uZmlndXJlIHN5c3RlbSBwZXIgU1RJRyBndWlkYW5jZS4nLFxyXG4gICAgICAgIGNjaTogZmluZGluZy5jY2kgfHwgZmluZGluZy5jY2lzIHx8IFsnQ0NJLTAwMDM2NiddLFxyXG4gICAgICAgIG5pc3RDb250cm9sczogZmluZGluZy5uaXN0Q29udHJvbHMgfHwgZmluZGluZy5uaXN0IHx8IFtdXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgcGFyc2VkICR7cmVxdWlyZW1lbnRzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZyb20gSlNPTmApO1xyXG4gICAgXHJcbiAgICAvLyBMb2cgc2V2ZXJpdHkgZGlzdHJpYnV0aW9uXHJcbiAgICBjb25zdCBzZXZlcml0eURpc3Q6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuICAgIHJlcXVpcmVtZW50cy5mb3JFYWNoKHJlcSA9PiB7XHJcbiAgICAgIHNldmVyaXR5RGlzdFtyZXEuc2V2ZXJpdHldID0gKHNldmVyaXR5RGlzdFtyZXEuc2V2ZXJpdHldIHx8IDApICsgMTtcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coYPCfk4ogSlNPTiBTZXZlcml0eSBEaXN0cmlidXRpb246YCwgc2V2ZXJpdHlEaXN0KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGlnSWQsXHJcbiAgICAgIHN0aWdOYW1lLFxyXG4gICAgICB2ZXJzaW9uLFxyXG4gICAgICByZWxlYXNlRGF0ZSxcclxuICAgICAgcmVxdWlyZW1lbnRzLFxyXG4gICAgICB0b3RhbFJlcXVpcmVtZW50czogcmVxdWlyZW1lbnRzLmxlbmd0aFxyXG4gICAgfTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBzdGlndmlld2VyLmNvbSBKU09OOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0aWd2aWV3ZXIuY29tIEpTT046ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBzdGlndmlld2VyLmNvbSBIVE1MIHRvIGV4dHJhY3QgU1RJRyByZXF1aXJlbWVudHNcclxuICogRmV0Y2hlcyBmdWxsIHJlcXVpcmVtZW50IGRldGFpbHMgaW5jbHVkaW5nIGNoZWNrIGFuZCBmaXggdGV4dFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcGFyc2VTdGlnVmlld2VySHRtbChodG1sOiBzdHJpbmcsIHN0aWdJZDogc3RyaW5nKTogUHJvbWlzZTxPbWl0PFN0aWdJbXBvcnRSZXN1bHQsICdzdWNjZXNzJyB8ICdzb3VyY2UnIHwgJ21lc3NhZ2UnPj4ge1xyXG4gIGNvbnN0IHJlcXVpcmVtZW50czogU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIEV4dHJhY3QgU1RJRyBtZXRhZGF0YSBmcm9tIHBhZ2UgdGl0bGUgYW5kIGhlYWRlcnNcclxuICAgIGNvbnN0IHRpdGxlTWF0Y2ggPSBodG1sLm1hdGNoKC88dGl0bGU+KFtePF0rKTxcXC90aXRsZT4vaSk7XHJcbiAgICBjb25zdCBzdGlnTmFtZSA9IHRpdGxlTWF0Y2ggPyB0aXRsZU1hdGNoWzFdLnJlcGxhY2UoJyB8IFNUSUdWaWV3ZXInLCAnJykudHJpbSgpIDogc3RpZ0lkO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgdmVyc2lvbiBmcm9tIHBhZ2VcclxuICAgIGNvbnN0IHZlcnNpb25NYXRjaCA9IGh0bWwubWF0Y2goL1ZlcnNpb25bOlxcc10rKFtWdlJyXFxkLl0rKS9pKSB8fCBodG1sLm1hdGNoKC9jbGFzcz1cIlteXCJdKnZlcnNpb25bXlwiXSpcIltePl0qPihbXjxdKyk8L2kpO1xyXG4gICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25NYXRjaCA/IHZlcnNpb25NYXRjaFsxXS50cmltKCkgOiAnVW5rbm93bic7XHJcblxyXG4gICAgLy8gRXh0cmFjdCByZWxlYXNlIGRhdGVcclxuICAgIGNvbnN0IGRhdGVNYXRjaCA9IGh0bWwubWF0Y2goL1JlbGVhc2VbOlxcc10rKFxcZHsxLDJ9XFxzK1xcdytcXHMrXFxkezR9KS9pKSB8fCBcclxuICAgICAgICAgICAgICAgICAgICAgaHRtbC5tYXRjaCgvRGF0ZVs6XFxzXSsoXFxkezR9LVxcZHsyfS1cXGR7Mn0pL2kpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIGh0bWwubWF0Y2goLyhcXGR7NH0tXFxkezJ9LVxcZHsyfSkvKTtcclxuICAgIGNvbnN0IHJlbGVhc2VEYXRlID0gZGF0ZU1hdGNoID8gZGF0ZU1hdGNoWzFdIDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XHJcblxyXG4gICAgY29uc29sZS5sb2coYPCfk4sgUGFyc2luZyBTVElHOiAke3N0aWdOYW1lfSwgVmVyc2lvbjogJHt2ZXJzaW9ufSwgUmVsZWFzZTogJHtyZWxlYXNlRGF0ZX1gKTtcclxuXHJcbiAgICAvLyBNZXRob2QgMTogRXh0cmFjdCBjb21wbGV0ZSByZXF1aXJlbWVudCBlbnRyaWVzIHdpdGggYWxsIGRldGFpbHNcclxuICAgIC8vIHN0aWd2aWV3ZXIuY29tIGhhcyBsaW5rcyBsaWtlOiBocmVmPVwiL3N0aWcve3N0aWdJZH0vcmVxdWlyZW1lbnQvVi0jIyMjI1wiXHJcbiAgICAvLyBQYXR0ZXJuIHRvIG1hdGNoIGVudGlyZSByZXF1aXJlbWVudCBzZWN0aW9ucyB3aXRoIHNldmVyaXR5IGluZm9cclxuICAgIGNvbnN0IHJlcVNlY3Rpb25QYXR0ZXJuID0gLyg/OkNBVFxccysoSXsxLDN9KXxzZXZlcml0eVtePl0qPyhoaWdofG1lZGl1bXxsb3cpKVteVl0qKFYtXFxkKylbXjxdKjxhW14+XSpocmVmPVwiW15cIl0qXFwvcmVxdWlyZW1lbnRcXC9cXDNcIltePl0qPihbXjxdKyk8L2dpO1xyXG4gICAgbGV0IG1hdGNoO1xyXG4gICAgY29uc3QgZGV0YWlsZWRSZXFzOiBBcnJheTx7dnVsbklkOiBzdHJpbmcsIHNldmVyaXR5OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9PiA9IFtdO1xyXG4gICAgXHJcbiAgICB3aGlsZSAoKG1hdGNoID0gcmVxU2VjdGlvblBhdHRlcm4uZXhlYyhodG1sKSkgIT09IG51bGwpIHtcclxuICAgICAgY29uc3Qgc2V2ZXJpdHkgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXTsgLy8gQ0FUIEkvSUkvSUlJIG9yIGhpZ2gvbWVkaXVtL2xvd1xyXG4gICAgICBjb25zdCB2dWxuSWQgPSBtYXRjaFszXTtcclxuICAgICAgY29uc3QgdGl0bGUgPSBtYXRjaFs0XS50cmltKCk7XHJcbiAgICAgIGRldGFpbGVkUmVxcy5wdXNoKHsgdnVsbklkLCBzZXZlcml0eSwgdGl0bGUgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGDwn5SNIE1ldGhvZCAxOiBGb3VuZCAke2RldGFpbGVkUmVxcy5sZW5ndGh9IHJlcXVpcmVtZW50cyB3aXRoIHNldmVyaXR5IGluZm9gKTtcclxuXHJcbiAgICAvLyBNZXRob2QgMjogRXh0cmFjdCBmcm9tIHRhYmxlIHJvd3MgaWYgYXZhaWxhYmxlXHJcbiAgICBjb25zdCB0YWJsZVJvd3M6IEFycmF5PHt2dWxuSWQ6IHN0cmluZywgc2V2ZXJpdHk6IHN0cmluZywgdGl0bGU6IHN0cmluZ30+ID0gW107XHJcbiAgICBjb25zdCByb3dQYXR0ZXJuID0gLzx0cltePl0qPihbXFxzXFxTXSo/KTxcXC90cj4vZ2k7XHJcbiAgICBsZXQgcm93TWF0Y2g7XHJcbiAgICBcclxuICAgIHdoaWxlICgocm93TWF0Y2ggPSByb3dQYXR0ZXJuLmV4ZWMoaHRtbCkpICE9PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IHJvd0h0bWwgPSByb3dNYXRjaFsxXTtcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgcm93IGhhcyBhIHZ1bG4gSURcclxuICAgICAgY29uc3QgdnVsbk1hdGNoID0gcm93SHRtbC5tYXRjaCgvPihWLVxcZCspPC8pO1xyXG4gICAgICBpZiAoIXZ1bG5NYXRjaCkgY29udGludWU7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB2dWxuSWQgPSB2dWxuTWF0Y2hbMV07XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IHNldmVyaXR5IGZyb20gdGhpcyByb3dcclxuICAgICAgY29uc3QgY2F0TWF0Y2ggPSByb3dIdG1sLm1hdGNoKC9DQVRcXHMrKEl7MSwzfSkvaSk7XHJcbiAgICAgIGNvbnN0IHNldk1hdGNoID0gcm93SHRtbC5tYXRjaCgvPihoaWdofG1lZGl1bXxsb3cpPC9pKTtcclxuICAgICAgY29uc3Qgc2V2ZXJpdHkgPSBjYXRNYXRjaCA/IGNhdE1hdGNoWzFdIDogKHNldk1hdGNoID8gc2V2TWF0Y2hbMV0gOiAnSUknKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgdGl0bGVcclxuICAgICAgY29uc3QgdGl0bGVNYXRjaCA9IHJvd0h0bWwubWF0Y2goLzxhW14+XSpocmVmPVwiW15cIl0qXFwvcmVxdWlyZW1lbnRcXC9bXlwiXSpcIltePl0qPihbXjxdKyk8L2kpO1xyXG4gICAgICBjb25zdCB0aXRsZSA9IHRpdGxlTWF0Y2ggPyB0aXRsZU1hdGNoWzFdLnRyaW0oKSA6IGBSZXF1aXJlbWVudCAke3Z1bG5JZH1gO1xyXG4gICAgICBcclxuICAgICAgdGFibGVSb3dzLnB1c2goeyB2dWxuSWQsIHNldmVyaXR5LCB0aXRsZSB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCflI0gTWV0aG9kIDI6IEZvdW5kICR7dGFibGVSb3dzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZyb20gdGFibGUgcm93c2ApO1xyXG5cclxuICAgIC8vIE1ldGhvZCAzOiBGYWxsYmFjayAtIGV4dHJhY3QgYWxsIFYtIyMjIyB3aXRoIGRlZmF1bHQgZGF0YVxyXG4gICAgY29uc3QgdnVsbklkUGF0dGVybiA9IC9WLVxcZCsvZztcclxuICAgIGNvbnN0IGFsbFZ1bG5JZHMgPSBbLi4ubmV3IFNldChodG1sLm1hdGNoKHZ1bG5JZFBhdHRlcm4pIHx8IFtdKV07XHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBNZXRob2QgMzogRm91bmQgJHthbGxWdWxuSWRzLmxlbmd0aH0gdG90YWwgVi0jIyMjIHBhdHRlcm5zYCk7XHJcblxyXG4gICAgLy8gVXNlIHRoZSBtZXRob2QgdGhhdCBmb3VuZCB0aGUgbW9zdCByZXF1aXJlbWVudHNcclxuICAgIGxldCByZXFEYXRhOiBBcnJheTx7dnVsbklkOiBzdHJpbmcsIHNldmVyaXR5OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9PiA9IFtdO1xyXG4gICAgXHJcbiAgICBpZiAoZGV0YWlsZWRSZXFzLmxlbmd0aCA+PSB0YWJsZVJvd3MubGVuZ3RoICYmIGRldGFpbGVkUmVxcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHJlcURhdGEgPSBkZXRhaWxlZFJlcXM7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinJMgVXNpbmcgTWV0aG9kIDE6ICR7ZGV0YWlsZWRSZXFzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIHdpdGggc2V2ZXJpdHlgKTtcclxuICAgIH0gZWxzZSBpZiAodGFibGVSb3dzLmxlbmd0aCA+IDApIHtcclxuICAgICAgcmVxRGF0YSA9IHRhYmxlUm93cztcclxuICAgICAgY29uc29sZS5sb2coYOKckyBVc2luZyBNZXRob2QgMjogJHt0YWJsZVJvd3MubGVuZ3RofSByZXF1aXJlbWVudHMgZnJvbSB0YWJsZXNgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEZhbGxiYWNrOiBjcmVhdGUgYmFzaWMgZW50cmllc1xyXG4gICAgICByZXFEYXRhID0gYWxsVnVsbklkcy5tYXAodnVsbklkID0+ICh7XHJcbiAgICAgICAgdnVsbklkLFxyXG4gICAgICAgIHNldmVyaXR5OiAnSUknLCAvLyBkZWZhdWx0XHJcbiAgICAgICAgdGl0bGU6IGAke3N0aWdOYW1lfSAtICR7dnVsbklkfWBcclxuICAgICAgfSkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyTIFVzaW5nIE1ldGhvZCAzOiAke2FsbFZ1bG5JZHMubGVuZ3RofSBiYXNpYyByZXF1aXJlbWVudHNgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+TnSBQcm9jZXNzaW5nICR7cmVxRGF0YS5sZW5ndGh9IHJlcXVpcmVtZW50cy4uLmApO1xyXG5cclxuICAgIGxldCByZXF1aXJlbWVudENvdW50ID0gMDtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCByZXEgb2YgcmVxRGF0YSkge1xyXG4gICAgICBjb25zdCB7IHZ1bG5JZCwgc2V2ZXJpdHk6IHJhd1NldmVyaXR5LCB0aXRsZSB9ID0gcmVxO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBSdWxlIElEIGlmIGF2YWlsYWJsZVxyXG4gICAgICBjb25zdCBydWxlUGF0dGVybiA9IG5ldyBSZWdFeHAoYCR7dnVsbklkfVteU10qPyhTVi1cXFxcZCtyXFxcXGQrX3J1bGUpYCwgJ2knKTtcclxuICAgICAgY29uc3QgcnVsZU1hdGNoID0gaHRtbC5tYXRjaChydWxlUGF0dGVybik7XHJcbiAgICAgIGNvbnN0IHJ1bGVJZCA9IHJ1bGVNYXRjaCA/IHJ1bGVNYXRjaFsxXSA6IGAke3Z1bG5JZH0tcnVsZWA7XHJcbiAgICAgIFxyXG4gICAgICAvLyBOb3JtYWxpemUgc2V2ZXJpdHlcclxuICAgICAgbGV0IHNldmVyaXR5OiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnID0gJ21lZGl1bSc7XHJcbiAgICAgIGNvbnN0IHNldlRleHQgPSByYXdTZXZlcml0eS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBpZiAoc2V2VGV4dC5pbmNsdWRlcygnaScpICYmICFzZXZUZXh0LmluY2x1ZGVzKCdpaScpIHx8IHNldlRleHQgPT09ICdoaWdoJyB8fCBzZXZUZXh0ID09PSAnMScpIHtcclxuICAgICAgICBzZXZlcml0eSA9ICdoaWdoJztcclxuICAgICAgfSBlbHNlIGlmIChzZXZUZXh0LmluY2x1ZGVzKCdpaWknKSB8fCBzZXZUZXh0ID09PSAnbG93JyB8fCBzZXZUZXh0ID09PSAnMycpIHtcclxuICAgICAgICBzZXZlcml0eSA9ICdsb3cnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldmVyaXR5ID0gJ21lZGl1bSc7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIERlc2NyaXB0aW9uIGRlZmF1bHRzIHRvIHRpdGxlXHJcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGl0bGU7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IENDSSByZWZlcmVuY2VzIC0gc2VhcmNoIGZvciB0aGlzIHZ1bG5JZCBpbiBIVE1MXHJcbiAgICAgIGNvbnN0IHZ1bG5Db250ZXh0ID0gaHRtbC5zdWJzdHJpbmcoXHJcbiAgICAgICAgTWF0aC5tYXgoMCwgaHRtbC5pbmRleE9mKHZ1bG5JZCkgLSAzMDApLFxyXG4gICAgICAgIE1hdGgubWluKGh0bWwubGVuZ3RoLCBodG1sLmluZGV4T2YodnVsbklkKSArIDMwMClcclxuICAgICAgKTtcclxuICAgICAgY29uc3QgY2NpTWF0Y2hlcyA9IHZ1bG5Db250ZXh0Lm1hdGNoKC9DQ0ktXFxkKy9nKTtcclxuICAgICAgY29uc3QgY2NpID0gY2NpTWF0Y2hlcyAmJiBjY2lNYXRjaGVzLmxlbmd0aCA+IDAgPyBbLi4ubmV3IFNldChjY2lNYXRjaGVzKV0gOiBbJ0NDSS0wMDAzNjYnXTtcclxuICAgICAgXHJcbiAgICAgIC8vIERlZmF1bHQgY2hlY2sgYW5kIGZpeCB0ZXh0IHdpdGggbm90ZSBhYm91dCBmdWxsIGRvY3VtZW50YXRpb25cclxuICAgICAgY29uc3QgY2hlY2tUZXh0ID0gYFJldmlldyB0aGUgc3lzdGVtIGNvbmZpZ3VyYXRpb24gdG8gdmVyaWZ5IGNvbXBsaWFuY2Ugd2l0aCAke3Z1bG5JZH0uIFJlZmVyIHRvIHRoZSBmdWxsIFNUSUcgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlsZWQgY2hlY2sgcHJvY2VkdXJlcy5gO1xyXG4gICAgICBjb25zdCBmaXhUZXh0ID0gYENvbmZpZ3VyZSB0aGUgc3lzdGVtIHRvIG1lZXQgdGhlIHJlcXVpcmVtZW50cyBzcGVjaWZpZWQgaW4gJHt2dWxuSWR9LiBSZWZlciB0byB0aGUgZnVsbCBTVElHIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbGVkIGZpeCBwcm9jZWR1cmVzLmA7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IE5JU1QgY29udHJvbHMgZnJvbSBjb250ZXh0XHJcbiAgICAgIGNvbnN0IG5pc3RNYXRjaGVzID0gdnVsbkNvbnRleHQubWF0Y2goLyhbQS1aXXsyfS1cXGQrKD86XFxzKlxcKFthLXowLTldK1xcKSk/KS9nKTtcclxuICAgICAgY29uc3QgbmlzdENvbnRyb2xzID0gbmlzdE1hdGNoZXMgPyBbLi4ubmV3IFNldChuaXN0TWF0Y2hlcyldIDogW107XHJcbiAgICAgIFxyXG4gICAgICByZXF1aXJlbWVudHMucHVzaCh7XHJcbiAgICAgICAgdnVsbklkLFxyXG4gICAgICAgIHJ1bGVJZCxcclxuICAgICAgICBzZXZlcml0eSxcclxuICAgICAgICB0aXRsZSxcclxuICAgICAgICBkZXNjcmlwdGlvbixcclxuICAgICAgICBjaGVja1RleHQsXHJcbiAgICAgICAgZml4VGV4dCxcclxuICAgICAgICBjY2ksXHJcbiAgICAgICAgbmlzdENvbnRyb2xzXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgcmVxdWlyZW1lbnRDb3VudCsrO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IHBhcnNlZCAke3JlcXVpcmVtZW50Q291bnR9IHJlcXVpcmVtZW50cyBmcm9tIEhUTUxgKTtcclxuICAgIFxyXG4gICAgLy8gTG9nIHNldmVyaXR5IGRpc3RyaWJ1dGlvblxyXG4gICAgY29uc3Qgc2V2ZXJpdHlEaXN0OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XHJcbiAgICByZXF1aXJlbWVudHMuZm9yRWFjaChyZXEgPT4ge1xyXG4gICAgICBzZXZlcml0eURpc3RbcmVxLnNldmVyaXR5XSA9IChzZXZlcml0eURpc3RbcmVxLnNldmVyaXR5XSB8fCAwKSArIDE7XHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OKIEFQSSBTZXZlcml0eSBEaXN0cmlidXRpb246YCwgc2V2ZXJpdHlEaXN0KTtcclxuXHJcbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnkgcmVxdWlyZW1lbnRzIGluIHRhYmxlIGZvcm1hdCwgdHJ5IGFsdGVybmF0aXZlIHBhcnNpbmdcclxuICAgIGlmIChyZXF1aXJlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIHJlcXVpcmVtZW50cyBmb3VuZCBpbiB0YWJsZSBmb3JtYXQsIHRyeWluZyBhbHRlcm5hdGl2ZSBwYXJzaW5nLi4uJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBUcnkgdG8gZmluZCBhbGwgVi0jIyMjIHBhdHRlcm5zIGFuZCBjcmVhdGUgYmFzaWMgcmVxdWlyZW1lbnRzXHJcbiAgICAgIGNvbnN0IHZ1bG5JZFBhdHRlcm4gPSAvVi1cXGQrL2c7XHJcbiAgICAgIGNvbnN0IHZ1bG5JZHMgPSBbLi4ubmV3IFNldChodG1sLm1hdGNoKHZ1bG5JZFBhdHRlcm4pIHx8IFtdKV07XHJcbiAgICAgIFxyXG4gICAgICB2dWxuSWRzLmZvckVhY2goKHZ1bG5JZCwgaW5kZXgpID0+IHtcclxuICAgICAgICByZXF1aXJlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICB2dWxuSWQsXHJcbiAgICAgICAgICBydWxlSWQ6IGAke3Z1bG5JZH0tcnVsZWAsXHJcbiAgICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXHJcbiAgICAgICAgICB0aXRsZTogYCR7c3RpZ05hbWV9IC0gJHt2dWxuSWR9YCxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgU2VjdXJpdHkgcmVxdWlyZW1lbnQgJHt2dWxuSWR9IGZyb20gJHtzdGlnTmFtZX1gLFxyXG4gICAgICAgICAgY2hlY2tUZXh0OiAnUmV2aWV3IHRoZSBzeXN0ZW0gY29uZmlndXJhdGlvbiB0byB2ZXJpZnkgY29tcGxpYW5jZS4gRGV0YWlsZWQgY2hlY2sgcHJvY2VkdXJlIGF2YWlsYWJsZSBpbiB0aGUgZnVsbCBTVElHIGRvY3VtZW50YXRpb24uJyxcclxuICAgICAgICAgIGZpeFRleHQ6ICdDb25maWd1cmUgdGhlIHN5c3RlbSB0byBtZWV0IHRoZSBzZWN1cml0eSByZXF1aXJlbWVudC4gRGV0YWlsZWQgZml4IHByb2NlZHVyZSBhdmFpbGFibGUgaW4gdGhlIGZ1bGwgU1RJRyBkb2N1bWVudGF0aW9uLicsXHJcbiAgICAgICAgICBjY2k6IFsnQ0NJLTAwMDM2NiddLFxyXG4gICAgICAgICAgbmlzdENvbnRyb2xzOiBbXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIENyZWF0ZWQgJHtyZXF1aXJlbWVudHMubGVuZ3RofSBiYXNpYyByZXF1aXJlbWVudHMgZnJvbSBWdWxuIElEc2ApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0aWdJZCxcclxuICAgICAgc3RpZ05hbWUsXHJcbiAgICAgIHZlcnNpb24sXHJcbiAgICAgIHJlbGVhc2VEYXRlLFxyXG4gICAgICByZXF1aXJlbWVudHMsXHJcbiAgICAgIHRvdGFsUmVxdWlyZW1lbnRzOiByZXF1aXJlbWVudHMubGVuZ3RoXHJcbiAgICB9O1xyXG5cclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHN0aWd2aWV3ZXIuY29tIEhUTUw6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3RpZ3ZpZXdlci5jb20gcGFnZTogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIFhDQ0RGIFhNTCBmaWxlIHRvIGV4dHJhY3QgU1RJRyByZXF1aXJlbWVudHNcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlWGNjZGZYbWwoeG1sQ29udGVudDogc3RyaW5nLCBmaWxlTmFtZTogc3RyaW5nKTogT21pdDxTdGlnSW1wb3J0UmVzdWx0LCAnc3VjY2VzcycgfCAnc291cmNlJyB8ICdtZXNzYWdlJz4ge1xyXG4gIGNvbnN0IHJlcXVpcmVtZW50czogU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIEV4dHJhY3QgU1RJRyBJRCBmcm9tIGZpbGVuYW1lXHJcbiAgICBjb25zdCBzdGlnSWQgPSBmaWxlTmFtZS5yZXBsYWNlKC9cXC54bWx8XFwueGNjZGYvZ2ksICcnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJ18nKTtcclxuXHJcbiAgICAvLyBQYXJzZSBYTUwgdXNpbmcgcmVnZXggKHNpbXBsaWZpZWQgLSBpbiBwcm9kdWN0aW9uIHVzZSBhIHByb3BlciBYTUwgcGFyc2VyKVxyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IEJlbmNobWFyayB0aXRsZVxyXG4gICAgY29uc3QgdGl0bGVNYXRjaCA9IHhtbENvbnRlbnQubWF0Y2goLzx0aXRsZVtePl0qPihbXjxdKyk8XFwvdGl0bGU+L2kpO1xyXG4gICAgY29uc3Qgc3RpZ05hbWUgPSB0aXRsZU1hdGNoID8gdGl0bGVNYXRjaFsxXS50cmltKCkgOiBzdGlnSWQ7XHJcblxyXG4gICAgLy8gRXh0cmFjdCB2ZXJzaW9uXHJcbiAgICBjb25zdCB2ZXJzaW9uTWF0Y2ggPSB4bWxDb250ZW50Lm1hdGNoKC88dmVyc2lvbltePl0qPihbXjxdKyk8XFwvdmVyc2lvbj4vaSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sQ29udGVudC5tYXRjaCgvVmVyc2lvbls6XFxzXSsoW1Z2UnJcXGQuXSspL2kpO1xyXG4gICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25NYXRjaCA/IHZlcnNpb25NYXRjaFsxXSA6ICdVbmtub3duJztcclxuXHJcbiAgICAvLyBFeHRyYWN0IHJlbGVhc2UgZGF0ZVxyXG4gICAgY29uc3QgZGF0ZU1hdGNoID0geG1sQ29udGVudC5tYXRjaCgvcmVsZWFzZS1kYXRlW14+XSo+KFtePF0rKTwvaSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgeG1sQ29udGVudC5tYXRjaCgvKFxcZHsxLDJ9XFxzK1xcdytcXHMrXFxkezR9KS8pO1xyXG4gICAgY29uc3QgcmVsZWFzZURhdGUgPSBkYXRlTWF0Y2ggPyBkYXRlTWF0Y2hbMV0gOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcclxuXHJcbiAgICAvLyBFeHRyYWN0IGFsbCBHcm91cCBlbGVtZW50cyAocmVxdWlyZW1lbnRzKVxyXG4gICAgY29uc3QgZ3JvdXBQYXR0ZXJuID0gLzxHcm91cFtePl0qaWQ9XCIoW15cIl0rKVwiW14+XSo+KFtcXHNcXFNdKj8pPFxcL0dyb3VwPi9naTtcclxuICAgIGxldCBncm91cE1hdGNoO1xyXG5cclxuICAgIHdoaWxlICgoZ3JvdXBNYXRjaCA9IGdyb3VwUGF0dGVybi5leGVjKHhtbENvbnRlbnQpKSAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBncm91cElkID0gZ3JvdXBNYXRjaFsxXTtcclxuICAgICAgY29uc3QgZ3JvdXBDb250ZW50ID0gZ3JvdXBNYXRjaFsyXTtcclxuXHJcbiAgICAgIC8vIEV4dHJhY3QgUnVsZSBmcm9tIEdyb3VwXHJcbiAgICAgIGNvbnN0IHJ1bGVNYXRjaCA9IGdyb3VwQ29udGVudC5tYXRjaCgvPFJ1bGVbXj5dKmlkPVwiKFteXCJdKylcIltePl0qc2V2ZXJpdHk9XCIoW15cIl0rKVwiW14+XSo+KFtcXHNcXFNdKj8pPFxcL1J1bGU+L2kpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHJ1bGVNYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHJ1bGVJZCA9IHJ1bGVNYXRjaFsxXTtcclxuICAgICAgICBjb25zdCBzZXZlcml0eSA9IHJ1bGVNYXRjaFsyXS50b0xvd2VyQ2FzZSgpIGFzICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdyc7XHJcbiAgICAgICAgY29uc3QgcnVsZUNvbnRlbnQgPSBydWxlTWF0Y2hbM107XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgdGl0bGVcclxuICAgICAgICBjb25zdCB0aXRsZU1hdGNoID0gcnVsZUNvbnRlbnQubWF0Y2goLzx0aXRsZVtePl0qPihbXjxdKyk8XFwvdGl0bGU+L2kpO1xyXG4gICAgICAgIGNvbnN0IHRpdGxlID0gdGl0bGVNYXRjaCA/IHRpdGxlTWF0Y2hbMV0udHJpbSgpIDogYFJlcXVpcmVtZW50ICR7Z3JvdXBJZH1gO1xyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IGRlc2NyaXB0aW9uXHJcbiAgICAgICAgY29uc3QgZGVzY01hdGNoID0gcnVsZUNvbnRlbnQubWF0Y2goLzxkZXNjcmlwdGlvbltePl0qPihbXFxzXFxTXSo/KTxcXC9kZXNjcmlwdGlvbj4vaSk7XHJcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBkZXNjTWF0Y2ggPyBzdHJpcEh0bWwoZGVzY01hdGNoWzFdKSA6ICcnO1xyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IGNoZWNrIHRleHRcclxuICAgICAgICBjb25zdCBjaGVja01hdGNoID0gcnVsZUNvbnRlbnQubWF0Y2goLzxjaGVjay1jb250ZW50W14+XSo+KFtcXHNcXFNdKj8pPFxcL2NoZWNrLWNvbnRlbnQ+L2kpO1xyXG4gICAgICAgIGNvbnN0IGNoZWNrVGV4dCA9IGNoZWNrTWF0Y2ggPyBzdHJpcEh0bWwoY2hlY2tNYXRjaFsxXSkgOiAnTm8gY2hlY2sgcHJvY2VkdXJlIHByb3ZpZGVkJztcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBmaXggdGV4dFxyXG4gICAgICAgIGNvbnN0IGZpeE1hdGNoID0gcnVsZUNvbnRlbnQubWF0Y2goLzxmaXh0ZXh0W14+XSo+KFtcXHNcXFNdKj8pPFxcL2ZpeHRleHQ+L2kpO1xyXG4gICAgICAgIGNvbnN0IGZpeFRleHQgPSBmaXhNYXRjaCA/IHN0cmlwSHRtbChmaXhNYXRjaFsxXSkgOiAnTm8gZml4IHByb2NlZHVyZSBwcm92aWRlZCc7XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgQ0NJIHJlZmVyZW5jZXNcclxuICAgICAgICBjb25zdCBjY2lQYXR0ZXJuID0gLzxpZGVudFtePl0qc3lzdGVtPVwiaHR0cDpcXC9cXC9jeWJlclxcLm1pbFxcL2xlZ2FjeVxcL2NjaVwiW14+XSo+KFtePF0rKTxcXC9pZGVudD4vZ2k7XHJcbiAgICAgICAgY29uc3QgY2NpOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGxldCBjY2lNYXRjaDtcclxuICAgICAgICB3aGlsZSAoKGNjaU1hdGNoID0gY2NpUGF0dGVybi5leGVjKHJ1bGVDb250ZW50KSkgIT09IG51bGwpIHtcclxuICAgICAgICAgIGNjaS5wdXNoKGNjaU1hdGNoWzFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgTklTVCBjb250cm9sc1xyXG4gICAgICAgIGNvbnN0IG5pc3RQYXR0ZXJuID0gLzxyZWZlcmVuY2VbXj5dKj4oW1xcc1xcU10qPylOSVNUW148XSooW0EtWl17Mn0tXFxkKyg/OlxccypcXChcXGQrXFwpKT8oPzpcXHMqW2Etel0pPylbXjxdKihbXFxzXFxTXSo/KTxcXC9yZWZlcmVuY2U+L2dpO1xyXG4gICAgICAgIGNvbnN0IG5pc3RDb250cm9sczogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICBsZXQgbmlzdE1hdGNoO1xyXG4gICAgICAgIHdoaWxlICgobmlzdE1hdGNoID0gbmlzdFBhdHRlcm4uZXhlYyhydWxlQ29udGVudCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBjb25zdCBjb250cm9sID0gbmlzdE1hdGNoWzJdLnRyaW0oKTtcclxuICAgICAgICAgIGlmIChjb250cm9sICYmICFuaXN0Q29udHJvbHMuaW5jbHVkZXMoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgbmlzdENvbnRyb2xzLnB1c2goY29udHJvbCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXF1aXJlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICB2dWxuSWQ6IGdyb3VwSWQsXHJcbiAgICAgICAgICBydWxlSWQsXHJcbiAgICAgICAgICBzZXZlcml0eSxcclxuICAgICAgICAgIHRpdGxlLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLnN1YnN0cmluZygwLCA1MDApLCAvLyBMaW1pdCBkZXNjcmlwdGlvbiBsZW5ndGhcclxuICAgICAgICAgIGNoZWNrVGV4dDogY2hlY2tUZXh0LnN1YnN0cmluZygwLCAxMDAwKSxcclxuICAgICAgICAgIGZpeFRleHQ6IGZpeFRleHQuc3Vic3RyaW5nKDAsIDEwMDApLFxyXG4gICAgICAgICAgY2NpOiBjY2kubGVuZ3RoID4gMCA/IGNjaSA6IFsnQ0NJLTAwMDAwMCddLFxyXG4gICAgICAgICAgbmlzdENvbnRyb2xzOiBuaXN0Q29udHJvbHMubGVuZ3RoID4gMCA/IG5pc3RDb250cm9scyA6IFsnQUMtMSddXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVxdWlyZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlcXVpcmVtZW50cyBmb3VuZCBpbiBYTUwuIFRoZSBmaWxlIG1heSBub3QgYmUgYSB2YWxpZCBYQ0NERiBTVElHIGZpbGUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RpZ0lkLFxyXG4gICAgICBzdGlnTmFtZSxcclxuICAgICAgdmVyc2lvbixcclxuICAgICAgcmVsZWFzZURhdGUsXHJcbiAgICAgIHJlcXVpcmVtZW50cyxcclxuICAgICAgdG90YWxSZXF1aXJlbWVudHM6IHJlcXVpcmVtZW50cy5sZW5ndGhcclxuICAgIH07XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgWENDREYgWE1MOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIFhDQ0RGIFhNTDogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFN0cmlwIEhUTUwgdGFncyBhbmQgZGVjb2RlIGVudGl0aWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpcEh0bWwoaHRtbDogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gaHRtbFxyXG4gICAgLnJlcGxhY2UoLzxbXj5dKz4vZywgJycpIC8vIFJlbW92ZSBIVE1MIHRhZ3NcclxuICAgIC5yZXBsYWNlKC8mbHQ7L2csICc8JylcclxuICAgIC5yZXBsYWNlKC8mZ3Q7L2csICc+JylcclxuICAgIC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpXHJcbiAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpXHJcbiAgICAucmVwbGFjZSgvJiMzOTsvZywgXCInXCIpXHJcbiAgICAucmVwbGFjZSgvJm5ic3A7L2csICcgJylcclxuICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJykgLy8gTm9ybWFsaXplIHdoaXRlc3BhY2VcclxuICAgIC50cmltKCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImh0dHBzIiwiaGFzTG9jYWxTdGlnIiwiZ2V0TG9jYWxTdGlnQ29udGVudCIsImdldExvY2FsU3RpZ01ldGFkYXRhIiwiR0VUIiwicmVxdWVzdCIsInNlYXJjaFBhcmFtcyIsIlVSTCIsInVybCIsInN0aWdJZCIsImdldCIsImpzb24iLCJlcnJvciIsInN0YXR1cyIsImNvbnNvbGUiLCJsb2ciLCJtZXRhZGF0YSIsImNvbnRlbnQiLCJmaWxlbmFtZSIsImlzWG1sIiwiZm9ybWF0IiwidG9Mb3dlckNhc2UiLCJlbmRzV2l0aCIsInN0aWdEYXRhIiwicGFyc2VYY2NkZlhtbCIsInJlcXVpcmVtZW50cyIsImxlbmd0aCIsInN1Y2Nlc3MiLCJ2ZXJzaW9uIiwicmVsZWFzZURhdGUiLCJzb3VyY2UiLCJtZXNzYWdlIiwicGFyc2VTdGlnQ3N2Iiwic3RpZ05hbWUiLCJuYW1lIiwibG9jYWxFcnJvciIsImluc3RydWN0aW9ucyIsInN0ZXAxIiwic3RlcDIiLCJzdGVwMyIsInN0ZXA0Iiwibm90ZSIsImNzdkNvbnRlbnQiLCJmaWxlTmFtZSIsImxpbmVzIiwiY3VycmVudExpbmUiLCJpbnNpZGVRdW90ZXMiLCJpIiwiY2hhciIsIm5leHRDaGFyIiwidHJpbSIsInB1c2giLCJyZXBsYWNlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJ0b3RhbFJlcXVpcmVtZW50cyIsInBhcnNlQ1NWTGluZSIsImxpbmUiLCJyZXN1bHQiLCJjdXJyZW50IiwiaW5RdW90ZXMiLCJoZWFkZXJMaW5lSW5kZXgiLCJoZWFkZXJzIiwiTWF0aCIsIm1pbiIsInBhcnNlZExpbmUiLCJsaW5lVGV4dCIsImpvaW4iLCJpbmNsdWRlcyIsIm1hcCIsImgiLCJzbGljZSIsImdldEluZGV4IiwibmFtZXMiLCJpZHgiLCJmaW5kSW5kZXgiLCJzdGlnSWRJZHgiLCJzZXZlcml0eUlkeCIsInRpdGxlSWR4IiwiZGlzY3Vzc2lvbklkeCIsImNoZWNrSWR4IiwiZml4SWR4IiwiY2NpSWR4IiwicnVsZUlkSWR4Iiwic2V2ZXJpdHkiLCJ0aXRsZSIsImRpc2N1c3Npb24iLCJjaGVjayIsImZpeCIsImNjaSIsInJ1bGVJZCIsInZhbHVlcyIsImJlbmNobWFya0lkeCIsInZlcnNpb25JZHgiLCJ2dWxuSWQiLCJzZXZlcml0eVZhbHVlIiwiY2NpVGV4dCIsImNjaU1hdGNoZXMiLCJtYXRjaCIsImRlc2NyaXB0aW9uIiwiY2hlY2tUZXh0IiwiZml4VGV4dCIsIm5pc3RDb250cm9scyIsIlBPU1QiLCJmb3JtRGF0YSIsImZpbGUiLCJpc0NzdiIsImZpbGVDb250ZW50IiwidGV4dCIsIkVycm9yIiwiZmV0Y2hSZXF1aXJlbWVudERldGFpbHMiLCJhZ2VudCIsIkFnZW50IiwicmVqZWN0VW5hdXRob3JpemVkIiwicmVzcG9uc2UiLCJmZXRjaCIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwidGltZW91dCIsIm9rIiwiaHRtbCIsImNoZWNrTWF0Y2giLCJmaXhNYXRjaCIsInBhcnNlU3RpZ1ZpZXdlckpzb24iLCJqc29uRGF0YSIsInN0aWciLCJkYXRlIiwiZmluZGluZ3MiLCJ2dWxuSWRzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJmaW5kaW5nIiwic2V2VGV4dCIsImNhdCIsInRvU3RyaW5nIiwicnVsZV9pZCIsInJ1bGVpZCIsInJ1bGVUaXRsZSIsInJ1bGV0aXRsZSIsImNoZWNrdGV4dCIsImNoZWNrX3RleHQiLCJmaXh0ZXh0IiwiZml4X3RleHQiLCJjY2lzIiwibmlzdCIsInNldmVyaXR5RGlzdCIsInJlcSIsInBhcnNlU3RpZ1ZpZXdlckh0bWwiLCJ0aXRsZU1hdGNoIiwidmVyc2lvbk1hdGNoIiwiZGF0ZU1hdGNoIiwicmVxU2VjdGlvblBhdHRlcm4iLCJkZXRhaWxlZFJlcXMiLCJleGVjIiwidGFibGVSb3dzIiwicm93UGF0dGVybiIsInJvd01hdGNoIiwicm93SHRtbCIsInZ1bG5NYXRjaCIsImNhdE1hdGNoIiwic2V2TWF0Y2giLCJ2dWxuSWRQYXR0ZXJuIiwiYWxsVnVsbklkcyIsIlNldCIsInJlcURhdGEiLCJyZXF1aXJlbWVudENvdW50IiwicmF3U2V2ZXJpdHkiLCJydWxlUGF0dGVybiIsIlJlZ0V4cCIsInJ1bGVNYXRjaCIsInZ1bG5Db250ZXh0Iiwic3Vic3RyaW5nIiwibWF4IiwiaW5kZXhPZiIsIm5pc3RNYXRjaGVzIiwid2FybiIsImluZGV4IiwieG1sQ29udGVudCIsImdyb3VwUGF0dGVybiIsImdyb3VwTWF0Y2giLCJncm91cElkIiwiZ3JvdXBDb250ZW50IiwicnVsZUNvbnRlbnQiLCJkZXNjTWF0Y2giLCJzdHJpcEh0bWwiLCJjY2lQYXR0ZXJuIiwiY2NpTWF0Y2giLCJuaXN0UGF0dGVybiIsIm5pc3RNYXRjaCIsImNvbnRyb2wiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/import-stig/route.ts\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/./node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/./node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var C_Users_ronni_OneDrive_Desktop_Projects_SRTM_tool_app_api_import_stig_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./app/api/import-stig/route.ts */ \"(rsc)/./app/api/import-stig/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/import-stig/route\",\n        pathname: \"/api/import-stig\",\n        filename: \"route\",\n        bundlePath: \"app/api/import-stig/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"C:\\\\Users\\\\ronni\\\\OneDrive\\\\Desktop\\\\Projects\\\\SRTM-tool\\\\app\\\\api\\\\import-stig\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_ronni_OneDrive_Desktop_Projects_SRTM_tool_app_api_import_stig_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/import-stig/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZpbXBvcnQtc3RpZyUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGaW1wb3J0LXN0aWclMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZpbXBvcnQtc3RpZyUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNyb25uaSU1Q09uZURyaXZlJTVDRGVza3RvcCU1Q1Byb2plY3RzJTVDU1JUTS10b29sJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1DJTNBJTVDVXNlcnMlNUNyb25uaSU1Q09uZURyaXZlJTVDRGVza3RvcCU1Q1Byb2plY3RzJTVDU1JUTS10b29sJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PXN0YW5kYWxvbmUmcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCZpc0dsb2JhbE5vdEZvdW5kRW5hYmxlZD0hIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ3FCO0FBQ2Q7QUFDUztBQUNPO0FBQ0s7QUFDbUM7QUFDakQ7QUFDTztBQUNmO0FBQ3NDO0FBQ3pCO0FBQ007QUFDQztBQUNoQjtBQUNvRDtBQUN0SDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhLE9BQW9DLElBQUksQ0FBRTtBQUN2RCx3QkFBd0IsTUFBdUM7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NkNBQTZDLDBGQUFxQjtBQUNsRTtBQUNBLGtCQUFrQiw2RUFBWTtBQUM5QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2RUFBNkUsZ0ZBQWM7QUFDM0YsaUNBQWlDLFFBQVEsRUFBRSxRQUFRO0FBQ25ELDBCQUEwQix1RUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTiw2QkFBNkIsNkZBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkZBQW1CO0FBQ3JEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZFQUFZO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCB7IGdldFJlcXVlc3RNZXRhIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcmVxdWVzdC1tZXRhXCI7XG5pbXBvcnQgeyBnZXRUcmFjZXIsIFNwYW5LaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL3RyYWNlclwiO1xuaW1wb3J0IHsgbm9ybWFsaXplQXBwUGF0aCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYXBwLXBhdGhzXCI7XG5pbXBvcnQgeyBOb2RlTmV4dFJlcXVlc3QsIE5vZGVOZXh0UmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9iYXNlLWh0dHAvbm9kZVwiO1xuaW1wb3J0IHsgTmV4dFJlcXVlc3RBZGFwdGVyLCBzaWduYWxGcm9tTm9kZVJlc3BvbnNlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL25leHQtcmVxdWVzdFwiO1xuaW1wb3J0IHsgQmFzZVNlcnZlclNwYW4gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBnZXRSZXZhbGlkYXRlUmVhc29uIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvaW5zdHJ1bWVudGF0aW9uL3V0aWxzXCI7XG5pbXBvcnQgeyBzZW5kUmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9zZW5kLXJlc3BvbnNlXCI7XG5pbXBvcnQgeyBmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMsIHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci93ZWIvdXRpbHNcIjtcbmltcG9ydCB7IGdldENhY2hlQ29udHJvbEhlYWRlciB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9jYWNoZS1jb250cm9sXCI7XG5pbXBvcnQgeyBJTkZJTklURV9DQUNIRSwgTkVYVF9DQUNIRV9UQUdTX0hFQURFUiB9IGZyb20gXCJuZXh0L2Rpc3QvbGliL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgTm9GYWxsYmFja0Vycm9yIH0gZnJvbSBcIm5leHQvZGlzdC9zaGFyZWQvbGliL25vLWZhbGxiYWNrLWVycm9yLmV4dGVybmFsXCI7XG5pbXBvcnQgeyBDYWNoZWRSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZXNwb25zZS1jYWNoZVwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIkM6XFxcXFVzZXJzXFxcXHJvbm5pXFxcXE9uZURyaXZlXFxcXERlc2t0b3BcXFxcUHJvamVjdHNcXFxcU1JUTS10b29sXFxcXGFwcFxcXFxhcGlcXFxcaW1wb3J0LXN0aWdcXFxccm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwic3RhbmRhbG9uZVwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9pbXBvcnQtc3RpZy9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2ltcG9ydC1zdGlnXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9pbXBvcnQtc3RpZy9yb3V0ZVwiXG4gICAgfSxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcmVsYXRpdmVQcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJycsXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJDOlxcXFxVc2Vyc1xcXFxyb25uaVxcXFxPbmVEcml2ZVxcXFxEZXNrdG9wXFxcXFByb2plY3RzXFxcXFNSVE0tdG9vbFxcXFxhcHBcXFxcYXBpXFxcXGltcG9ydC1zdGlnXFxcXHJvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICAgICAgd29ya1VuaXRBc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIHBhdGNoRmV0Y2gsICB9O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMsIGN0eCkge1xuICAgIHZhciBfbmV4dENvbmZpZ19leHBlcmltZW50YWw7XG4gICAgbGV0IHNyY1BhZ2UgPSBcIi9hcGkvaW1wb3J0LXN0aWcvcm91dGVcIjtcbiAgICAvLyB0dXJib3BhY2sgZG9lc24ndCBub3JtYWxpemUgYC9pbmRleGAgaW4gdGhlIHBhZ2UgbmFtZVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gdG8gcHJvY2VzcyBkeW5hbWljIHJvdXRlcyBwcm9wZXJseVxuICAgIC8vIFRPRE86IGZpeCB0dXJib3BhY2sgcHJvdmlkaW5nIGRpZmZlcmluZyB2YWx1ZSBmcm9tIHdlYnBhY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIHNyY1BhZ2UgPSBzcmNQYWdlLnJlcGxhY2UoL1xcL2luZGV4JC8sICcnKSB8fCAnLyc7XG4gICAgfSBlbHNlIGlmIChzcmNQYWdlID09PSAnL2luZGV4Jykge1xuICAgICAgICAvLyB3ZSBhbHdheXMgbm9ybWFsaXplIC9pbmRleCBzcGVjaWZpY2FsbHlcbiAgICAgICAgc3JjUGFnZSA9ICcvJztcbiAgICB9XG4gICAgY29uc3QgbXVsdGlab25lRHJhZnRNb2RlID0gcHJvY2Vzcy5lbnYuX19ORVhUX01VTFRJX1pPTkVfRFJBRlRfTU9ERTtcbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlLFxuICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGVcbiAgICB9KTtcbiAgICBpZiAoIXByZXBhcmVSZXN1bHQpIHtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgIHJlcy5lbmQoJ0JhZCBSZXF1ZXN0Jyk7XG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVpbGRJZCwgcGFyYW1zLCBuZXh0Q29uZmlnLCBpc0RyYWZ0TW9kZSwgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQsIGlzT25EZW1hbmRSZXZhbGlkYXRlLCByZXZhbGlkYXRlT25seUdlbmVyYXRlZCwgcmVzb2x2ZWRQYXRobmFtZSB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICBjb25zdCBub3JtYWxpemVkU3JjUGFnZSA9IG5vcm1hbGl6ZUFwcFBhdGgoc3JjUGFnZSk7XG4gICAgbGV0IGlzSXNyID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSB8fCBwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgIGlmIChpc0lzciAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY29uc3QgaXNQcmVyZW5kZXJlZCA9IEJvb2xlYW4ocHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW3Jlc29sdmVkUGF0aG5hbWVdKTtcbiAgICAgICAgY29uc3QgcHJlcmVuZGVySW5mbyA9IHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdO1xuICAgICAgICBpZiAocHJlcmVuZGVySW5mbykge1xuICAgICAgICAgICAgaWYgKHByZXJlbmRlckluZm8uZmFsbGJhY2sgPT09IGZhbHNlICYmICFpc1ByZXJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vRmFsbGJhY2tFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjYWNoZUtleSA9IG51bGw7XG4gICAgaWYgKGlzSXNyICYmICFyb3V0ZU1vZHVsZS5pc0RldiAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY2FjaGVLZXkgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAvLyBlbnN1cmUgL2luZGV4IGFuZCAvIGlzIG5vcm1hbGl6ZWQgdG8gb25lIGtleVxuICAgICAgICBjYWNoZUtleSA9IGNhY2hlS2V5ID09PSAnL2luZGV4JyA/ICcvJyA6IGNhY2hlS2V5O1xuICAgIH1cbiAgICBjb25zdCBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSA9IC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50LCB3ZSBhbHdheXMgc3VwcG9ydCBkeW5hbWljIEhUTUxcbiAgICByb3V0ZU1vZHVsZS5pc0RldiA9PT0gdHJ1ZSB8fCAvLyBJZiB0aGlzIGlzIG5vdCBTU0cgb3IgZG9lcyBub3QgaGF2ZSBzdGF0aWMgcGF0aHMsIHRoZW4gaXQgc3VwcG9ydHNcbiAgICAvLyBkeW5hbWljIEhUTUwuXG4gICAgIWlzSXNyO1xuICAgIC8vIFRoaXMgaXMgYSByZXZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWNcbiAgICAvLyBwYWdlIGFuZCBpdCBpcyBub3QgYmVpbmcgcmVzdW1lZCBmcm9tIGEgcG9zdHBvbmVkIHJlbmRlciBhbmRcbiAgICAvLyBpdCBpcyBub3QgYSBkeW5hbWljIFJTQyByZXF1ZXN0IHRoZW4gaXQgaXMgYSByZXZhbGlkYXRpb25cbiAgICAvLyByZXF1ZXN0LlxuICAgIGNvbnN0IGlzUmV2YWxpZGF0ZSA9IGlzSXNyICYmICFzdXBwb3J0c0R5bmFtaWNSZXNwb25zZTtcbiAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsOiB7XG4gICAgICAgICAgICAgICAgY2FjaGVDb21wb25lbnRzOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmNhY2hlQ29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgYXV0aEludGVycnVwdHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuYXV0aEludGVycnVwdHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2UsXG4gICAgICAgICAgICBpbmNyZW1lbnRhbENhY2hlOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbmNyZW1lbnRhbENhY2hlJyksXG4gICAgICAgICAgICBjYWNoZUxpZmVQcm9maWxlczogKF9uZXh0Q29uZmlnX2V4cGVyaW1lbnRhbCA9IG5leHRDb25maWcuZXhwZXJpbWVudGFsKSA9PSBudWxsID8gdm9pZCAwIDogX25leHRDb25maWdfZXhwZXJpbWVudGFsLmNhY2hlTGlmZSxcbiAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbCxcbiAgICAgICAgICAgIG9uQ2xvc2U6IChjYik9PntcbiAgICAgICAgICAgICAgICByZXMub24oJ2Nsb3NlJywgY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQWZ0ZXJUYXNrRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uSW5zdHJ1bWVudGF0aW9uUmVxdWVzdEVycm9yOiAoZXJyb3IsIF9yZXF1ZXN0LCBlcnJvckNvbnRleHQpPT5yb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVycm9yLCBlcnJvckNvbnRleHQsIHJvdXRlclNlcnZlckNvbnRleHQpXG4gICAgICAgIH0sXG4gICAgICAgIHNoYXJlZENvbnRleHQ6IHtcbiAgICAgICAgICAgIGJ1aWxkSWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9kZU5leHRSZXEgPSBuZXcgTm9kZU5leHRSZXF1ZXN0KHJlcSk7XG4gICAgY29uc3Qgbm9kZU5leHRSZXMgPSBuZXcgTm9kZU5leHRSZXNwb25zZShyZXMpO1xuICAgIGNvbnN0IG5leHRSZXEgPSBOZXh0UmVxdWVzdEFkYXB0ZXIuZnJvbU5vZGVOZXh0UmVxdWVzdChub2RlTmV4dFJlcSwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZShyZXMpKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnZva2VSb3V0ZU1vZHVsZSA9IGFzeW5jIChzcGFuKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlTW9kdWxlLmhhbmRsZShuZXh0UmVxLCBjb250ZXh0KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gYXN5bmMgKGN1cnJlbnRTcGFuKT0+e1xuICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VHZW5lcmF0b3IgPSBhc3luYyAoeyBwcmV2aW91c0NhY2hlRW50cnkgfSk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiYgaXNPbkRlbWFuZFJldmFsaWRhdGUgJiYgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQgJiYgIXByZXZpb3VzQ2FjaGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbi1kZW1hbmQgcmV2YWxpZGF0ZSBhbHdheXMgc2V0cyB0aGlzIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCAnUkVWQUxJREFURUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW52b2tlUm91dGVNb2R1bGUoY3VycmVudFNwYW4pO1xuICAgICAgICAgICAgICAgICAgICByZXEuZmV0Y2hNZXRyaWNzID0gY29udGV4dC5yZW5kZXJPcHRzLmZldGNoTWV0cmljcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlbmRpbmdXYWl0VW50aWwgPSBjb250ZXh0LnJlbmRlck9wdHMucGVuZGluZ1dhaXRVbnRpbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB1c2luZyBwcm92aWRlZCB3YWl0VW50aWwgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHdlIGZhbGxiYWNrIHRvIHNlbmRSZXNwb25zZSdzIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nV2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LndhaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC53YWl0VW50aWwocGVuZGluZ1dhaXRVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dhaXRVbnRpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZVRhZ3MgPSBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkVGFncztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgZm9yIGEgc3RhdGljIHJlc3BvbnNlLCB3ZSBjYW4gY2FjaGUgaXQgc28gbG9uZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIG5vdCBlZGdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJc3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBoZWFkZXJzIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tORVhUX0NBQ0hFX1RBR1NfSEVBREVSXSA9IGNhY2hlVGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyc1snY29udGVudC10eXBlJ10gJiYgYmxvYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBibG9iLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gdHlwZW9mIGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZSA+PSBJTkZJTklURV9DQUNIRSA/IGZhbHNlIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA+PSBJTkZJTklURV9DQUNIRSA/IHVuZGVmaW5lZCA6IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRFeHBpcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNhY2hlIGVudHJ5IGZvciB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBCdWZmZXIuZnJvbShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCByZXNwb25zZSB3aXRob3V0IGNhY2hpbmcgaWYgbm90IElTUlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VuZFJlc3BvbnNlKG5vZGVOZXh0UmVxLCBub2RlTmV4dFJlcywgcmVzcG9uc2UsIGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBiYWNrZ3JvdW5kIHJldmFsaWRhdGUgd2UgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgZXJyb3IgaGVyZSBhcyBpdCB3b24ndCBiZSBidWJibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NhY2hlRW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzQ2FjaGVFbnRyeS5pc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVyciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcktpbmQ6ICdBcHAgUm91dGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVBhdGg6IHNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJvdXRlclNlcnZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGF3YWl0IHJvdXRlTW9kdWxlLmhhbmRsZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlR2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjcmVhdGUgYSBjYWNoZUVudHJ5IGZvciBJU1JcbiAgICAgICAgICAgIGlmICghaXNJc3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlLmtpbmQpICE9PSBDYWNoZWRSb3V0ZUtpbmQuQVBQX1JPVVRFKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlMTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhcmlhbnQ6IGFwcC1yb3V0ZSByZWNlaXZlZCBpbnZhbGlkIGNhY2hlIGVudHJ5ICR7Y2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlMSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZTEua2luZH1gKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU3MDFcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCBpc09uRGVtYW5kUmV2YWxpZGF0ZSA/ICdSRVZBTElEQVRFRCcgOiBjYWNoZUVudHJ5LmlzTWlzcyA/ICdNSVNTJyA6IGNhY2hlRW50cnkuaXNTdGFsZSA/ICdTVEFMRScgOiAnSElUJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcmFmdCBtb2RlIHNob3VsZCBuZXZlciBiZSBjYWNoZWRcbiAgICAgICAgICAgIGlmIChpc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCAncHJpdmF0ZSwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtYXgtYWdlPTAsIG11c3QtcmV2YWxpZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhjYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKCEoZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc0lzcikpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmRlbGV0ZShORVhUX0NBQ0hFX1RBR1NfSEVBREVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGNhY2hlIGNvbnRyb2wgaXMgYWxyZWFkeSBzZXQgb24gdGhlIHJlc3BvbnNlIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBvdmVycmlkZSBpdCB0byBhbGxvdyB1c2VycyB0byBjdXN0b21pemUgaXQgdmlhIG5leHQuY29uZmlnXG4gICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wgJiYgIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSAmJiAhaGVhZGVycy5nZXQoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdDYWNoZS1Db250cm9sJywgZ2V0Q2FjaGVDb250cm9sSGVhZGVyKGNhY2hlRW50cnkuY2FjaGVDb250cm9sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UoY2FjaGVFbnRyeS52YWx1ZS5ib2R5LCB7XG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlRW50cnkudmFsdWUuc3RhdHVzIHx8IDIwMFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVSZXNwb25zZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVSZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIE5vRmFsbGJhY2tFcnJvcikpIHtcbiAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogbm9ybWFsaXplZFNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldGhyb3cgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHNlcnZpbmcgZXJyb3IgcGFnZVxuICAgICAgICAvLyBJZiB0aGlzIGlzIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbiwgdGhyb3cgdGhlIGVycm9yIGFnYWluLlxuICAgICAgICBpZiAoaXNJc3IpIHRocm93IGVycjtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZW5kIGEgNTAwIHJlc3BvbnNlLlxuICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./utils/localStigLibrary.ts":
/*!***********************************!*\
  !*** ./utils/localStigLibrary.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLocalStigContent: () => (/* binding */ getLocalStigContent),\n/* harmony export */   getLocalStigMetadata: () => (/* binding */ getLocalStigMetadata),\n/* harmony export */   getLocalStigStats: () => (/* binding */ getLocalStigStats),\n/* harmony export */   getStigDirectory: () => (/* binding */ getStigDirectory),\n/* harmony export */   hasLocalStig: () => (/* binding */ hasLocalStig),\n/* harmony export */   listLocalStigs: () => (/* binding */ listLocalStigs)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/**\r\n * Local STIG Library Management\r\n * Handles reading and serving STIG files from the local public/stigs directory\r\n */ \n\n/**\r\n * Get the path to the local STIG directory\r\n */ function getStigDirectory() {\n    return path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'stigs');\n}\n/**\r\n * Check if a STIG exists in the local library\r\n */ function hasLocalStig(stigId) {\n    const stigDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(getStigDirectory(), stigId);\n    return fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(stigDir);\n}\n/**\r\n * Get metadata for a local STIG\r\n */ function getLocalStigMetadata(stigId) {\n    try {\n        const metadataPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(getStigDirectory(), stigId, 'metadata.json');\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(metadataPath)) {\n            const metadata = JSON.parse(fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(metadataPath, 'utf-8'));\n            return metadata;\n        }\n        // Try to auto-detect if no metadata file\n        const stigDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(getStigDirectory(), stigId);\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(stigDir)) {\n            const files = fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(stigDir);\n            const xmlFile = files.find((f)=>f.endsWith('.xml') || f.endsWith('.xccdf'));\n            const csvFile = files.find((f)=>f.endsWith('.csv'));\n            if (xmlFile || csvFile) {\n                return {\n                    stigId,\n                    name: stigId.replace(/_/g, ' ').replace(/\\b\\w/g, (l)=>l.toUpperCase()),\n                    version: 'Unknown',\n                    releaseDate: new Date().toISOString().split('T')[0],\n                    filename: xmlFile || csvFile || '',\n                    format: xmlFile ? 'xml' : 'csv'\n                };\n            }\n        }\n        return null;\n    } catch (error) {\n        console.error(`Error reading metadata for ${stigId}:`, error);\n        return null;\n    }\n}\n/**\r\n * Read local STIG file content\r\n */ function getLocalStigContent(stigId) {\n    try {\n        const metadata = getLocalStigMetadata(stigId);\n        if (!metadata) return null;\n        const filePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(getStigDirectory(), stigId, metadata.filename);\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(filePath)) {\n            return fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(filePath, 'utf-8');\n        }\n        return null;\n    } catch (error) {\n        console.error(`Error reading STIG file for ${stigId}:`, error);\n        return null;\n    }\n}\n/**\r\n * List all available local STIGs\r\n */ function listLocalStigs() {\n    try {\n        const stigsDir = getStigDirectory();\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(stigsDir)) {\n            return [];\n        }\n        const directories = fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(stigsDir, {\n            withFileTypes: true\n        }).filter((dirent)=>dirent.isDirectory()).map((dirent)=>dirent.name);\n        const stigs = [];\n        for (const stigId of directories){\n            const metadata = getLocalStigMetadata(stigId);\n            if (metadata) {\n                stigs.push(metadata);\n            }\n        }\n        return stigs.sort((a, b)=>a.name.localeCompare(b.name));\n    } catch (error) {\n        console.error('Error listing local STIGs:', error);\n        return [];\n    }\n}\n/**\r\n * Get statistics about local STIG library\r\n */ function getLocalStigStats() {\n    const stigs = listLocalStigs();\n    return {\n        total: stigs.length,\n        byFormat: {\n            xml: stigs.filter((s)=>s.format === 'xml').length,\n            csv: stigs.filter((s)=>s.format === 'csv').length\n        },\n        stigs: stigs.map((s)=>({\n                id: s.stigId,\n                name: s.name,\n                version: s.version\n            }))\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDbkM7WUFDYjtRQUNGO1FBRUEsT0FBT2tDLE1BQU1FLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFMUIsSUFBSSxDQUFDNEIsYUFBYSxDQUFDRCxFQUFFM0IsSUFBSTtJQUN6RCxFQUFFLE9BQU9XLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBTyxFQUFFO0lBQ1g7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU2tCO0lBQ2QsTUFBTU4sUUFBUVI7SUFFZCxPQUFPO1FBQ0xlLE9BQU9QLE1BQU1RLE1BQU07UUFDbkJDLFVBQVU7WUFDUkMsS0FBS1YsTUFBTUosTUFBTSxDQUFDZSxDQUFBQSxJQUFLQSxFQUFFeEIsTUFBTSxLQUFLLE9BQU9xQixNQUFNO1lBQ2pESSxLQUFLWixNQUFNSixNQUFNLENBQUNlLENBQUFBLElBQUtBLEVBQUV4QixNQUFNLEtBQUssT0FBT3FCLE1BQU07UUFDbkQ7UUFDQVIsT0FBT0EsTUFBTUQsR0FBRyxDQUFDWSxDQUFBQSxJQUFNO2dCQUNyQkUsSUFBSUYsRUFBRWxELE1BQU07Z0JBQ1pnQixNQUFNa0MsRUFBRWxDLElBQUk7Z0JBQ1pJLFNBQVM4QixFQUFFOUIsT0FBTztZQUNwQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xccm9ubmlcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZWN0c1xcU1JUTS10b29sXFx1dGlsc1xcbG9jYWxTdGlnTGlicmFyeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTG9jYWwgU1RJRyBMaWJyYXJ5IE1hbmFnZW1lbnRcclxuICogSGFuZGxlcyByZWFkaW5nIGFuZCBzZXJ2aW5nIFNUSUcgZmlsZXMgZnJvbSB0aGUgbG9jYWwgcHVibGljL3N0aWdzIGRpcmVjdG9yeVxyXG4gKi9cclxuXHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMb2NhbFN0aWdNZXRhZGF0YSB7XHJcbiAgc3RpZ0lkOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIHZlcnNpb246IHN0cmluZztcclxuICByZWxlYXNlRGF0ZTogc3RyaW5nO1xyXG4gIGZpbGVuYW1lOiBzdHJpbmc7XHJcbiAgZm9ybWF0PzogJ3htbCcgfCAnY3N2JztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcGF0aCB0byB0aGUgbG9jYWwgU1RJRyBkaXJlY3RvcnlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGlnRGlyZWN0b3J5KCk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ3N0aWdzJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIFNUSUcgZXhpc3RzIGluIHRoZSBsb2NhbCBsaWJyYXJ5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzTG9jYWxTdGlnKHN0aWdJZDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgY29uc3Qgc3RpZ0RpciA9IHBhdGguam9pbihnZXRTdGlnRGlyZWN0b3J5KCksIHN0aWdJZCk7XHJcbiAgcmV0dXJuIGZzLmV4aXN0c1N5bmMoc3RpZ0Rpcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgbWV0YWRhdGEgZm9yIGEgbG9jYWwgU1RJR1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsU3RpZ01ldGFkYXRhKHN0aWdJZDogc3RyaW5nKTogTG9jYWxTdGlnTWV0YWRhdGEgfCBudWxsIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgbWV0YWRhdGFQYXRoID0gcGF0aC5qb2luKGdldFN0aWdEaXJlY3RvcnkoKSwgc3RpZ0lkLCAnbWV0YWRhdGEuanNvbicpO1xyXG4gICAgXHJcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhtZXRhZGF0YVBhdGgpKSB7XHJcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMobWV0YWRhdGFQYXRoLCAndXRmLTgnKSk7XHJcbiAgICAgIHJldHVybiBtZXRhZGF0YTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVHJ5IHRvIGF1dG8tZGV0ZWN0IGlmIG5vIG1ldGFkYXRhIGZpbGVcclxuICAgIGNvbnN0IHN0aWdEaXIgPSBwYXRoLmpvaW4oZ2V0U3RpZ0RpcmVjdG9yeSgpLCBzdGlnSWQpO1xyXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoc3RpZ0RpcikpIHtcclxuICAgICAgY29uc3QgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhzdGlnRGlyKTtcclxuICAgICAgY29uc3QgeG1sRmlsZSA9IGZpbGVzLmZpbmQoZiA9PiBmLmVuZHNXaXRoKCcueG1sJykgfHwgZi5lbmRzV2l0aCgnLnhjY2RmJykpO1xyXG4gICAgICBjb25zdCBjc3ZGaWxlID0gZmlsZXMuZmluZChmID0+IGYuZW5kc1dpdGgoJy5jc3YnKSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoeG1sRmlsZSB8fCBjc3ZGaWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN0aWdJZCxcclxuICAgICAgICAgIG5hbWU6IHN0aWdJZC5yZXBsYWNlKC9fL2csICcgJykucmVwbGFjZSgvXFxiXFx3L2csIGwgPT4gbC50b1VwcGVyQ2FzZSgpKSxcclxuICAgICAgICAgIHZlcnNpb246ICdVbmtub3duJyxcclxuICAgICAgICAgIHJlbGVhc2VEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcclxuICAgICAgICAgIGZpbGVuYW1lOiB4bWxGaWxlIHx8IGNzdkZpbGUgfHwgJycsXHJcbiAgICAgICAgICBmb3JtYXQ6IHhtbEZpbGUgPyAneG1sJyA6ICdjc3YnXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBtZXRhZGF0YSBmb3IgJHtzdGlnSWR9OmAsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlYWQgbG9jYWwgU1RJRyBmaWxlIGNvbnRlbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhbFN0aWdDb250ZW50KHN0aWdJZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0TG9jYWxTdGlnTWV0YWRhdGEoc3RpZ0lkKTtcclxuICAgIGlmICghbWV0YWRhdGEpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihnZXRTdGlnRGlyZWN0b3J5KCksIHN0aWdJZCwgbWV0YWRhdGEuZmlsZW5hbWUpO1xyXG4gICAgXHJcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkpIHtcclxuICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0Zi04Jyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWFkaW5nIFNUSUcgZmlsZSBmb3IgJHtzdGlnSWR9OmAsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3QgYWxsIGF2YWlsYWJsZSBsb2NhbCBTVElHc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RMb2NhbFN0aWdzKCk6IExvY2FsU3RpZ01ldGFkYXRhW10ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzdGlnc0RpciA9IGdldFN0aWdEaXJlY3RvcnkoKTtcclxuICAgIFxyXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHN0aWdzRGlyKSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGRpcmVjdG9yaWVzID0gZnMucmVhZGRpclN5bmMoc3RpZ3NEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxyXG4gICAgICAuZmlsdGVyKGRpcmVudCA9PiBkaXJlbnQuaXNEaXJlY3RvcnkoKSlcclxuICAgICAgLm1hcChkaXJlbnQgPT4gZGlyZW50Lm5hbWUpO1xyXG4gICAgXHJcbiAgICBjb25zdCBzdGlnczogTG9jYWxTdGlnTWV0YWRhdGFbXSA9IFtdO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IHN0aWdJZCBvZiBkaXJlY3Rvcmllcykge1xyXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGdldExvY2FsU3RpZ01ldGFkYXRhKHN0aWdJZCk7XHJcbiAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgIHN0aWdzLnB1c2gobWV0YWRhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBzdGlncy5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbGlzdGluZyBsb2NhbCBTVElHczonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHN0YXRpc3RpY3MgYWJvdXQgbG9jYWwgU1RJRyBsaWJyYXJ5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYWxTdGlnU3RhdHMoKSB7XHJcbiAgY29uc3Qgc3RpZ3MgPSBsaXN0TG9jYWxTdGlncygpO1xyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICB0b3RhbDogc3RpZ3MubGVuZ3RoLFxyXG4gICAgYnlGb3JtYXQ6IHtcclxuICAgICAgeG1sOiBzdGlncy5maWx0ZXIocyA9PiBzLmZvcm1hdCA9PT0gJ3htbCcpLmxlbmd0aCxcclxuICAgICAgY3N2OiBzdGlncy5maWx0ZXIocyA9PiBzLmZvcm1hdCA9PT0gJ2NzdicpLmxlbmd0aFxyXG4gICAgfSxcclxuICAgIHN0aWdzOiBzdGlncy5tYXAocyA9PiAoe1xyXG4gICAgICBpZDogcy5zdGlnSWQsXHJcbiAgICAgIG5hbWU6IHMubmFtZSxcclxuICAgICAgdmVyc2lvbjogcy52ZXJzaW9uXHJcbiAgICB9KSlcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJmcyIsInBhdGgiLCJnZXRTdGlnRGlyZWN0b3J5Iiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJoYXNMb2NhbFN0aWciLCJzdGlnSWQiLCJzdGlnRGlyIiwiZXhpc3RzU3luYyIsImdldExvY2FsU3RpZ01ldGFkYXRhIiwibWV0YWRhdGFQYXRoIiwibWV0YWRhdGEiLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZVN5bmMiLCJmaWxlcyIsInJlYWRkaXJTeW5jIiwieG1sRmlsZSIsImZpbmQiLCJmIiwiZW5kc1dpdGgiLCJjc3ZGaWxlIiwibmFtZSIsInJlcGxhY2UiLCJsIiwidG9VcHBlckNhc2UiLCJ2ZXJzaW9uIiwicmVsZWFzZURhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImZpbGVuYW1lIiwiZm9ybWF0IiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0TG9jYWxTdGlnQ29udGVudCIsImZpbGVQYXRoIiwibGlzdExvY2FsU3RpZ3MiLCJzdGlnc0RpciIsImRpcmVjdG9yaWVzIiwid2l0aEZpbGVUeXBlcyIsImZpbHRlciIsImRpcmVudCIsImlzRGlyZWN0b3J5IiwibWFwIiwic3RpZ3MiLCJwdXNoIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImdldExvY2FsU3RpZ1N0YXRzIiwidG90YWwiLCJsZW5ndGgiLCJieUZvcm1hdCIsInhtbCIsInMiLCJjc3YiLCJpZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./utils/localStigLibrary.ts\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "./work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();