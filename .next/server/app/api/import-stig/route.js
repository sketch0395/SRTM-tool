/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/import-stig/route";
exports.ids = ["app/api/import-stig/route"];
exports.modules = {

/***/ "(rsc)/./app/api/import-stig/route.ts":
/*!**************************************!*\
  !*** ./app/api/import-stig/route.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_localStigLibrary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/localStigLibrary */ \"(rsc)/./utils/localStigLibrary.ts\");\n\n\n\n/**\r\n * GET - Fetch STIG from local library or stigviewer.com\r\n * Query params: stigId (e.g., 'apache_server_2.4_unix')\r\n */ async function GET(request) {\n    try {\n        const { searchParams } = new URL(request.url);\n        const stigId = searchParams.get('stigId');\n        if (!stigId) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'stigId parameter is required'\n            }, {\n                status: 400\n            });\n        }\n        // üéØ PRIORITY 1: Check local STIG library first\n        console.log(`üîç Checking local STIG library for: ${stigId}`);\n        if ((0,_utils_localStigLibrary__WEBPACK_IMPORTED_MODULE_2__.hasLocalStig)(stigId)) {\n            console.log(`‚úÖ Found STIG in local library: ${stigId}`);\n            try {\n                const metadata = (0,_utils_localStigLibrary__WEBPACK_IMPORTED_MODULE_2__.getLocalStigMetadata)(stigId);\n                const content = (0,_utils_localStigLibrary__WEBPACK_IMPORTED_MODULE_2__.getLocalStigContent)(stigId);\n                if (content && metadata) {\n                    console.log(`üìÑ Reading local STIG file: ${metadata.filename}`);\n                    // Determine format and parse accordingly\n                    const isXml = metadata.format === 'xml' || metadata.filename.toLowerCase().endsWith('.xml');\n                    if (isXml) {\n                        console.log(`üîÑ Parsing local XML file...`);\n                        const stigData = parseXccdfXml(content, stigId);\n                        if (stigData.requirements.length > 0) {\n                            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                                success: true,\n                                ...stigData,\n                                version: metadata.version,\n                                releaseDate: metadata.releaseDate,\n                                source: 'local',\n                                message: `‚úÖ Successfully imported ${stigData.requirements.length} requirements from local library (${metadata.filename})`\n                            });\n                        }\n                    } else {\n                        console.log(`üîÑ Parsing local CSV file...`);\n                        const stigData = parseStigCsv(content, stigId);\n                        if (stigData.requirements.length > 0) {\n                            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                                success: true,\n                                ...stigData,\n                                stigName: metadata.name,\n                                version: metadata.version,\n                                releaseDate: metadata.releaseDate,\n                                source: 'local',\n                                message: `‚úÖ Successfully imported ${stigData.requirements.length} requirements from local library (${metadata.filename})`\n                            });\n                        }\n                    }\n                }\n            } catch (localError) {\n                console.error(`‚ùå Error reading local STIG: ${localError.message}`);\n            // Continue to stigviewer.com fallback\n            }\n        } else {\n            console.log(`‚ÑπÔ∏è STIG not found in local library, will try stigviewer.com`);\n        }\n        // üåê FALLBACK: Try stigviewer.com\n        console.log(`üîç Fetching STIG from stigviewer.com: ${stigId}`);\n        // Try JSON API first (has complete severity data)\n        const jsonUrl = `https://stigviewer.com/stigs/${stigId}/json`;\n        const htmlUrl = `https://stigviewer.com/stigs/${stigId}/`;\n        // Create custom agent to bypass SSL certificate validation\n        const agent = new (https__WEBPACK_IMPORTED_MODULE_1___default().Agent)({\n            rejectUnauthorized: false\n        });\n        try {\n            // Attempt JSON API first\n            console.log(`üì• Attempting JSON API...`);\n            const jsonResponse = await fetch(jsonUrl, {\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n                    'Accept': 'application/json, text/html, */*',\n                    'Accept-Language': 'en-US,en;q=0.9',\n                    'Accept-Encoding': 'gzip, deflate, br',\n                    'Referer': 'https://stigviewer.com/',\n                    'Connection': 'keep-alive',\n                    'Cache-Control': 'no-cache',\n                    'Pragma': 'no-cache'\n                },\n                // @ts-ignore\n                agent,\n                signal: AbortSignal.timeout(15000)\n            });\n            if (jsonResponse.ok) {\n                const jsonData = await jsonResponse.json();\n                console.log(`‚úÖ JSON API successful`);\n                const stigData = parseStigViewerJson(jsonData, stigId);\n                if (stigData.requirements.length > 0) {\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        success: true,\n                        ...stigData,\n                        source: 'stigviewer',\n                        message: `Successfully imported ${stigData.requirements.length} requirements from JSON API`\n                    });\n                }\n            } else {\n                console.log(`‚ö†Ô∏è JSON API returned ${jsonResponse.status}: ${jsonResponse.statusText}`);\n            }\n        } catch (jsonError) {\n            console.log(`‚ö†Ô∏è JSON API failed: ${jsonError.message}, trying HTML...`);\n        }\n        // Fallback to HTML parsing\n        try {\n            console.log(`üì• Attempting HTML parsing...`);\n            // Add a small delay to avoid rate limiting\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n            const response = await fetch(htmlUrl, {\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',\n                    'Accept-Language': 'en-US,en;q=0.9',\n                    'Accept-Encoding': 'gzip, deflate, br',\n                    'Referer': 'https://stigviewer.com/',\n                    'Connection': 'keep-alive',\n                    'Cache-Control': 'no-cache',\n                    'Pragma': 'no-cache',\n                    'Sec-Fetch-Dest': 'document',\n                    'Sec-Fetch-Mode': 'navigate',\n                    'Sec-Fetch-Site': 'same-origin',\n                    'Upgrade-Insecure-Requests': '1'\n                },\n                // @ts-ignore\n                agent,\n                signal: AbortSignal.timeout(15000)\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            const html = await response.text();\n            // Parse STIG information from HTML\n            const stigData = await parseStigViewerHtml(html, stigId);\n            if (stigData.requirements.length === 0) {\n                throw new Error('No requirements found in STIG data');\n            }\n            console.log(`‚úÖ Successfully fetched ${stigData.requirements.length} requirements from stigviewer.com`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: true,\n                ...stigData,\n                source: 'stigviewer',\n                message: `Successfully imported ${stigData.requirements.length} requirements from stigviewer.com`\n            });\n        } catch (fetchError) {\n            console.error('‚ùå Error fetching from stigviewer.com:', fetchError.message);\n            // Provide specific guidance based on error type\n            let errorGuidance = 'Failed to fetch from stigviewer.com. Please try again or upload STIG manually.';\n            if (fetchError.message.includes('403') || fetchError.message.includes('Forbidden')) {\n                errorGuidance = 'stigviewer.com is blocking automated requests (403 Forbidden). This may be due to rate limiting or access restrictions. Please wait a few minutes and try again, or download and upload the STIG manually.';\n            } else if (fetchError.message.includes('timeout')) {\n                errorGuidance = 'Request timed out. The server may be slow or unavailable. Please try again.';\n            }\n            // Return error with instructions for manual upload\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                stigId,\n                error: fetchError.message,\n                message: errorGuidance,\n                instructions: {\n                    step1: 'Download STIG XML from DISA Cyber Exchange: https://public.cyber.mil/stigs/downloads/',\n                    step2: 'Or download from STIGViewer: https://stigviewer.com/stigs',\n                    step3: 'Upload the XCCDF XML file using the manual upload option'\n                }\n            }, {\n                status: 503\n            });\n        }\n    } catch (error) {\n        console.error('‚ùå Error in STIG import:', error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error.message,\n            message: 'An error occurred while importing STIG'\n        }, {\n            status: 500\n        });\n    }\n}\n/**\r\n * Parse DISA STIG CSV file\r\n * CSV format from DISA Cyber Exchange\r\n */ function parseStigCsv(csvContent, fileName) {\n    const requirements = [];\n    // Properly split CSV content into lines, handling multi-line quoted fields\n    const lines = [];\n    let currentLine = '';\n    let insideQuotes = false;\n    for(let i = 0; i < csvContent.length; i++){\n        const char = csvContent[i];\n        const nextChar = csvContent[i + 1];\n        if (char === '\"') {\n            // Check if it's an escaped quote\n            if (nextChar === '\"') {\n                currentLine += char + nextChar;\n                i++; // Skip next quote\n            } else {\n                insideQuotes = !insideQuotes;\n                currentLine += char;\n            }\n        } else if (char === '\\n' && !insideQuotes) {\n            if (currentLine.trim()) {\n                lines.push(currentLine);\n            }\n            currentLine = '';\n        } else if (char === '\\r') {\n            continue;\n        } else {\n            currentLine += char;\n        }\n    }\n    // Add the last line if not empty\n    if (currentLine.trim()) {\n        lines.push(currentLine);\n    }\n    console.log(`üìÑ Split CSV into ${lines.length} lines`);\n    if (lines.length < 2) {\n        return {\n            stigId: fileName.replace(/\\.csv$/i, ''),\n            stigName: 'Imported STIG',\n            version: 'Unknown',\n            releaseDate: new Date().toISOString().split('T')[0],\n            requirements: [],\n            totalRequirements: 0\n        };\n    }\n    // Parse header row - handle quoted CSV fields\n    const parseCSVLine = (line)=>{\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        for(let i = 0; i < line.length; i++){\n            const char = line[i];\n            const nextChar = line[i + 1];\n            if (char === '\"') {\n                if (inQuotes && nextChar === '\"') {\n                    // Escaped quote\n                    current += '\"';\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                }\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        return result;\n    };\n    // Find the header row (skip classification banners like \"~~~~~~~ Unclassified ~~~~~~\")\n    let headerLineIndex = 0;\n    let headers = [];\n    for(let i = 0; i < Math.min(5, lines.length); i++){\n        const parsedLine = parseCSVLine(lines[i]);\n        const lineText = parsedLine.join('').toLowerCase();\n        // Skip classification banners and empty lines\n        if (lineText.includes('unclassified') || lineText.includes('~~~~~') || parsedLine.length < 5) {\n            continue;\n        }\n        // Check if this looks like a header row (has common STIG column names)\n        if (lineText.includes('stig') || lineText.includes('severity') || lineText.includes('rule')) {\n            headerLineIndex = i;\n            headers = parsedLine.map((h)=>h.toLowerCase().trim());\n            console.log(`üìã Found header row at line ${i + 1}`);\n            break;\n        }\n    }\n    if (headers.length === 0) {\n        console.error('‚ùå Could not find valid header row in CSV');\n        return {\n            stigId: fileName.replace(/\\.csv$/i, ''),\n            stigName: 'Imported STIG',\n            version: 'Unknown',\n            releaseDate: new Date().toISOString().split('T')[0],\n            requirements: [],\n            totalRequirements: 0\n        };\n    }\n    console.log(`üìã CSV Headers found: ${headers.slice(0, 10).join(', ')}...`);\n    console.log(`üìã All headers (first 15):`, headers.slice(0, 15));\n    // Find column indices\n    const getIndex = (names)=>{\n        for (const name of names){\n            const idx = headers.findIndex((h)=>h.includes(name));\n            if (idx !== -1) {\n                console.log(`‚úÖ Found \"${name}\" at index ${idx}: \"${headers[idx]}\"`);\n                return idx;\n            }\n        }\n        console.log(`‚ùå Could not find any of: ${names.join(', ')}`);\n        return -1;\n    };\n    const stigIdIdx = getIndex([\n        'stig id',\n        'stigid'\n    ]);\n    const severityIdx = getIndex([\n        'severity'\n    ]);\n    const titleIdx = getIndex([\n        'rule title',\n        'ruletitle'\n    ]);\n    const discussionIdx = getIndex([\n        'discussion'\n    ]);\n    const checkIdx = getIndex([\n        'check content',\n        'checkcontent'\n    ]);\n    const fixIdx = getIndex([\n        'fix text',\n        'fixtext'\n    ]);\n    const cciIdx = getIndex([\n        'ccis',\n        'cci'\n    ]);\n    const ruleIdIdx = getIndex([\n        'rule id',\n        'ruleid'\n    ]);\n    console.log(`üìä Column indices:`, {\n        stigId: stigIdIdx,\n        severity: severityIdx,\n        title: titleIdx,\n        discussion: discussionIdx,\n        check: checkIdx,\n        fix: fixIdx,\n        cci: cciIdx,\n        ruleId: ruleIdIdx\n    });\n    let stigName = 'Imported STIG';\n    let version = 'Unknown';\n    console.log(`üìÑ Processing ${lines.length - headerLineIndex - 1} data rows from CSV`);\n    // Parse data rows (start after header row)\n    for(let i = headerLineIndex + 1; i < lines.length; i++){\n        const line = lines[i].trim();\n        if (!line) continue;\n        const values = parseCSVLine(line);\n        if (i === headerLineIndex + 1) {\n            console.log(`üìù First data row has ${values.length} values`);\n        }\n        // Extract STIG name from first data row if available\n        if (i === headerLineIndex + 1 && values.length > 0) {\n            const benchmarkIdx = headers.findIndex((h)=>h.includes('benchmark'));\n            if (benchmarkIdx !== -1 && values[benchmarkIdx]) {\n                stigName = values[benchmarkIdx];\n            }\n            const versionIdx = headers.findIndex((h)=>h.includes('version') || h.includes('release'));\n            if (versionIdx !== -1 && values[versionIdx]) {\n                version = values[versionIdx];\n            }\n        }\n        const vulnId = stigIdIdx !== -1 ? values[stigIdIdx] : '';\n        const ruleId = ruleIdIdx !== -1 ? values[ruleIdIdx] : vulnId;\n        if (!vulnId) {\n            if (i <= headerLineIndex + 3) {\n                console.log(`‚ö†Ô∏è Line ${i}: No STIG ID found`);\n            }\n            continue;\n        }\n        if (i === headerLineIndex + 1) {\n            console.log(`‚úÖ First requirement found: ${vulnId}`);\n        }\n        // Parse severity - handle multiple formats\n        const severityValue = severityIdx !== -1 ? values[severityIdx].toLowerCase().trim() : 'medium';\n        let severity = 'medium';\n        // Direct severity values\n        if (severityValue === 'high' || severityValue.includes('cat i') || severityValue.includes('cat 1') || severityValue.includes('cati')) {\n            severity = 'high';\n        } else if (severityValue === 'low' || severityValue.includes('cat iii') || severityValue.includes('cat 3') || severityValue.includes('catiii')) {\n            severity = 'low';\n        } else if (severityValue === 'medium' || severityValue.includes('cat ii') || severityValue.includes('cat 2') || severityValue.includes('catii')) {\n            severity = 'medium';\n        }\n        // Log first few for debugging\n        if (i <= headerLineIndex + 3) {\n            console.log(`üìä Row ${i - headerLineIndex}: vulnId=\"${vulnId}\", severity=\"${severityValue}\" ‚Üí ${severity}`);\n        }\n        // Extract CCI references\n        const cciText = cciIdx !== -1 ? values[cciIdx] : '';\n        const cciMatches = cciText.match(/CCI-\\d+/g);\n        const cci = cciMatches || [\n            'CCI-000366'\n        ];\n        requirements.push({\n            vulnId,\n            ruleId,\n            severity,\n            title: titleIdx !== -1 ? values[titleIdx] : `Requirement ${vulnId}`,\n            description: discussionIdx !== -1 ? values[discussionIdx] : 'No description provided',\n            checkText: checkIdx !== -1 ? values[checkIdx] : 'Review system configuration per STIG guidance.',\n            fixText: fixIdx !== -1 ? values[fixIdx] : 'Configure system per STIG guidance.',\n            cci,\n            nistControls: []\n        });\n    }\n    console.log(`‚úÖ CSV parsing complete: ${requirements.length} requirements found`);\n    return {\n        stigId: fileName.replace(/\\.csv$/i, ''),\n        stigName,\n        version,\n        releaseDate: new Date().toISOString().split('T')[0],\n        requirements,\n        totalRequirements: requirements.length\n    };\n}\n/**\r\n * POST - Manual STIG upload (XML or CSV file)\r\n * Body: FormData with 'file' field containing XCCDF XML or DISA CSV\r\n */ async function POST(request) {\n    try {\n        const formData = await request.formData();\n        const file = formData.get('file');\n        if (!file) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'No file provided'\n            }, {\n                status: 400\n            });\n        }\n        // Validate file type\n        const fileName = file.name.toLowerCase();\n        const isXml = fileName.endsWith('.xml') || fileName.endsWith('.xccdf');\n        const isCsv = fileName.endsWith('.csv');\n        if (!isXml && !isCsv) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Invalid file type. Please upload an XCCDF XML file or DISA CSV file.'\n            }, {\n                status: 400\n            });\n        }\n        console.log(`üìÅ Processing manual STIG upload: ${file.name}`);\n        // Read file content\n        const fileContent = await file.text();\n        let stigData;\n        if (isCsv) {\n            // Parse CSV file\n            stigData = parseStigCsv(fileContent, fileName);\n        } else {\n            // Parse XCCDF XML\n            stigData = parseXccdfXml(fileContent, fileName);\n        }\n        if (stigData.requirements.length === 0) {\n            throw new Error(`No requirements found in ${isCsv ? 'CSV' : 'XML'} file. Please ensure this is a valid DISA STIG file.`);\n        }\n        console.log(`‚úÖ Successfully parsed ${stigData.requirements.length} requirements from manual upload`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            ...stigData,\n            source: 'manual',\n            message: `Successfully imported ${stigData.requirements.length} requirements from ${file.name}`\n        });\n    } catch (error) {\n        console.error('‚ùå Error processing manual upload:', error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error.message,\n            message: 'Failed to parse STIG file. Please ensure this is a valid XCCDF XML file.'\n        }, {\n            status: 500\n        });\n    }\n}\n/**\r\n * Fetch detailed requirement page from stigviewer.com\r\n * Returns check and fix text for a specific vulnerability\r\n */ async function fetchRequirementDetails(stigId, vulnId) {\n    try {\n        const agent = new (https__WEBPACK_IMPORTED_MODULE_1___default().Agent)({\n            rejectUnauthorized: false\n        });\n        const url = `https://stigviewer.com/stig/${stigId}/requirement/${vulnId}`;\n        const response = await fetch(url, {\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            },\n            // @ts-ignore\n            agent,\n            signal: AbortSignal.timeout(10000)\n        });\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}`);\n        }\n        const html = await response.text();\n        // Extract check text\n        const checkMatch = html.match(/<div[^>]*(?:id|class)=\"[^\"]*check[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i) || html.match(/Check Text[:\\s]*<[^>]*>([\\s\\S]*?)<\\/(?:div|pre|p)>/i) || html.match(/<pre[^>]*>([\\s\\S]*?)<\\/pre>/i);\n        const checkText = checkMatch ? checkMatch[1].replace(/<[^>]+>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '\"').replace(/\\s+/g, ' ').trim() : 'Review the system configuration to verify compliance with the security requirement.';\n        // Extract fix text  \n        const fixMatch = html.match(/<div[^>]*(?:id|class)=\"[^\"]*fix[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i) || html.match(/Fix Text[:\\s]*<[^>]*>([\\s\\S]*?)<\\/(?:div|pre|p)>/i);\n        const fixText = fixMatch ? fixMatch[1].replace(/<[^>]+>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '\"').replace(/\\s+/g, ' ').trim() : 'Configure the system to meet the security requirement as specified in the STIG documentation.';\n        return {\n            checkText,\n            fixText\n        };\n    } catch (error) {\n        // Return defaults if fetch fails\n        return {\n            checkText: 'Review the system configuration to verify compliance with the security requirement. Detailed check procedure available in the full STIG documentation.',\n            fixText: 'Configure the system to meet the security requirement. Detailed fix procedure available in the full STIG documentation.'\n        };\n    }\n}\n/**\r\n * Parse stig viewer.com JSON API response\r\n * JSON format has complete data including severity for each requirement\r\n */ function parseStigViewerJson(jsonData, stigId) {\n    const requirements = [];\n    try {\n        const stig = jsonData.stig || jsonData;\n        const stigName = stig.title || stigId;\n        const version = stig.version || 'Unknown';\n        const releaseDate = stig.date || new Date().toISOString().split('T')[0];\n        console.log(`üìã Parsing JSON: ${stigName}, Version: ${version}, Release: ${releaseDate}`);\n        const findings = stig.findings || {};\n        const vulnIds = Object.keys(findings);\n        console.log(`üîç Found ${vulnIds.length} requirements in JSON`);\n        vulnIds.forEach((vulnId)=>{\n            const finding = findings[vulnId];\n            if (!finding) return;\n            // Extract severity from finding\n            // JSON might have severity as \"high\", \"medium\", \"low\" or \"CAT I\", \"CAT II\", \"CAT III\"\n            let severity = 'medium';\n            const sevText = (finding.severity || finding.cat || 'medium').toString().toLowerCase();\n            if (sevText.includes('high') || sevText.includes('cat i') || sevText === 'i' || sevText === '1') {\n                severity = 'high';\n            } else if (sevText.includes('low') || sevText.includes('cat iii') || sevText === 'iii' || sevText === '3') {\n                severity = 'low';\n            } else {\n                severity = 'medium';\n            }\n            requirements.push({\n                vulnId,\n                ruleId: finding.ruleId || finding.rule_id || finding.ruleid || `${vulnId}-rule`,\n                severity,\n                title: finding.title || finding.ruleTitle || finding.ruletitle || `Requirement ${vulnId}`,\n                description: finding.discussion || finding.description || finding.title || '',\n                checkText: finding.checktext || finding.checkText || finding.check_text || finding.check || 'Review system configuration per STIG guidance.',\n                fixText: finding.fixtext || finding.fixText || finding.fix_text || finding.fix || 'Configure system per STIG guidance.',\n                cci: finding.cci || finding.ccis || [\n                    'CCI-000366'\n                ],\n                nistControls: finding.nistControls || finding.nist || []\n            });\n        });\n        console.log(`‚úÖ Successfully parsed ${requirements.length} requirements from JSON`);\n        // Log severity distribution\n        const severityDist = {};\n        requirements.forEach((req)=>{\n            severityDist[req.severity] = (severityDist[req.severity] || 0) + 1;\n        });\n        console.log(`üìä JSON Severity Distribution:`, severityDist);\n        return {\n            stigId,\n            stigName,\n            version,\n            releaseDate,\n            requirements,\n            totalRequirements: requirements.length\n        };\n    } catch (error) {\n        console.error('Error parsing stigviewer.com JSON:', error);\n        throw new Error(`Failed to parse stigviewer.com JSON: ${error.message}`);\n    }\n}\n/**\r\n * Parse stigviewer.com HTML to extract STIG requirements\r\n * Fetches full requirement details including check and fix text\r\n */ async function parseStigViewerHtml(html, stigId) {\n    const requirements = [];\n    try {\n        // Extract STIG metadata from page title and headers\n        const titleMatch = html.match(/<title>([^<]+)<\\/title>/i);\n        const stigName = titleMatch ? titleMatch[1].replace(' | STIGViewer', '').trim() : stigId;\n        // Extract version from page\n        const versionMatch = html.match(/Version[:\\s]+([VvRr\\d.]+)/i) || html.match(/class=\"[^\"]*version[^\"]*\"[^>]*>([^<]+)</i);\n        const version = versionMatch ? versionMatch[1].trim() : 'Unknown';\n        // Extract release date\n        const dateMatch = html.match(/Release[:\\s]+(\\d{1,2}\\s+\\w+\\s+\\d{4})/i) || html.match(/Date[:\\s]+(\\d{4}-\\d{2}-\\d{2})/i) || html.match(/(\\d{4}-\\d{2}-\\d{2})/);\n        const releaseDate = dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0];\n        console.log(`üìã Parsing STIG: ${stigName}, Version: ${version}, Release: ${releaseDate}`);\n        // Method 1: Extract complete requirement entries with all details\n        // stigviewer.com has links like: href=\"/stig/{stigId}/requirement/V-#####\"\n        // Pattern to match entire requirement sections with severity info\n        const reqSectionPattern = /(?:CAT\\s+(I{1,3})|severity[^>]*?(high|medium|low))[^V]*(V-\\d+)[^<]*<a[^>]*href=\"[^\"]*\\/requirement\\/\\3\"[^>]*>([^<]+)</gi;\n        let match;\n        const detailedReqs = [];\n        while((match = reqSectionPattern.exec(html)) !== null){\n            const severity = match[1] || match[2]; // CAT I/II/III or high/medium/low\n            const vulnId = match[3];\n            const title = match[4].trim();\n            detailedReqs.push({\n                vulnId,\n                severity,\n                title\n            });\n        }\n        console.log(`üîç Method 1: Found ${detailedReqs.length} requirements with severity info`);\n        // Method 2: Extract from table rows if available\n        const tableRows = [];\n        const rowPattern = /<tr[^>]*>([\\s\\S]*?)<\\/tr>/gi;\n        let rowMatch;\n        while((rowMatch = rowPattern.exec(html)) !== null){\n            const rowHtml = rowMatch[1];\n            // Check if this row has a vuln ID\n            const vulnMatch = rowHtml.match(/>(V-\\d+)</);\n            if (!vulnMatch) continue;\n            const vulnId = vulnMatch[1];\n            // Extract severity from this row\n            const catMatch = rowHtml.match(/CAT\\s+(I{1,3})/i);\n            const sevMatch = rowHtml.match(/>(high|medium|low)</i);\n            const severity = catMatch ? catMatch[1] : sevMatch ? sevMatch[1] : 'II';\n            // Extract title\n            const titleMatch = rowHtml.match(/<a[^>]*href=\"[^\"]*\\/requirement\\/[^\"]*\"[^>]*>([^<]+)</i);\n            const title = titleMatch ? titleMatch[1].trim() : `Requirement ${vulnId}`;\n            tableRows.push({\n                vulnId,\n                severity,\n                title\n            });\n        }\n        console.log(`üîç Method 2: Found ${tableRows.length} requirements from table rows`);\n        // Method 3: Fallback - extract all V-#### with default data\n        const vulnIdPattern = /V-\\d+/g;\n        const allVulnIds = [\n            ...new Set(html.match(vulnIdPattern) || [])\n        ];\n        console.log(`üîç Method 3: Found ${allVulnIds.length} total V-#### patterns`);\n        // Use the method that found the most requirements\n        let reqData = [];\n        if (detailedReqs.length >= tableRows.length && detailedReqs.length > 0) {\n            reqData = detailedReqs;\n            console.log(`‚úì Using Method 1: ${detailedReqs.length} requirements with severity`);\n        } else if (tableRows.length > 0) {\n            reqData = tableRows;\n            console.log(`‚úì Using Method 2: ${tableRows.length} requirements from tables`);\n        } else {\n            // Fallback: create basic entries\n            reqData = allVulnIds.map((vulnId)=>({\n                    vulnId,\n                    severity: 'II',\n                    title: `${stigName} - ${vulnId}`\n                }));\n            console.log(`‚úì Using Method 3: ${allVulnIds.length} basic requirements`);\n        }\n        console.log(`üìù Processing ${reqData.length} requirements...`);\n        let requirementCount = 0;\n        for (const req of reqData){\n            const { vulnId, severity: rawSeverity, title } = req;\n            // Extract Rule ID if available\n            const rulePattern = new RegExp(`${vulnId}[^S]*?(SV-\\\\d+r\\\\d+_rule)`, 'i');\n            const ruleMatch = html.match(rulePattern);\n            const ruleId = ruleMatch ? ruleMatch[1] : `${vulnId}-rule`;\n            // Normalize severity\n            let severity = 'medium';\n            const sevText = rawSeverity.toLowerCase();\n            if (sevText.includes('i') && !sevText.includes('ii') || sevText === 'high' || sevText === '1') {\n                severity = 'high';\n            } else if (sevText.includes('iii') || sevText === 'low' || sevText === '3') {\n                severity = 'low';\n            } else {\n                severity = 'medium';\n            }\n            // Description defaults to title\n            const description = title;\n            // Extract CCI references - search for this vulnId in HTML\n            const vulnContext = html.substring(Math.max(0, html.indexOf(vulnId) - 300), Math.min(html.length, html.indexOf(vulnId) + 300));\n            const cciMatches = vulnContext.match(/CCI-\\d+/g);\n            const cci = cciMatches && cciMatches.length > 0 ? [\n                ...new Set(cciMatches)\n            ] : [\n                'CCI-000366'\n            ];\n            // Default check and fix text with note about full documentation\n            const checkText = `Review the system configuration to verify compliance with ${vulnId}. Refer to the full STIG documentation for detailed check procedures.`;\n            const fixText = `Configure the system to meet the requirements specified in ${vulnId}. Refer to the full STIG documentation for detailed fix procedures.`;\n            // Extract NIST controls from context\n            const nistMatches = vulnContext.match(/([A-Z]{2}-\\d+(?:\\s*\\([a-z0-9]+\\))?)/g);\n            const nistControls = nistMatches ? [\n                ...new Set(nistMatches)\n            ] : [];\n            requirements.push({\n                vulnId,\n                ruleId,\n                severity,\n                title,\n                description,\n                checkText,\n                fixText,\n                cci,\n                nistControls\n            });\n            requirementCount++;\n        }\n        console.log(`‚úÖ Successfully parsed ${requirementCount} requirements from HTML`);\n        // Log severity distribution\n        const severityDist = {};\n        requirements.forEach((req)=>{\n            severityDist[req.severity] = (severityDist[req.severity] || 0) + 1;\n        });\n        console.log(`üìä API Severity Distribution:`, severityDist);\n        // If we didn't find any requirements in table format, try alternative parsing\n        if (requirements.length === 0) {\n            console.warn('‚ö†Ô∏è No requirements found in table format, trying alternative parsing...');\n            // Try to find all V-#### patterns and create basic requirements\n            const vulnIdPattern = /V-\\d+/g;\n            const vulnIds = [\n                ...new Set(html.match(vulnIdPattern) || [])\n            ];\n            vulnIds.forEach((vulnId, index)=>{\n                requirements.push({\n                    vulnId,\n                    ruleId: `${vulnId}-rule`,\n                    severity: 'medium',\n                    title: `${stigName} - ${vulnId}`,\n                    description: `Security requirement ${vulnId} from ${stigName}`,\n                    checkText: 'Review the system configuration to verify compliance. Detailed check procedure available in the full STIG documentation.',\n                    fixText: 'Configure the system to meet the security requirement. Detailed fix procedure available in the full STIG documentation.',\n                    cci: [\n                        'CCI-000366'\n                    ],\n                    nistControls: []\n                });\n            });\n            console.log(`üìù Created ${requirements.length} basic requirements from Vuln IDs`);\n        }\n        return {\n            stigId,\n            stigName,\n            version,\n            releaseDate,\n            requirements,\n            totalRequirements: requirements.length\n        };\n    } catch (error) {\n        console.error('Error parsing stigviewer.com HTML:', error);\n        throw new Error(`Failed to parse stigviewer.com page: ${error.message}`);\n    }\n}\n/**\r\n * Parse XCCDF XML file to extract STIG requirements\r\n */ function parseXccdfXml(xmlContent, fileName) {\n    const requirements = [];\n    try {\n        // Extract STIG ID from filename\n        const stigId = fileName.replace(/\\.xml|\\.xccdf/gi, '').toLowerCase().replace(/\\s+/g, '_');\n        // Parse XML using regex (simplified - in production use a proper XML parser)\n        // Extract Benchmark title\n        const titleMatch = xmlContent.match(/<title[^>]*>([^<]+)<\\/title>/i);\n        const stigName = titleMatch ? titleMatch[1].trim() : stigId;\n        // Extract version\n        const versionMatch = xmlContent.match(/<version[^>]*>([^<]+)<\\/version>/i) || xmlContent.match(/Version[:\\s]+([VvRr\\d.]+)/i);\n        const version = versionMatch ? versionMatch[1] : 'Unknown';\n        // Extract release date\n        const dateMatch = xmlContent.match(/release-date[^>]*>([^<]+)</i) || xmlContent.match(/(\\d{1,2}\\s+\\w+\\s+\\d{4})/);\n        const releaseDate = dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0];\n        // Extract all Group elements (requirements)\n        const groupPattern = /<Group[^>]*id=\"([^\"]+)\"[^>]*>([\\s\\S]*?)<\\/Group>/gi;\n        let groupMatch;\n        while((groupMatch = groupPattern.exec(xmlContent)) !== null){\n            const groupId = groupMatch[1];\n            const groupContent = groupMatch[2];\n            // Extract Rule from Group\n            const ruleMatch = groupContent.match(/<Rule[^>]*id=\"([^\"]+)\"[^>]*severity=\"([^\"]+)\"[^>]*>([\\s\\S]*?)<\\/Rule>/i);\n            if (ruleMatch) {\n                const ruleId = ruleMatch[1];\n                const severity = ruleMatch[2].toLowerCase();\n                const ruleContent = ruleMatch[3];\n                // Extract title\n                const titleMatch = ruleContent.match(/<title[^>]*>([^<]+)<\\/title>/i);\n                const title = titleMatch ? titleMatch[1].trim() : `Requirement ${groupId}`;\n                // Extract description\n                const descMatch = ruleContent.match(/<description[^>]*>([\\s\\S]*?)<\\/description>/i);\n                const description = descMatch ? stripHtml(descMatch[1]) : '';\n                // Extract check text\n                const checkMatch = ruleContent.match(/<check-content[^>]*>([\\s\\S]*?)<\\/check-content>/i);\n                const checkText = checkMatch ? stripHtml(checkMatch[1]) : 'No check procedure provided';\n                // Extract fix text\n                const fixMatch = ruleContent.match(/<fixtext[^>]*>([\\s\\S]*?)<\\/fixtext>/i);\n                const fixText = fixMatch ? stripHtml(fixMatch[1]) : 'No fix procedure provided';\n                // Extract CCI references\n                const cciPattern = /<ident[^>]*system=\"http:\\/\\/cyber\\.mil\\/legacy\\/cci\"[^>]*>([^<]+)<\\/ident>/gi;\n                const cci = [];\n                let cciMatch;\n                while((cciMatch = cciPattern.exec(ruleContent)) !== null){\n                    cci.push(cciMatch[1]);\n                }\n                // Extract NIST controls\n                const nistPattern = /<reference[^>]*>([\\s\\S]*?)NIST[^<]*([A-Z]{2}-\\d+(?:\\s*\\(\\d+\\))?(?:\\s*[a-z])?)[^<]*([\\s\\S]*?)<\\/reference>/gi;\n                const nistControls = [];\n                let nistMatch;\n                while((nistMatch = nistPattern.exec(ruleContent)) !== null){\n                    const control = nistMatch[2].trim();\n                    if (control && !nistControls.includes(control)) {\n                        nistControls.push(control);\n                    }\n                }\n                requirements.push({\n                    vulnId: groupId,\n                    ruleId,\n                    severity,\n                    title,\n                    description: description.substring(0, 500),\n                    checkText: checkText.substring(0, 1000),\n                    fixText: fixText.substring(0, 1000),\n                    cci: cci.length > 0 ? cci : [\n                        'CCI-000000'\n                    ],\n                    nistControls: nistControls.length > 0 ? nistControls : [\n                        'AC-1'\n                    ]\n                });\n            }\n        }\n        if (requirements.length === 0) {\n            throw new Error('No requirements found in XML. The file may not be a valid XCCDF STIG file.');\n        }\n        return {\n            stigId,\n            stigName,\n            version,\n            releaseDate,\n            requirements,\n            totalRequirements: requirements.length\n        };\n    } catch (error) {\n        console.error('Error parsing XCCDF XML:', error);\n        throw new Error(`Failed to parse XCCDF XML: ${error.message}`);\n    }\n}\n/**\r\n * Strip HTML tags and decode entities\r\n */ function stripHtml(html) {\n    return html.replace(/<[^>]+>/g, '') // Remove HTML tags\n    .replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '\"').replace(/&#39;/g, \"'\").replace(/&nbsp;/g, ' ').replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNuQkEsT0FBTyxDQUFDLFFBQVEsS0FBSyx1QkFBdUI7S0FDNUNGLElBQUk7QUFDVCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxyb25uaVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2plY3RzXFxTUlRNLXRvb2xcXGFwcFxcYXBpXFxpbXBvcnQtc3RpZ1xccm91dGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcclxuaW1wb3J0IHsgaGFzTG9jYWxTdGlnLCBnZXRMb2NhbFN0aWdDb250ZW50LCBnZXRMb2NhbFN0aWdNZXRhZGF0YSB9IGZyb20gJ0AvdXRpbHMvbG9jYWxTdGlnTGlicmFyeSc7XHJcblxyXG4vKipcclxuICogU1RJRyBJbXBvcnQgQVBJXHJcbiAqIFByaW9yaXR5IG9yZGVyOlxyXG4gKiAxLiBDaGVjayBsb2NhbCBTVElHIGxpYnJhcnkgKC9wdWJsaWMvc3RpZ3MvKVxyXG4gKiAyLiBGYWxsYmFjayB0byBzdGlndmlld2VyLmNvbVxyXG4gKiAzLiBBY2NlcHQgbWFudWFsIHVwbG9hZFxyXG4gKiBcclxuICogTm90ZTogc3RpZ3ZpZXdlci5jb20gaGFzIFNTTCBjZXJ0aWZpY2F0ZSBpc3N1ZXMsIHNvIHdlIGJ5cGFzcyBjZXJ0IHZhbGlkYXRpb25cclxuICovXHJcblxyXG5pbnRlcmZhY2UgU3RpZ1JlcXVpcmVtZW50IHtcclxuICB2dWxuSWQ6IHN0cmluZztcclxuICBydWxlSWQ6IHN0cmluZztcclxuICBzZXZlcml0eTogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgY2hlY2tUZXh0OiBzdHJpbmc7XHJcbiAgZml4VGV4dDogc3RyaW5nO1xyXG4gIGNjaTogc3RyaW5nW107XHJcbiAgbmlzdENvbnRyb2xzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFN0aWdJbXBvcnRSZXN1bHQge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgc3RpZ0lkOiBzdHJpbmc7XHJcbiAgc3RpZ05hbWU6IHN0cmluZztcclxuICB2ZXJzaW9uOiBzdHJpbmc7XHJcbiAgcmVsZWFzZURhdGU6IHN0cmluZztcclxuICByZXF1aXJlbWVudHM6IFN0aWdSZXF1aXJlbWVudFtdO1xyXG4gIHRvdGFsUmVxdWlyZW1lbnRzOiBudW1iZXI7XHJcbiAgc291cmNlOiAnc3RpZ3ZpZXdlcicgfCAnbWFudWFsJyB8ICdjYWNoZScgfCAnbG9jYWwnO1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmc7XHJcbiAgZXJyb3I/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHRVQgLSBGZXRjaCBTVElHIGZyb20gbG9jYWwgbGlicmFyeSBvciBzdGlndmlld2VyLmNvbVxyXG4gKiBRdWVyeSBwYXJhbXM6IHN0aWdJZCAoZS5nLiwgJ2FwYWNoZV9zZXJ2ZXJfMi40X3VuaXgnKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XHJcbiAgICBjb25zdCBzdGlnSWQgPSBzZWFyY2hQYXJhbXMuZ2V0KCdzdGlnSWQnKTtcclxuXHJcbiAgICBpZiAoIXN0aWdJZCkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBlcnJvcjogJ3N0aWdJZCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8g8J+OryBQUklPUklUWSAxOiBDaGVjayBsb2NhbCBTVElHIGxpYnJhcnkgZmlyc3RcclxuICAgIGNvbnNvbGUubG9nKGDwn5SNIENoZWNraW5nIGxvY2FsIFNUSUcgbGlicmFyeSBmb3I6ICR7c3RpZ0lkfWApO1xyXG4gICAgXHJcbiAgICBpZiAoaGFzTG9jYWxTdGlnKHN0aWdJZCkpIHtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBTVElHIGluIGxvY2FsIGxpYnJhcnk6ICR7c3RpZ0lkfWApO1xyXG4gICAgICBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGdldExvY2FsU3RpZ01ldGFkYXRhKHN0aWdJZCk7XHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IGdldExvY2FsU3RpZ0NvbnRlbnQoc3RpZ0lkKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY29udGVudCAmJiBtZXRhZGF0YSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfk4QgUmVhZGluZyBsb2NhbCBTVElHIGZpbGU6ICR7bWV0YWRhdGEuZmlsZW5hbWV9YCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIERldGVybWluZSBmb3JtYXQgYW5kIHBhcnNlIGFjY29yZGluZ2x5XHJcbiAgICAgICAgICBjb25zdCBpc1htbCA9IG1ldGFkYXRhLmZvcm1hdCA9PT0gJ3htbCcgfHwgbWV0YWRhdGEuZmlsZW5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLnhtbCcpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoaXNYbWwpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflIQgUGFyc2luZyBsb2NhbCBYTUwgZmlsZS4uLmApO1xyXG4gICAgICAgICAgICBjb25zdCBzdGlnRGF0YSA9IHBhcnNlWGNjZGZYbWwoY29udGVudCwgc3RpZ0lkKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChzdGlnRGF0YS5yZXF1aXJlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgLi4uc3RpZ0RhdGEsXHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBtZXRhZGF0YS52ZXJzaW9uLFxyXG4gICAgICAgICAgICAgICAgcmVsZWFzZURhdGU6IG1ldGFkYXRhLnJlbGVhc2VEYXRlLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiAnbG9jYWwnLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYOKchSBTdWNjZXNzZnVsbHkgaW1wb3J0ZWQgJHtzdGlnRGF0YS5yZXF1aXJlbWVudHMubGVuZ3RofSByZXF1aXJlbWVudHMgZnJvbSBsb2NhbCBsaWJyYXJ5ICgke21ldGFkYXRhLmZpbGVuYW1lfSlgXHJcbiAgICAgICAgICAgICAgfSBhcyBTdGlnSW1wb3J0UmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCflIQgUGFyc2luZyBsb2NhbCBDU1YgZmlsZS4uLmApO1xyXG4gICAgICAgICAgICBjb25zdCBzdGlnRGF0YSA9IHBhcnNlU3RpZ0Nzdihjb250ZW50LCBzdGlnSWQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHN0aWdEYXRhLnJlcXVpcmVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAuLi5zdGlnRGF0YSxcclxuICAgICAgICAgICAgICAgIHN0aWdOYW1lOiBtZXRhZGF0YS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogbWV0YWRhdGEudmVyc2lvbixcclxuICAgICAgICAgICAgICAgIHJlbGVhc2VEYXRlOiBtZXRhZGF0YS5yZWxlYXNlRGF0ZSxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogJ2xvY2FsJyxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGDinIUgU3VjY2Vzc2Z1bGx5IGltcG9ydGVkICR7c3RpZ0RhdGEucmVxdWlyZW1lbnRzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZyb20gbG9jYWwgbGlicmFyeSAoJHttZXRhZGF0YS5maWxlbmFtZX0pYFxyXG4gICAgICAgICAgICAgIH0gYXMgU3RpZ0ltcG9ydFJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGxvY2FsRXJyb3I6IGFueSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciByZWFkaW5nIGxvY2FsIFNUSUc6ICR7bG9jYWxFcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAgIC8vIENvbnRpbnVlIHRvIHN0aWd2aWV3ZXIuY29tIGZhbGxiYWNrXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDihLnvuI8gU1RJRyBub3QgZm91bmQgaW4gbG9jYWwgbGlicmFyeSwgd2lsbCB0cnkgc3RpZ3ZpZXdlci5jb21gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyDwn4yQIEZBTExCQUNLOiBUcnkgc3RpZ3ZpZXdlci5jb21cclxuICAgIGNvbnNvbGUubG9nKGDwn5SNIEZldGNoaW5nIFNUSUcgZnJvbSBzdGlndmlld2VyLmNvbTogJHtzdGlnSWR9YCk7XHJcblxyXG4gICAgLy8gVHJ5IEpTT04gQVBJIGZpcnN0IChoYXMgY29tcGxldGUgc2V2ZXJpdHkgZGF0YSlcclxuICAgIGNvbnN0IGpzb25VcmwgPSBgaHR0cHM6Ly9zdGlndmlld2VyLmNvbS9zdGlncy8ke3N0aWdJZH0vanNvbmA7XHJcbiAgICBjb25zdCBodG1sVXJsID0gYGh0dHBzOi8vc3RpZ3ZpZXdlci5jb20vc3RpZ3MvJHtzdGlnSWR9L2A7XHJcbiAgICBcclxuICAgIC8vIENyZWF0ZSBjdXN0b20gYWdlbnQgdG8gYnlwYXNzIFNTTCBjZXJ0aWZpY2F0ZSB2YWxpZGF0aW9uXHJcbiAgICBjb25zdCBhZ2VudCA9IG5ldyBodHRwcy5BZ2VudCh7XHJcbiAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2VcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBBdHRlbXB0IEpTT04gQVBJIGZpcnN0XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OlIEF0dGVtcHRpbmcgSlNPTiBBUEkuLi5gKTtcclxuICAgICAgY29uc3QganNvblJlc3BvbnNlID0gYXdhaXQgZmV0Y2goanNvblVybCwge1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdVc2VyLUFnZW50JzogJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8xMjAuMC4wLjAgU2FmYXJpLzUzNy4zNicsXHJcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvaHRtbCwgKi8qJyxcclxuICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnZW4tVVMsZW47cT0wLjknLFxyXG4gICAgICAgICAgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlLCBicicsXHJcbiAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3N0aWd2aWV3ZXIuY29tLycsXHJcbiAgICAgICAgICAnQ29ubmVjdGlvbic6ICdrZWVwLWFsaXZlJyxcclxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcclxuICAgICAgICAgICdQcmFnbWEnOiAnbm8tY2FjaGUnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGFnZW50LFxyXG4gICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCgxNTAwMCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKGpzb25SZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGpzb25EYXRhID0gYXdhaXQganNvblJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEpTT04gQVBJIHN1Y2Nlc3NmdWxgKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBzdGlnRGF0YSA9IHBhcnNlU3RpZ1ZpZXdlckpzb24oanNvbkRhdGEsIHN0aWdJZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHN0aWdEYXRhLnJlcXVpcmVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xyXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgICAuLi5zdGlnRGF0YSxcclxuICAgICAgICAgICAgc291cmNlOiAnc3RpZ3ZpZXdlcicsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBTdWNjZXNzZnVsbHkgaW1wb3J0ZWQgJHtzdGlnRGF0YS5yZXF1aXJlbWVudHMubGVuZ3RofSByZXF1aXJlbWVudHMgZnJvbSBKU09OIEFQSWBcclxuICAgICAgICAgIH0gYXMgU3RpZ0ltcG9ydFJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gSlNPTiBBUEkgcmV0dXJuZWQgJHtqc29uUmVzcG9uc2Uuc3RhdHVzfTogJHtqc29uUmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoanNvbkVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBKU09OIEFQSSBmYWlsZWQ6ICR7anNvbkVycm9yLm1lc3NhZ2V9LCB0cnlpbmcgSFRNTC4uLmApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBGYWxsYmFjayB0byBIVE1MIHBhcnNpbmdcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OlIEF0dGVtcHRpbmcgSFRNTCBwYXJzaW5nLi4uYCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSB0byBhdm9pZCByYXRlIGxpbWl0aW5nXHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaHRtbFVybCwge1xyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdVc2VyLUFnZW50JzogJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8xMjAuMC4wLjAgU2FmYXJpLzUzNy4zNicsXHJcbiAgICAgICAgICAnQWNjZXB0JzogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCcsXHJcbiAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogJ2VuLVVTLGVuO3E9MC45JyxcclxuICAgICAgICAgICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCwgZGVmbGF0ZSwgYnInLFxyXG4gICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly9zdGlndmlld2VyLmNvbS8nLFxyXG4gICAgICAgICAgJ0Nvbm5lY3Rpb24nOiAna2VlcC1hbGl2ZScsXHJcbiAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXHJcbiAgICAgICAgICAnUHJhZ21hJzogJ25vLWNhY2hlJyxcclxuICAgICAgICAgICdTZWMtRmV0Y2gtRGVzdCc6ICdkb2N1bWVudCcsXHJcbiAgICAgICAgICAnU2VjLUZldGNoLU1vZGUnOiAnbmF2aWdhdGUnLFxyXG4gICAgICAgICAgJ1NlYy1GZXRjaC1TaXRlJzogJ3NhbWUtb3JpZ2luJyxcclxuICAgICAgICAgICdVcGdyYWRlLUluc2VjdXJlLVJlcXVlc3RzJzogJzEnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGFnZW50LFxyXG4gICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCgxNTAwMCksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgaHRtbCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuXHJcbiAgICAgIC8vIFBhcnNlIFNUSUcgaW5mb3JtYXRpb24gZnJvbSBIVE1MXHJcbiAgICAgIGNvbnN0IHN0aWdEYXRhID0gYXdhaXQgcGFyc2VTdGlnVmlld2VySHRtbChodG1sLCBzdGlnSWQpO1xyXG5cclxuICAgICAgaWYgKHN0aWdEYXRhLnJlcXVpcmVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlcXVpcmVtZW50cyBmb3VuZCBpbiBTVElHIGRhdGEnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCAke3N0aWdEYXRhLnJlcXVpcmVtZW50cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmcm9tIHN0aWd2aWV3ZXIuY29tYCk7XHJcblxyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xyXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgLi4uc3RpZ0RhdGEsXHJcbiAgICAgICAgc291cmNlOiAnc3RpZ3ZpZXdlcicsXHJcbiAgICAgICAgbWVzc2FnZTogYFN1Y2Nlc3NmdWxseSBpbXBvcnRlZCAke3N0aWdEYXRhLnJlcXVpcmVtZW50cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmcm9tIHN0aWd2aWV3ZXIuY29tYFxyXG4gICAgICB9IGFzIFN0aWdJbXBvcnRSZXN1bHQpO1xyXG5cclxuICAgIH0gY2F0Y2ggKGZldGNoRXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgZnJvbSBzdGlndmlld2VyLmNvbTonLCBmZXRjaEVycm9yLm1lc3NhZ2UpO1xyXG5cclxuICAgICAgLy8gUHJvdmlkZSBzcGVjaWZpYyBndWlkYW5jZSBiYXNlZCBvbiBlcnJvciB0eXBlXHJcbiAgICAgIGxldCBlcnJvckd1aWRhbmNlID0gJ0ZhaWxlZCB0byBmZXRjaCBmcm9tIHN0aWd2aWV3ZXIuY29tLiBQbGVhc2UgdHJ5IGFnYWluIG9yIHVwbG9hZCBTVElHIG1hbnVhbGx5Lic7XHJcbiAgICAgIGlmIChmZXRjaEVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJzQwMycpIHx8IGZldGNoRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnRm9yYmlkZGVuJykpIHtcclxuICAgICAgICBlcnJvckd1aWRhbmNlID0gJ3N0aWd2aWV3ZXIuY29tIGlzIGJsb2NraW5nIGF1dG9tYXRlZCByZXF1ZXN0cyAoNDAzIEZvcmJpZGRlbikuIFRoaXMgbWF5IGJlIGR1ZSB0byByYXRlIGxpbWl0aW5nIG9yIGFjY2VzcyByZXN0cmljdGlvbnMuIFBsZWFzZSB3YWl0IGEgZmV3IG1pbnV0ZXMgYW5kIHRyeSBhZ2Fpbiwgb3IgZG93bmxvYWQgYW5kIHVwbG9hZCB0aGUgU1RJRyBtYW51YWxseS4nO1xyXG4gICAgICB9IGVsc2UgaWYgKGZldGNoRXJyb3IubWVzc2FnZS5pbmNsdWRlcygndGltZW91dCcpKSB7XHJcbiAgICAgICAgZXJyb3JHdWlkYW5jZSA9ICdSZXF1ZXN0IHRpbWVkIG91dC4gVGhlIHNlcnZlciBtYXkgYmUgc2xvdyBvciB1bmF2YWlsYWJsZS4gUGxlYXNlIHRyeSBhZ2Fpbi4nO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXR1cm4gZXJyb3Igd2l0aCBpbnN0cnVjdGlvbnMgZm9yIG1hbnVhbCB1cGxvYWRcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBzdGlnSWQsXHJcbiAgICAgICAgZXJyb3I6IGZldGNoRXJyb3IubWVzc2FnZSxcclxuICAgICAgICBtZXNzYWdlOiBlcnJvckd1aWRhbmNlLFxyXG4gICAgICAgIGluc3RydWN0aW9uczoge1xyXG4gICAgICAgICAgc3RlcDE6ICdEb3dubG9hZCBTVElHIFhNTCBmcm9tIERJU0EgQ3liZXIgRXhjaGFuZ2U6IGh0dHBzOi8vcHVibGljLmN5YmVyLm1pbC9zdGlncy9kb3dubG9hZHMvJyxcclxuICAgICAgICAgIHN0ZXAyOiAnT3IgZG93bmxvYWQgZnJvbSBTVElHVmlld2VyOiBodHRwczovL3N0aWd2aWV3ZXIuY29tL3N0aWdzJyxcclxuICAgICAgICAgIHN0ZXAzOiAnVXBsb2FkIHRoZSBYQ0NERiBYTUwgZmlsZSB1c2luZyB0aGUgbWFudWFsIHVwbG9hZCBvcHRpb24nXHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB7IHN0YXR1czogNTAzIH0pO1xyXG4gICAgfVxyXG5cclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaW4gU1RJRyBpbXBvcnQ6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICB7IFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBpbXBvcnRpbmcgU1RJRydcclxuICAgICAgfSxcclxuICAgICAgeyBzdGF0dXM6IDUwMCB9XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIERJU0EgU1RJRyBDU1YgZmlsZVxyXG4gKiBDU1YgZm9ybWF0IGZyb20gRElTQSBDeWJlciBFeGNoYW5nZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VTdGlnQ3N2KGNzdkNvbnRlbnQ6IHN0cmluZywgZmlsZU5hbWU6IHN0cmluZyk6IE9taXQ8U3RpZ0ltcG9ydFJlc3VsdCwgJ3N1Y2Nlc3MnIHwgJ3NvdXJjZScgfCAnbWVzc2FnZSc+IHtcclxuICBjb25zdCByZXF1aXJlbWVudHM6IFN0aWdSZXF1aXJlbWVudFtdID0gW107XHJcbiAgXHJcbiAgLy8gUHJvcGVybHkgc3BsaXQgQ1NWIGNvbnRlbnQgaW50byBsaW5lcywgaGFuZGxpbmcgbXVsdGktbGluZSBxdW90ZWQgZmllbGRzXHJcbiAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gW107XHJcbiAgbGV0IGN1cnJlbnRMaW5lID0gJyc7XHJcbiAgbGV0IGluc2lkZVF1b3RlcyA9IGZhbHNlO1xyXG4gIFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3N2Q29udGVudC5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgY2hhciA9IGNzdkNvbnRlbnRbaV07XHJcbiAgICBjb25zdCBuZXh0Q2hhciA9IGNzdkNvbnRlbnRbaSArIDFdO1xyXG4gICAgXHJcbiAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xyXG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGFuIGVzY2FwZWQgcXVvdGVcclxuICAgICAgaWYgKG5leHRDaGFyID09PSAnXCInKSB7XHJcbiAgICAgICAgY3VycmVudExpbmUgKz0gY2hhciArIG5leHRDaGFyO1xyXG4gICAgICAgIGkrKzsgLy8gU2tpcCBuZXh0IHF1b3RlXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW5zaWRlUXVvdGVzID0gIWluc2lkZVF1b3RlcztcclxuICAgICAgICBjdXJyZW50TGluZSArPSBjaGFyO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcXG4nICYmICFpbnNpZGVRdW90ZXMpIHtcclxuICAgICAgaWYgKGN1cnJlbnRMaW5lLnRyaW0oKSkge1xyXG4gICAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xyXG4gICAgICB9XHJcbiAgICAgIGN1cnJlbnRMaW5lID0gJyc7XHJcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdcXHInKSB7XHJcbiAgICAgIC8vIFNraXAgY2FycmlhZ2UgcmV0dXJuc1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN1cnJlbnRMaW5lICs9IGNoYXI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEFkZCB0aGUgbGFzdCBsaW5lIGlmIG5vdCBlbXB0eVxyXG4gIGlmIChjdXJyZW50TGluZS50cmltKCkpIHtcclxuICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xyXG4gIH1cclxuICBcclxuICBjb25zb2xlLmxvZyhg8J+ThCBTcGxpdCBDU1YgaW50byAke2xpbmVzLmxlbmd0aH0gbGluZXNgKTtcclxuICBcclxuICBpZiAobGluZXMubGVuZ3RoIDwgMikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RpZ0lkOiBmaWxlTmFtZS5yZXBsYWNlKC9cXC5jc3YkL2ksICcnKSxcclxuICAgICAgc3RpZ05hbWU6ICdJbXBvcnRlZCBTVElHJyxcclxuICAgICAgdmVyc2lvbjogJ1Vua25vd24nLFxyXG4gICAgICByZWxlYXNlRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgIHJlcXVpcmVtZW50czogW10sXHJcbiAgICAgIHRvdGFsUmVxdWlyZW1lbnRzOiAwXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUGFyc2UgaGVhZGVyIHJvdyAtIGhhbmRsZSBxdW90ZWQgQ1NWIGZpZWxkc1xyXG4gIGNvbnN0IHBhcnNlQ1NWTGluZSA9IChsaW5lOiBzdHJpbmcpOiBzdHJpbmdbXSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW107XHJcbiAgICBsZXQgY3VycmVudCA9ICcnO1xyXG4gICAgbGV0IGluUXVvdGVzID0gZmFsc2U7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGNoYXIgPSBsaW5lW2ldO1xyXG4gICAgICBjb25zdCBuZXh0Q2hhciA9IGxpbmVbaSArIDFdO1xyXG4gICAgICBcclxuICAgICAgaWYgKGNoYXIgPT09ICdcIicpIHtcclxuICAgICAgICBpZiAoaW5RdW90ZXMgJiYgbmV4dENoYXIgPT09ICdcIicpIHtcclxuICAgICAgICAgIC8vIEVzY2FwZWQgcXVvdGVcclxuICAgICAgICAgIGN1cnJlbnQgKz0gJ1wiJztcclxuICAgICAgICAgIGkrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW5RdW90ZXMgPSAhaW5RdW90ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICcsJyAmJiAhaW5RdW90ZXMpIHtcclxuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50LnRyaW0oKSk7XHJcbiAgICAgICAgY3VycmVudCA9ICcnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdWx0LnB1c2goY3VycmVudC50cmltKCkpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICAvLyBGaW5kIHRoZSBoZWFkZXIgcm93IChza2lwIGNsYXNzaWZpY2F0aW9uIGJhbm5lcnMgbGlrZSBcIn5+fn5+fn4gVW5jbGFzc2lmaWVkIH5+fn5+flwiKVxyXG4gIGxldCBoZWFkZXJMaW5lSW5kZXggPSAwO1xyXG4gIGxldCBoZWFkZXJzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oNSwgbGluZXMubGVuZ3RoKTsgaSsrKSB7XHJcbiAgICBjb25zdCBwYXJzZWRMaW5lID0gcGFyc2VDU1ZMaW5lKGxpbmVzW2ldKTtcclxuICAgIGNvbnN0IGxpbmVUZXh0ID0gcGFyc2VkTGluZS5qb2luKCcnKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgXHJcbiAgICAvLyBTa2lwIGNsYXNzaWZpY2F0aW9uIGJhbm5lcnMgYW5kIGVtcHR5IGxpbmVzXHJcbiAgICBpZiAobGluZVRleHQuaW5jbHVkZXMoJ3VuY2xhc3NpZmllZCcpIHx8IGxpbmVUZXh0LmluY2x1ZGVzKCd+fn5+ficpIHx8IHBhcnNlZExpbmUubGVuZ3RoIDwgNSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBsb29rcyBsaWtlIGEgaGVhZGVyIHJvdyAoaGFzIGNvbW1vbiBTVElHIGNvbHVtbiBuYW1lcylcclxuICAgIGlmIChsaW5lVGV4dC5pbmNsdWRlcygnc3RpZycpIHx8IGxpbmVUZXh0LmluY2x1ZGVzKCdzZXZlcml0eScpIHx8IGxpbmVUZXh0LmluY2x1ZGVzKCdydWxlJykpIHtcclxuICAgICAgaGVhZGVyTGluZUluZGV4ID0gaTtcclxuICAgICAgaGVhZGVycyA9IHBhcnNlZExpbmUubWFwKGggPT4gaC50b0xvd2VyQ2FzZSgpLnRyaW0oKSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OLIEZvdW5kIGhlYWRlciByb3cgYXQgbGluZSAke2kgKyAxfWApO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgaWYgKGhlYWRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCfinYwgQ291bGQgbm90IGZpbmQgdmFsaWQgaGVhZGVyIHJvdyBpbiBDU1YnKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0aWdJZDogZmlsZU5hbWUucmVwbGFjZSgvXFwuY3N2JC9pLCAnJyksXHJcbiAgICAgIHN0aWdOYW1lOiAnSW1wb3J0ZWQgU1RJRycsXHJcbiAgICAgIHZlcnNpb246ICdVbmtub3duJyxcclxuICAgICAgcmVsZWFzZURhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxyXG4gICAgICByZXF1aXJlbWVudHM6IFtdLFxyXG4gICAgICB0b3RhbFJlcXVpcmVtZW50czogMFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnNvbGUubG9nKGDwn5OLIENTViBIZWFkZXJzIGZvdW5kOiAke2hlYWRlcnMuc2xpY2UoMCwgMTApLmpvaW4oJywgJyl9Li4uYCk7XHJcbiAgY29uc29sZS5sb2coYPCfk4sgQWxsIGhlYWRlcnMgKGZpcnN0IDE1KTpgLCBoZWFkZXJzLnNsaWNlKDAsIDE1KSk7XHJcbiAgXHJcbiAgLy8gRmluZCBjb2x1bW4gaW5kaWNlc1xyXG4gIGNvbnN0IGdldEluZGV4ID0gKG5hbWVzOiBzdHJpbmdbXSkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XHJcbiAgICAgIGNvbnN0IGlkeCA9IGhlYWRlcnMuZmluZEluZGV4KGggPT4gaC5pbmNsdWRlcyhuYW1lKSk7XHJcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCBcIiR7bmFtZX1cIiBhdCBpbmRleCAke2lkeH06IFwiJHtoZWFkZXJzW2lkeF19XCJgKTtcclxuICAgICAgICByZXR1cm4gaWR4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZyhg4p2MIENvdWxkIG5vdCBmaW5kIGFueSBvZjogJHtuYW1lcy5qb2luKCcsICcpfWApO1xyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHN0aWdJZElkeCA9IGdldEluZGV4KFsnc3RpZyBpZCcsICdzdGlnaWQnXSk7XHJcbiAgY29uc3Qgc2V2ZXJpdHlJZHggPSBnZXRJbmRleChbJ3NldmVyaXR5J10pO1xyXG4gIGNvbnN0IHRpdGxlSWR4ID0gZ2V0SW5kZXgoWydydWxlIHRpdGxlJywgJ3J1bGV0aXRsZSddKTtcclxuICBjb25zdCBkaXNjdXNzaW9uSWR4ID0gZ2V0SW5kZXgoWydkaXNjdXNzaW9uJ10pO1xyXG4gIGNvbnN0IGNoZWNrSWR4ID0gZ2V0SW5kZXgoWydjaGVjayBjb250ZW50JywgJ2NoZWNrY29udGVudCddKTtcclxuICBjb25zdCBmaXhJZHggPSBnZXRJbmRleChbJ2ZpeCB0ZXh0JywgJ2ZpeHRleHQnXSk7XHJcbiAgY29uc3QgY2NpSWR4ID0gZ2V0SW5kZXgoWydjY2lzJywgJ2NjaSddKTtcclxuICBjb25zdCBydWxlSWRJZHggPSBnZXRJbmRleChbJ3J1bGUgaWQnLCAncnVsZWlkJ10pO1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKGDwn5OKIENvbHVtbiBpbmRpY2VzOmAsIHtcclxuICAgIHN0aWdJZDogc3RpZ0lkSWR4LFxyXG4gICAgc2V2ZXJpdHk6IHNldmVyaXR5SWR4LFxyXG4gICAgdGl0bGU6IHRpdGxlSWR4LFxyXG4gICAgZGlzY3Vzc2lvbjogZGlzY3Vzc2lvbklkeCxcclxuICAgIGNoZWNrOiBjaGVja0lkeCxcclxuICAgIGZpeDogZml4SWR4LFxyXG4gICAgY2NpOiBjY2lJZHgsXHJcbiAgICBydWxlSWQ6IHJ1bGVJZElkeFxyXG4gIH0pO1xyXG5cclxuICBsZXQgc3RpZ05hbWUgPSAnSW1wb3J0ZWQgU1RJRyc7XHJcbiAgbGV0IHZlcnNpb24gPSAnVW5rbm93bic7XHJcbiAgXHJcbiAgY29uc29sZS5sb2coYPCfk4QgUHJvY2Vzc2luZyAke2xpbmVzLmxlbmd0aCAtIGhlYWRlckxpbmVJbmRleCAtIDF9IGRhdGEgcm93cyBmcm9tIENTVmApO1xyXG4gIFxyXG4gIC8vIFBhcnNlIGRhdGEgcm93cyAoc3RhcnQgYWZ0ZXIgaGVhZGVyIHJvdylcclxuICBmb3IgKGxldCBpID0gaGVhZGVyTGluZUluZGV4ICsgMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xyXG4gICAgaWYgKCFsaW5lKSBjb250aW51ZTtcclxuXHJcbiAgICBjb25zdCB2YWx1ZXMgPSBwYXJzZUNTVkxpbmUobGluZSk7XHJcbiAgICBcclxuICAgIGlmIChpID09PSBoZWFkZXJMaW5lSW5kZXggKyAxKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OdIEZpcnN0IGRhdGEgcm93IGhhcyAke3ZhbHVlcy5sZW5ndGh9IHZhbHVlc2ApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IFNUSUcgbmFtZSBmcm9tIGZpcnN0IGRhdGEgcm93IGlmIGF2YWlsYWJsZVxyXG4gICAgaWYgKGkgPT09IGhlYWRlckxpbmVJbmRleCArIDEgJiYgdmFsdWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgYmVuY2htYXJrSWR4ID0gaGVhZGVycy5maW5kSW5kZXgoaCA9PiBoLmluY2x1ZGVzKCdiZW5jaG1hcmsnKSk7XHJcbiAgICAgIGlmIChiZW5jaG1hcmtJZHggIT09IC0xICYmIHZhbHVlc1tiZW5jaG1hcmtJZHhdKSB7XHJcbiAgICAgICAgc3RpZ05hbWUgPSB2YWx1ZXNbYmVuY2htYXJrSWR4XTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB2ZXJzaW9uSWR4ID0gaGVhZGVycy5maW5kSW5kZXgoaCA9PiBoLmluY2x1ZGVzKCd2ZXJzaW9uJykgfHwgaC5pbmNsdWRlcygncmVsZWFzZScpKTtcclxuICAgICAgaWYgKHZlcnNpb25JZHggIT09IC0xICYmIHZhbHVlc1t2ZXJzaW9uSWR4XSkge1xyXG4gICAgICAgIHZlcnNpb24gPSB2YWx1ZXNbdmVyc2lvbklkeF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2dWxuSWQgPSBzdGlnSWRJZHggIT09IC0xID8gdmFsdWVzW3N0aWdJZElkeF0gOiAnJztcclxuICAgIGNvbnN0IHJ1bGVJZCA9IHJ1bGVJZElkeCAhPT0gLTEgPyB2YWx1ZXNbcnVsZUlkSWR4XSA6IHZ1bG5JZDtcclxuICAgIFxyXG4gICAgaWYgKCF2dWxuSWQpIHtcclxuICAgICAgaWYgKGkgPD0gaGVhZGVyTGluZUluZGV4ICsgMykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gTGluZSAke2l9OiBObyBTVElHIElEIGZvdW5kYCk7XHJcbiAgICAgIH1cclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChpID09PSBoZWFkZXJMaW5lSW5kZXggKyAxKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgRmlyc3QgcmVxdWlyZW1lbnQgZm91bmQ6ICR7dnVsbklkfWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhcnNlIHNldmVyaXR5IC0gaGFuZGxlIG11bHRpcGxlIGZvcm1hdHNcclxuICAgIGNvbnN0IHNldmVyaXR5VmFsdWUgPSBzZXZlcml0eUlkeCAhPT0gLTEgPyB2YWx1ZXNbc2V2ZXJpdHlJZHhdLnRvTG93ZXJDYXNlKCkudHJpbSgpIDogJ21lZGl1bSc7XHJcbiAgICBsZXQgc2V2ZXJpdHk6ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdycgPSAnbWVkaXVtJztcclxuICAgIFxyXG4gICAgLy8gRGlyZWN0IHNldmVyaXR5IHZhbHVlc1xyXG4gICAgaWYgKHNldmVyaXR5VmFsdWUgPT09ICdoaWdoJyB8fCBzZXZlcml0eVZhbHVlLmluY2x1ZGVzKCdjYXQgaScpIHx8IHNldmVyaXR5VmFsdWUuaW5jbHVkZXMoJ2NhdCAxJykgfHwgc2V2ZXJpdHlWYWx1ZS5pbmNsdWRlcygnY2F0aScpKSB7XHJcbiAgICAgIHNldmVyaXR5ID0gJ2hpZ2gnO1xyXG4gICAgfSBlbHNlIGlmIChzZXZlcml0eVZhbHVlID09PSAnbG93JyB8fCBzZXZlcml0eVZhbHVlLmluY2x1ZGVzKCdjYXQgaWlpJykgfHwgc2V2ZXJpdHlWYWx1ZS5pbmNsdWRlcygnY2F0IDMnKSB8fCBzZXZlcml0eVZhbHVlLmluY2x1ZGVzKCdjYXRpaWknKSkge1xyXG4gICAgICBzZXZlcml0eSA9ICdsb3cnO1xyXG4gICAgfSBlbHNlIGlmIChzZXZlcml0eVZhbHVlID09PSAnbWVkaXVtJyB8fCBzZXZlcml0eVZhbHVlLmluY2x1ZGVzKCdjYXQgaWknKSB8fCBzZXZlcml0eVZhbHVlLmluY2x1ZGVzKCdjYXQgMicpIHx8IHNldmVyaXR5VmFsdWUuaW5jbHVkZXMoJ2NhdGlpJykpIHtcclxuICAgICAgc2V2ZXJpdHkgPSAnbWVkaXVtJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gTG9nIGZpcnN0IGZldyBmb3IgZGVidWdnaW5nXHJcbiAgICBpZiAoaSA8PSBoZWFkZXJMaW5lSW5kZXggKyAzKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFJvdyAke2kgLSBoZWFkZXJMaW5lSW5kZXh9OiB2dWxuSWQ9XCIke3Z1bG5JZH1cIiwgc2V2ZXJpdHk9XCIke3NldmVyaXR5VmFsdWV9XCIg4oaSICR7c2V2ZXJpdHl9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXh0cmFjdCBDQ0kgcmVmZXJlbmNlc1xyXG4gICAgY29uc3QgY2NpVGV4dCA9IGNjaUlkeCAhPT0gLTEgPyB2YWx1ZXNbY2NpSWR4XSA6ICcnO1xyXG4gICAgY29uc3QgY2NpTWF0Y2hlcyA9IGNjaVRleHQubWF0Y2goL0NDSS1cXGQrL2cpO1xyXG4gICAgY29uc3QgY2NpID0gY2NpTWF0Y2hlcyB8fCBbJ0NDSS0wMDAzNjYnXTtcclxuXHJcbiAgICByZXF1aXJlbWVudHMucHVzaCh7XHJcbiAgICAgIHZ1bG5JZCxcclxuICAgICAgcnVsZUlkLFxyXG4gICAgICBzZXZlcml0eSxcclxuICAgICAgdGl0bGU6IHRpdGxlSWR4ICE9PSAtMSA/IHZhbHVlc1t0aXRsZUlkeF0gOiBgUmVxdWlyZW1lbnQgJHt2dWxuSWR9YCxcclxuICAgICAgZGVzY3JpcHRpb246IGRpc2N1c3Npb25JZHggIT09IC0xID8gdmFsdWVzW2Rpc2N1c3Npb25JZHhdIDogJ05vIGRlc2NyaXB0aW9uIHByb3ZpZGVkJyxcclxuICAgICAgY2hlY2tUZXh0OiBjaGVja0lkeCAhPT0gLTEgPyB2YWx1ZXNbY2hlY2tJZHhdIDogJ1JldmlldyBzeXN0ZW0gY29uZmlndXJhdGlvbiBwZXIgU1RJRyBndWlkYW5jZS4nLFxyXG4gICAgICBmaXhUZXh0OiBmaXhJZHggIT09IC0xID8gdmFsdWVzW2ZpeElkeF0gOiAnQ29uZmlndXJlIHN5c3RlbSBwZXIgU1RJRyBndWlkYW5jZS4nLFxyXG4gICAgICBjY2ksXHJcbiAgICAgIG5pc3RDb250cm9sczogW11cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coYOKchSBDU1YgcGFyc2luZyBjb21wbGV0ZTogJHtyZXF1aXJlbWVudHMubGVuZ3RofSByZXF1aXJlbWVudHMgZm91bmRgKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN0aWdJZDogZmlsZU5hbWUucmVwbGFjZSgvXFwuY3N2JC9pLCAnJyksXHJcbiAgICBzdGlnTmFtZSxcclxuICAgIHZlcnNpb24sXHJcbiAgICByZWxlYXNlRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICByZXF1aXJlbWVudHMsXHJcbiAgICB0b3RhbFJlcXVpcmVtZW50czogcmVxdWlyZW1lbnRzLmxlbmd0aFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQT1NUIC0gTWFudWFsIFNUSUcgdXBsb2FkIChYTUwgb3IgQ1NWIGZpbGUpXHJcbiAqIEJvZHk6IEZvcm1EYXRhIHdpdGggJ2ZpbGUnIGZpZWxkIGNvbnRhaW5pbmcgWENDREYgWE1MIG9yIERJU0EgQ1NWXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBmb3JtRGF0YSA9IGF3YWl0IHJlcXVlc3QuZm9ybURhdGEoKTtcclxuICAgIGNvbnN0IGZpbGUgPSBmb3JtRGF0YS5nZXQoJ2ZpbGUnKSBhcyBGaWxlO1xyXG5cclxuICAgIGlmICghZmlsZSkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBlcnJvcjogJ05vIGZpbGUgcHJvdmlkZWQnIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgZmlsZSB0eXBlXHJcbiAgICBjb25zdCBmaWxlTmFtZSA9IGZpbGUubmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgY29uc3QgaXNYbWwgPSBmaWxlTmFtZS5lbmRzV2l0aCgnLnhtbCcpIHx8IGZpbGVOYW1lLmVuZHNXaXRoKCcueGNjZGYnKTtcclxuICAgIGNvbnN0IGlzQ3N2ID0gZmlsZU5hbWUuZW5kc1dpdGgoJy5jc3YnKTtcclxuICAgIFxyXG4gICAgaWYgKCFpc1htbCAmJiAhaXNDc3YpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIGZpbGUgdHlwZS4gUGxlYXNlIHVwbG9hZCBhbiBYQ0NERiBYTUwgZmlsZSBvciBESVNBIENTViBmaWxlLicgfSxcclxuICAgICAgICB7IHN0YXR1czogNDAwIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+TgSBQcm9jZXNzaW5nIG1hbnVhbCBTVElHIHVwbG9hZDogJHtmaWxlLm5hbWV9YCk7XHJcblxyXG4gICAgLy8gUmVhZCBmaWxlIGNvbnRlbnRcclxuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgZmlsZS50ZXh0KCk7XHJcblxyXG4gICAgbGV0IHN0aWdEYXRhO1xyXG4gICAgXHJcbiAgICBpZiAoaXNDc3YpIHtcclxuICAgICAgLy8gUGFyc2UgQ1NWIGZpbGVcclxuICAgICAgc3RpZ0RhdGEgPSBwYXJzZVN0aWdDc3YoZmlsZUNvbnRlbnQsIGZpbGVOYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFBhcnNlIFhDQ0RGIFhNTFxyXG4gICAgICBzdGlnRGF0YSA9IHBhcnNlWGNjZGZYbWwoZmlsZUNvbnRlbnQsIGZpbGVOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RpZ0RhdGEucmVxdWlyZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlcXVpcmVtZW50cyBmb3VuZCBpbiAke2lzQ3N2ID8gJ0NTVicgOiAnWE1MJ30gZmlsZS4gUGxlYXNlIGVuc3VyZSB0aGlzIGlzIGEgdmFsaWQgRElTQSBTVElHIGZpbGUuYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgcGFyc2VkICR7c3RpZ0RhdGEucmVxdWlyZW1lbnRzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZyb20gbWFudWFsIHVwbG9hZGApO1xyXG5cclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgIC4uLnN0aWdEYXRhLFxyXG4gICAgICBzb3VyY2U6ICdtYW51YWwnLFxyXG4gICAgICBtZXNzYWdlOiBgU3VjY2Vzc2Z1bGx5IGltcG9ydGVkICR7c3RpZ0RhdGEucmVxdWlyZW1lbnRzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZyb20gJHtmaWxlLm5hbWV9YFxyXG4gICAgfSBhcyBTdGlnSW1wb3J0UmVzdWx0KTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHByb2Nlc3NpbmcgbWFudWFsIHVwbG9hZDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgIHsgXHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBwYXJzZSBTVElHIGZpbGUuIFBsZWFzZSBlbnN1cmUgdGhpcyBpcyBhIHZhbGlkIFhDQ0RGIFhNTCBmaWxlLidcclxuICAgICAgfSxcclxuICAgICAgeyBzdGF0dXM6IDUwMCB9XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZldGNoIGRldGFpbGVkIHJlcXVpcmVtZW50IHBhZ2UgZnJvbSBzdGlndmlld2VyLmNvbVxyXG4gKiBSZXR1cm5zIGNoZWNrIGFuZCBmaXggdGV4dCBmb3IgYSBzcGVjaWZpYyB2dWxuZXJhYmlsaXR5XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBmZXRjaFJlcXVpcmVtZW50RGV0YWlscyhzdGlnSWQ6IHN0cmluZywgdnVsbklkOiBzdHJpbmcpOiBQcm9taXNlPHtjaGVja1RleHQ6IHN0cmluZywgZml4VGV4dDogc3RyaW5nfT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBhZ2VudCA9IG5ldyBodHRwcy5BZ2VudCh7IHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UgfSk7XHJcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9zdGlndmlld2VyLmNvbS9zdGlnLyR7c3RpZ0lkfS9yZXF1aXJlbWVudC8ke3Z1bG5JZH1gO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2JyxcclxuICAgICAgfSxcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICBhZ2VudCxcclxuICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDEwMDAwKSxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgaHRtbCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBjaGVjayB0ZXh0XHJcbiAgICBjb25zdCBjaGVja01hdGNoID0gaHRtbC5tYXRjaCgvPGRpdltePl0qKD86aWR8Y2xhc3MpPVwiW15cIl0qY2hlY2tbXlwiXSpcIltePl0qPihbXFxzXFxTXSo/KTxcXC9kaXY+L2kpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICBodG1sLm1hdGNoKC9DaGVjayBUZXh0WzpcXHNdKjxbXj5dKj4oW1xcc1xcU10qPyk8XFwvKD86ZGl2fHByZXxwKT4vaSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgIGh0bWwubWF0Y2goLzxwcmVbXj5dKj4oW1xcc1xcU10qPyk8XFwvcHJlPi9pKTtcclxuICAgIFxyXG4gICAgY29uc3QgY2hlY2tUZXh0ID0gY2hlY2tNYXRjaCA/IFxyXG4gICAgICBjaGVja01hdGNoWzFdXHJcbiAgICAgICAgLnJlcGxhY2UoLzxbXj5dKz4vZywgJycpXHJcbiAgICAgICAgLnJlcGxhY2UoLyZsdDsvZywgJzwnKVxyXG4gICAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csICc+JylcclxuICAgICAgICAucmVwbGFjZSgvJmFtcDsvZywgJyYnKVxyXG4gICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcclxuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXHJcbiAgICAgICAgLnRyaW0oKSA6IFxyXG4gICAgICAnUmV2aWV3IHRoZSBzeXN0ZW0gY29uZmlndXJhdGlvbiB0byB2ZXJpZnkgY29tcGxpYW5jZSB3aXRoIHRoZSBzZWN1cml0eSByZXF1aXJlbWVudC4nO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGZpeCB0ZXh0ICBcclxuICAgIGNvbnN0IGZpeE1hdGNoID0gaHRtbC5tYXRjaCgvPGRpdltePl0qKD86aWR8Y2xhc3MpPVwiW15cIl0qZml4W15cIl0qXCJbXj5dKj4oW1xcc1xcU10qPyk8XFwvZGl2Pi9pKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwubWF0Y2goL0ZpeCBUZXh0WzpcXHNdKjxbXj5dKj4oW1xcc1xcU10qPyk8XFwvKD86ZGl2fHByZXxwKT4vaSk7XHJcbiAgICBcclxuICAgIGNvbnN0IGZpeFRleHQgPSBmaXhNYXRjaCA/IFxyXG4gICAgICBmaXhNYXRjaFsxXVxyXG4gICAgICAgIC5yZXBsYWNlKC88W14+XSs+L2csICcnKVxyXG4gICAgICAgIC5yZXBsYWNlKC8mbHQ7L2csICc8JylcclxuICAgICAgICAucmVwbGFjZSgvJmd0Oy9nLCAnPicpXHJcbiAgICAgICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJylcclxuICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKVxyXG4gICAgICAgIC50cmltKCkgOiBcclxuICAgICAgJ0NvbmZpZ3VyZSB0aGUgc3lzdGVtIHRvIG1lZXQgdGhlIHNlY3VyaXR5IHJlcXVpcmVtZW50IGFzIHNwZWNpZmllZCBpbiB0aGUgU1RJRyBkb2N1bWVudGF0aW9uLic7XHJcbiAgICBcclxuICAgIHJldHVybiB7IGNoZWNrVGV4dCwgZml4VGV4dCB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAvLyBSZXR1cm4gZGVmYXVsdHMgaWYgZmV0Y2ggZmFpbHNcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNoZWNrVGV4dDogJ1JldmlldyB0aGUgc3lzdGVtIGNvbmZpZ3VyYXRpb24gdG8gdmVyaWZ5IGNvbXBsaWFuY2Ugd2l0aCB0aGUgc2VjdXJpdHkgcmVxdWlyZW1lbnQuIERldGFpbGVkIGNoZWNrIHByb2NlZHVyZSBhdmFpbGFibGUgaW4gdGhlIGZ1bGwgU1RJRyBkb2N1bWVudGF0aW9uLicsXHJcbiAgICAgIGZpeFRleHQ6ICdDb25maWd1cmUgdGhlIHN5c3RlbSB0byBtZWV0IHRoZSBzZWN1cml0eSByZXF1aXJlbWVudC4gRGV0YWlsZWQgZml4IHByb2NlZHVyZSBhdmFpbGFibGUgaW4gdGhlIGZ1bGwgU1RJRyBkb2N1bWVudGF0aW9uLidcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGFyc2Ugc3RpZyB2aWV3ZXIuY29tIEpTT04gQVBJIHJlc3BvbnNlXHJcbiAqIEpTT04gZm9ybWF0IGhhcyBjb21wbGV0ZSBkYXRhIGluY2x1ZGluZyBzZXZlcml0eSBmb3IgZWFjaCByZXF1aXJlbWVudFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VTdGlnVmlld2VySnNvbihqc29uRGF0YTogYW55LCBzdGlnSWQ6IHN0cmluZyk6IE9taXQ8U3RpZ0ltcG9ydFJlc3VsdCwgJ3N1Y2Nlc3MnIHwgJ3NvdXJjZScgfCAnbWVzc2FnZSc+IHtcclxuICBjb25zdCByZXF1aXJlbWVudHM6IFN0aWdSZXF1aXJlbWVudFtdID0gW107XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzdGlnID0ganNvbkRhdGEuc3RpZyB8fCBqc29uRGF0YTtcclxuICAgIGNvbnN0IHN0aWdOYW1lID0gc3RpZy50aXRsZSB8fCBzdGlnSWQ7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gc3RpZy52ZXJzaW9uIHx8ICdVbmtub3duJztcclxuICAgIGNvbnN0IHJlbGVhc2VEYXRlID0gc3RpZy5kYXRlIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhg8J+TiyBQYXJzaW5nIEpTT046ICR7c3RpZ05hbWV9LCBWZXJzaW9uOiAke3ZlcnNpb259LCBSZWxlYXNlOiAke3JlbGVhc2VEYXRlfWApO1xyXG5cclxuICAgIGNvbnN0IGZpbmRpbmdzID0gc3RpZy5maW5kaW5ncyB8fCB7fTtcclxuICAgIGNvbnN0IHZ1bG5JZHMgPSBPYmplY3Qua2V5cyhmaW5kaW5ncyk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGDwn5SNIEZvdW5kICR7dnVsbklkcy5sZW5ndGh9IHJlcXVpcmVtZW50cyBpbiBKU09OYCk7XHJcblxyXG4gICAgdnVsbklkcy5mb3JFYWNoKCh2dWxuSWQpID0+IHtcclxuICAgICAgY29uc3QgZmluZGluZyA9IGZpbmRpbmdzW3Z1bG5JZF07XHJcbiAgICAgIGlmICghZmluZGluZykgcmV0dXJuO1xyXG5cclxuICAgICAgLy8gRXh0cmFjdCBzZXZlcml0eSBmcm9tIGZpbmRpbmdcclxuICAgICAgLy8gSlNPTiBtaWdodCBoYXZlIHNldmVyaXR5IGFzIFwiaGlnaFwiLCBcIm1lZGl1bVwiLCBcImxvd1wiIG9yIFwiQ0FUIElcIiwgXCJDQVQgSUlcIiwgXCJDQVQgSUlJXCJcclxuICAgICAgbGV0IHNldmVyaXR5OiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnID0gJ21lZGl1bSc7XHJcbiAgICAgIGNvbnN0IHNldlRleHQgPSAoZmluZGluZy5zZXZlcml0eSB8fCBmaW5kaW5nLmNhdCB8fCAnbWVkaXVtJykudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBcclxuICAgICAgaWYgKHNldlRleHQuaW5jbHVkZXMoJ2hpZ2gnKSB8fCBzZXZUZXh0LmluY2x1ZGVzKCdjYXQgaScpIHx8IHNldlRleHQgPT09ICdpJyB8fCBzZXZUZXh0ID09PSAnMScpIHtcclxuICAgICAgICBzZXZlcml0eSA9ICdoaWdoJztcclxuICAgICAgfSBlbHNlIGlmIChzZXZUZXh0LmluY2x1ZGVzKCdsb3cnKSB8fCBzZXZUZXh0LmluY2x1ZGVzKCdjYXQgaWlpJykgfHwgc2V2VGV4dCA9PT0gJ2lpaScgfHwgc2V2VGV4dCA9PT0gJzMnKSB7XHJcbiAgICAgICAgc2V2ZXJpdHkgPSAnbG93JztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXZlcml0eSA9ICdtZWRpdW0nO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXF1aXJlbWVudHMucHVzaCh7XHJcbiAgICAgICAgdnVsbklkLFxyXG4gICAgICAgIHJ1bGVJZDogZmluZGluZy5ydWxlSWQgfHwgZmluZGluZy5ydWxlX2lkIHx8IGZpbmRpbmcucnVsZWlkIHx8IGAke3Z1bG5JZH0tcnVsZWAsXHJcbiAgICAgICAgc2V2ZXJpdHksXHJcbiAgICAgICAgdGl0bGU6IGZpbmRpbmcudGl0bGUgfHwgZmluZGluZy5ydWxlVGl0bGUgfHwgZmluZGluZy5ydWxldGl0bGUgfHwgYFJlcXVpcmVtZW50ICR7dnVsbklkfWAsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IGZpbmRpbmcuZGlzY3Vzc2lvbiB8fCBmaW5kaW5nLmRlc2NyaXB0aW9uIHx8IGZpbmRpbmcudGl0bGUgfHwgJycsXHJcbiAgICAgICAgY2hlY2tUZXh0OiBmaW5kaW5nLmNoZWNrdGV4dCB8fCBmaW5kaW5nLmNoZWNrVGV4dCB8fCBmaW5kaW5nLmNoZWNrX3RleHQgfHwgZmluZGluZy5jaGVjayB8fCAnUmV2aWV3IHN5c3RlbSBjb25maWd1cmF0aW9uIHBlciBTVElHIGd1aWRhbmNlLicsXHJcbiAgICAgICAgZml4VGV4dDogZmluZGluZy5maXh0ZXh0IHx8IGZpbmRpbmcuZml4VGV4dCB8fCBmaW5kaW5nLmZpeF90ZXh0IHx8IGZpbmRpbmcuZml4IHx8ICdDb25maWd1cmUgc3lzdGVtIHBlciBTVElHIGd1aWRhbmNlLicsXHJcbiAgICAgICAgY2NpOiBmaW5kaW5nLmNjaSB8fCBmaW5kaW5nLmNjaXMgfHwgWydDQ0ktMDAwMzY2J10sXHJcbiAgICAgICAgbmlzdENvbnRyb2xzOiBmaW5kaW5nLm5pc3RDb250cm9scyB8fCBmaW5kaW5nLm5pc3QgfHwgW11cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBwYXJzZWQgJHtyZXF1aXJlbWVudHMubGVuZ3RofSByZXF1aXJlbWVudHMgZnJvbSBKU09OYCk7XHJcbiAgICBcclxuICAgIC8vIExvZyBzZXZlcml0eSBkaXN0cmlidXRpb25cclxuICAgIGNvbnN0IHNldmVyaXR5RGlzdDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gICAgcmVxdWlyZW1lbnRzLmZvckVhY2gocmVxID0+IHtcclxuICAgICAgc2V2ZXJpdHlEaXN0W3JlcS5zZXZlcml0eV0gPSAoc2V2ZXJpdHlEaXN0W3JlcS5zZXZlcml0eV0gfHwgMCkgKyAxO1xyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TiiBKU09OIFNldmVyaXR5IERpc3RyaWJ1dGlvbjpgLCBzZXZlcml0eURpc3QpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0aWdJZCxcclxuICAgICAgc3RpZ05hbWUsXHJcbiAgICAgIHZlcnNpb24sXHJcbiAgICAgIHJlbGVhc2VEYXRlLFxyXG4gICAgICByZXF1aXJlbWVudHMsXHJcbiAgICAgIHRvdGFsUmVxdWlyZW1lbnRzOiByZXF1aXJlbWVudHMubGVuZ3RoXHJcbiAgICB9O1xyXG5cclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHN0aWd2aWV3ZXIuY29tIEpTT046JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3RpZ3ZpZXdlci5jb20gSlNPTjogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIHN0aWd2aWV3ZXIuY29tIEhUTUwgdG8gZXh0cmFjdCBTVElHIHJlcXVpcmVtZW50c1xyXG4gKiBGZXRjaGVzIGZ1bGwgcmVxdWlyZW1lbnQgZGV0YWlscyBpbmNsdWRpbmcgY2hlY2sgYW5kIGZpeCB0ZXh0XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBwYXJzZVN0aWdWaWV3ZXJIdG1sKGh0bWw6IHN0cmluZywgc3RpZ0lkOiBzdHJpbmcpOiBQcm9taXNlPE9taXQ8U3RpZ0ltcG9ydFJlc3VsdCwgJ3N1Y2Nlc3MnIHwgJ3NvdXJjZScgfCAnbWVzc2FnZSc+PiB7XHJcbiAgY29uc3QgcmVxdWlyZW1lbnRzOiBTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gRXh0cmFjdCBTVElHIG1ldGFkYXRhIGZyb20gcGFnZSB0aXRsZSBhbmQgaGVhZGVyc1xyXG4gICAgY29uc3QgdGl0bGVNYXRjaCA9IGh0bWwubWF0Y2goLzx0aXRsZT4oW148XSspPFxcL3RpdGxlPi9pKTtcclxuICAgIGNvbnN0IHN0aWdOYW1lID0gdGl0bGVNYXRjaCA/IHRpdGxlTWF0Y2hbMV0ucmVwbGFjZSgnIHwgU1RJR1ZpZXdlcicsICcnKS50cmltKCkgOiBzdGlnSWQ7XHJcblxyXG4gICAgLy8gRXh0cmFjdCB2ZXJzaW9uIGZyb20gcGFnZVxyXG4gICAgY29uc3QgdmVyc2lvbk1hdGNoID0gaHRtbC5tYXRjaCgvVmVyc2lvbls6XFxzXSsoW1Z2UnJcXGQuXSspL2kpIHx8IGh0bWwubWF0Y2goL2NsYXNzPVwiW15cIl0qdmVyc2lvblteXCJdKlwiW14+XSo+KFtePF0rKTwvaSk7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbk1hdGNoID8gdmVyc2lvbk1hdGNoWzFdLnRyaW0oKSA6ICdVbmtub3duJztcclxuXHJcbiAgICAvLyBFeHRyYWN0IHJlbGVhc2UgZGF0ZVxyXG4gICAgY29uc3QgZGF0ZU1hdGNoID0gaHRtbC5tYXRjaCgvUmVsZWFzZVs6XFxzXSsoXFxkezEsMn1cXHMrXFx3K1xccytcXGR7NH0pL2kpIHx8IFxyXG4gICAgICAgICAgICAgICAgICAgICBodG1sLm1hdGNoKC9EYXRlWzpcXHNdKyhcXGR7NH0tXFxkezJ9LVxcZHsyfSkvaSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgaHRtbC5tYXRjaCgvKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS8pO1xyXG4gICAgY29uc3QgcmVsZWFzZURhdGUgPSBkYXRlTWF0Y2ggPyBkYXRlTWF0Y2hbMV0gOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+TiyBQYXJzaW5nIFNUSUc6ICR7c3RpZ05hbWV9LCBWZXJzaW9uOiAke3ZlcnNpb259LCBSZWxlYXNlOiAke3JlbGVhc2VEYXRlfWApO1xyXG5cclxuICAgIC8vIE1ldGhvZCAxOiBFeHRyYWN0IGNvbXBsZXRlIHJlcXVpcmVtZW50IGVudHJpZXMgd2l0aCBhbGwgZGV0YWlsc1xyXG4gICAgLy8gc3RpZ3ZpZXdlci5jb20gaGFzIGxpbmtzIGxpa2U6IGhyZWY9XCIvc3RpZy97c3RpZ0lkfS9yZXF1aXJlbWVudC9WLSMjIyMjXCJcclxuICAgIC8vIFBhdHRlcm4gdG8gbWF0Y2ggZW50aXJlIHJlcXVpcmVtZW50IHNlY3Rpb25zIHdpdGggc2V2ZXJpdHkgaW5mb1xyXG4gICAgY29uc3QgcmVxU2VjdGlvblBhdHRlcm4gPSAvKD86Q0FUXFxzKyhJezEsM30pfHNldmVyaXR5W14+XSo/KGhpZ2h8bWVkaXVtfGxvdykpW15WXSooVi1cXGQrKVtePF0qPGFbXj5dKmhyZWY9XCJbXlwiXSpcXC9yZXF1aXJlbWVudFxcL1xcM1wiW14+XSo+KFtePF0rKTwvZ2k7XHJcbiAgICBsZXQgbWF0Y2g7XHJcbiAgICBjb25zdCBkZXRhaWxlZFJlcXM6IEFycmF5PHt2dWxuSWQ6IHN0cmluZywgc2V2ZXJpdHk6IHN0cmluZywgdGl0bGU6IHN0cmluZ30+ID0gW107XHJcbiAgICBcclxuICAgIHdoaWxlICgobWF0Y2ggPSByZXFTZWN0aW9uUGF0dGVybi5leGVjKGh0bWwpKSAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBzZXZlcml0eSA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdOyAvLyBDQVQgSS9JSS9JSUkgb3IgaGlnaC9tZWRpdW0vbG93XHJcbiAgICAgIGNvbnN0IHZ1bG5JZCA9IG1hdGNoWzNdO1xyXG4gICAgICBjb25zdCB0aXRsZSA9IG1hdGNoWzRdLnRyaW0oKTtcclxuICAgICAgZGV0YWlsZWRSZXFzLnB1c2goeyB2dWxuSWQsIHNldmVyaXR5LCB0aXRsZSB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCflI0gTWV0aG9kIDE6IEZvdW5kICR7ZGV0YWlsZWRSZXFzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIHdpdGggc2V2ZXJpdHkgaW5mb2ApO1xyXG5cclxuICAgIC8vIE1ldGhvZCAyOiBFeHRyYWN0IGZyb20gdGFibGUgcm93cyBpZiBhdmFpbGFibGVcclxuICAgIGNvbnN0IHRhYmxlUm93czogQXJyYXk8e3Z1bG5JZDogc3RyaW5nLCBzZXZlcml0eTogc3RyaW5nLCB0aXRsZTogc3RyaW5nfT4gPSBbXTtcclxuICAgIGNvbnN0IHJvd1BhdHRlcm4gPSAvPHRyW14+XSo+KFtcXHNcXFNdKj8pPFxcL3RyPi9naTtcclxuICAgIGxldCByb3dNYXRjaDtcclxuICAgIFxyXG4gICAgd2hpbGUgKChyb3dNYXRjaCA9IHJvd1BhdHRlcm4uZXhlYyhodG1sKSkgIT09IG51bGwpIHtcclxuICAgICAgY29uc3Qgcm93SHRtbCA9IHJvd01hdGNoWzFdO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyByb3cgaGFzIGEgdnVsbiBJRFxyXG4gICAgICBjb25zdCB2dWxuTWF0Y2ggPSByb3dIdG1sLm1hdGNoKC8+KFYtXFxkKyk8Lyk7XHJcbiAgICAgIGlmICghdnVsbk1hdGNoKSBjb250aW51ZTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHZ1bG5JZCA9IHZ1bG5NYXRjaFsxXTtcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3Qgc2V2ZXJpdHkgZnJvbSB0aGlzIHJvd1xyXG4gICAgICBjb25zdCBjYXRNYXRjaCA9IHJvd0h0bWwubWF0Y2goL0NBVFxccysoSXsxLDN9KS9pKTtcclxuICAgICAgY29uc3Qgc2V2TWF0Y2ggPSByb3dIdG1sLm1hdGNoKC8+KGhpZ2h8bWVkaXVtfGxvdyk8L2kpO1xyXG4gICAgICBjb25zdCBzZXZlcml0eSA9IGNhdE1hdGNoID8gY2F0TWF0Y2hbMV0gOiAoc2V2TWF0Y2ggPyBzZXZNYXRjaFsxXSA6ICdJSScpO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCB0aXRsZVxyXG4gICAgICBjb25zdCB0aXRsZU1hdGNoID0gcm93SHRtbC5tYXRjaCgvPGFbXj5dKmhyZWY9XCJbXlwiXSpcXC9yZXF1aXJlbWVudFxcL1teXCJdKlwiW14+XSo+KFtePF0rKTwvaSk7XHJcbiAgICAgIGNvbnN0IHRpdGxlID0gdGl0bGVNYXRjaCA/IHRpdGxlTWF0Y2hbMV0udHJpbSgpIDogYFJlcXVpcmVtZW50ICR7dnVsbklkfWA7XHJcbiAgICAgIFxyXG4gICAgICB0YWJsZVJvd3MucHVzaCh7IHZ1bG5JZCwgc2V2ZXJpdHksIHRpdGxlIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBNZXRob2QgMjogRm91bmQgJHt0YWJsZVJvd3MubGVuZ3RofSByZXF1aXJlbWVudHMgZnJvbSB0YWJsZSByb3dzYCk7XHJcblxyXG4gICAgLy8gTWV0aG9kIDM6IEZhbGxiYWNrIC0gZXh0cmFjdCBhbGwgVi0jIyMjIHdpdGggZGVmYXVsdCBkYXRhXHJcbiAgICBjb25zdCB2dWxuSWRQYXR0ZXJuID0gL1YtXFxkKy9nO1xyXG4gICAgY29uc3QgYWxsVnVsbklkcyA9IFsuLi5uZXcgU2V0KGh0bWwubWF0Y2godnVsbklkUGF0dGVybikgfHwgW10pXTtcclxuICAgIGNvbnNvbGUubG9nKGDwn5SNIE1ldGhvZCAzOiBGb3VuZCAke2FsbFZ1bG5JZHMubGVuZ3RofSB0b3RhbCBWLSMjIyMgcGF0dGVybnNgKTtcclxuXHJcbiAgICAvLyBVc2UgdGhlIG1ldGhvZCB0aGF0IGZvdW5kIHRoZSBtb3N0IHJlcXVpcmVtZW50c1xyXG4gICAgbGV0IHJlcURhdGE6IEFycmF5PHt2dWxuSWQ6IHN0cmluZywgc2V2ZXJpdHk6IHN0cmluZywgdGl0bGU6IHN0cmluZ30+ID0gW107XHJcbiAgICBcclxuICAgIGlmIChkZXRhaWxlZFJlcXMubGVuZ3RoID49IHRhYmxlUm93cy5sZW5ndGggJiYgZGV0YWlsZWRSZXFzLmxlbmd0aCA+IDApIHtcclxuICAgICAgcmVxRGF0YSA9IGRldGFpbGVkUmVxcztcclxuICAgICAgY29uc29sZS5sb2coYOKckyBVc2luZyBNZXRob2QgMTogJHtkZXRhaWxlZFJlcXMubGVuZ3RofSByZXF1aXJlbWVudHMgd2l0aCBzZXZlcml0eWApO1xyXG4gICAgfSBlbHNlIGlmICh0YWJsZVJvd3MubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXFEYXRhID0gdGFibGVSb3dzO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyTIFVzaW5nIE1ldGhvZCAyOiAke3RhYmxlUm93cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmcm9tIHRhYmxlc2ApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gRmFsbGJhY2s6IGNyZWF0ZSBiYXNpYyBlbnRyaWVzXHJcbiAgICAgIHJlcURhdGEgPSBhbGxWdWxuSWRzLm1hcCh2dWxuSWQgPT4gKHtcclxuICAgICAgICB2dWxuSWQsXHJcbiAgICAgICAgc2V2ZXJpdHk6ICdJSScsIC8vIGRlZmF1bHRcclxuICAgICAgICB0aXRsZTogYCR7c3RpZ05hbWV9IC0gJHt2dWxuSWR9YFxyXG4gICAgICB9KSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinJMgVXNpbmcgTWV0aG9kIDM6ICR7YWxsVnVsbklkcy5sZW5ndGh9IGJhc2ljIHJlcXVpcmVtZW50c2ApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGDwn5OdIFByb2Nlc3NpbmcgJHtyZXFEYXRhLmxlbmd0aH0gcmVxdWlyZW1lbnRzLi4uYCk7XHJcblxyXG4gICAgbGV0IHJlcXVpcmVtZW50Q291bnQgPSAwO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IHJlcSBvZiByZXFEYXRhKSB7XHJcbiAgICAgIGNvbnN0IHsgdnVsbklkLCBzZXZlcml0eTogcmF3U2V2ZXJpdHksIHRpdGxlIH0gPSByZXE7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IFJ1bGUgSUQgaWYgYXZhaWxhYmxlXHJcbiAgICAgIGNvbnN0IHJ1bGVQYXR0ZXJuID0gbmV3IFJlZ0V4cChgJHt2dWxuSWR9W15TXSo/KFNWLVxcXFxkK3JcXFxcZCtfcnVsZSlgLCAnaScpO1xyXG4gICAgICBjb25zdCBydWxlTWF0Y2ggPSBodG1sLm1hdGNoKHJ1bGVQYXR0ZXJuKTtcclxuICAgICAgY29uc3QgcnVsZUlkID0gcnVsZU1hdGNoID8gcnVsZU1hdGNoWzFdIDogYCR7dnVsbklkfS1ydWxlYDtcclxuICAgICAgXHJcbiAgICAgIC8vIE5vcm1hbGl6ZSBzZXZlcml0eVxyXG4gICAgICBsZXQgc2V2ZXJpdHk6ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdycgPSAnbWVkaXVtJztcclxuICAgICAgY29uc3Qgc2V2VGV4dCA9IHJhd1NldmVyaXR5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGlmIChzZXZUZXh0LmluY2x1ZGVzKCdpJykgJiYgIXNldlRleHQuaW5jbHVkZXMoJ2lpJykgfHwgc2V2VGV4dCA9PT0gJ2hpZ2gnIHx8IHNldlRleHQgPT09ICcxJykge1xyXG4gICAgICAgIHNldmVyaXR5ID0gJ2hpZ2gnO1xyXG4gICAgICB9IGVsc2UgaWYgKHNldlRleHQuaW5jbHVkZXMoJ2lpaScpIHx8IHNldlRleHQgPT09ICdsb3cnIHx8IHNldlRleHQgPT09ICczJykge1xyXG4gICAgICAgIHNldmVyaXR5ID0gJ2xvdyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2V2ZXJpdHkgPSAnbWVkaXVtJztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gRGVzY3JpcHRpb24gZGVmYXVsdHMgdG8gdGl0bGVcclxuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aXRsZTtcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgQ0NJIHJlZmVyZW5jZXMgLSBzZWFyY2ggZm9yIHRoaXMgdnVsbklkIGluIEhUTUxcclxuICAgICAgY29uc3QgdnVsbkNvbnRleHQgPSBodG1sLnN1YnN0cmluZyhcclxuICAgICAgICBNYXRoLm1heCgwLCBodG1sLmluZGV4T2YodnVsbklkKSAtIDMwMCksXHJcbiAgICAgICAgTWF0aC5taW4oaHRtbC5sZW5ndGgsIGh0bWwuaW5kZXhPZih2dWxuSWQpICsgMzAwKVxyXG4gICAgICApO1xyXG4gICAgICBjb25zdCBjY2lNYXRjaGVzID0gdnVsbkNvbnRleHQubWF0Y2goL0NDSS1cXGQrL2cpO1xyXG4gICAgICBjb25zdCBjY2kgPSBjY2lNYXRjaGVzICYmIGNjaU1hdGNoZXMubGVuZ3RoID4gMCA/IFsuLi5uZXcgU2V0KGNjaU1hdGNoZXMpXSA6IFsnQ0NJLTAwMDM2NiddO1xyXG4gICAgICBcclxuICAgICAgLy8gRGVmYXVsdCBjaGVjayBhbmQgZml4IHRleHQgd2l0aCBub3RlIGFib3V0IGZ1bGwgZG9jdW1lbnRhdGlvblxyXG4gICAgICBjb25zdCBjaGVja1RleHQgPSBgUmV2aWV3IHRoZSBzeXN0ZW0gY29uZmlndXJhdGlvbiB0byB2ZXJpZnkgY29tcGxpYW5jZSB3aXRoICR7dnVsbklkfS4gUmVmZXIgdG8gdGhlIGZ1bGwgU1RJRyBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxlZCBjaGVjayBwcm9jZWR1cmVzLmA7XHJcbiAgICAgIGNvbnN0IGZpeFRleHQgPSBgQ29uZmlndXJlIHRoZSBzeXN0ZW0gdG8gbWVldCB0aGUgcmVxdWlyZW1lbnRzIHNwZWNpZmllZCBpbiAke3Z1bG5JZH0uIFJlZmVyIHRvIHRoZSBmdWxsIFNUSUcgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlsZWQgZml4IHByb2NlZHVyZXMuYDtcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgTklTVCBjb250cm9scyBmcm9tIGNvbnRleHRcclxuICAgICAgY29uc3QgbmlzdE1hdGNoZXMgPSB2dWxuQ29udGV4dC5tYXRjaCgvKFtBLVpdezJ9LVxcZCsoPzpcXHMqXFwoW2EtejAtOV0rXFwpKT8pL2cpO1xyXG4gICAgICBjb25zdCBuaXN0Q29udHJvbHMgPSBuaXN0TWF0Y2hlcyA/IFsuLi5uZXcgU2V0KG5pc3RNYXRjaGVzKV0gOiBbXTtcclxuICAgICAgXHJcbiAgICAgIHJlcXVpcmVtZW50cy5wdXNoKHtcclxuICAgICAgICB2dWxuSWQsXHJcbiAgICAgICAgcnVsZUlkLFxyXG4gICAgICAgIHNldmVyaXR5LFxyXG4gICAgICAgIHRpdGxlLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uLFxyXG4gICAgICAgIGNoZWNrVGV4dCxcclxuICAgICAgICBmaXhUZXh0LFxyXG4gICAgICAgIGNjaSxcclxuICAgICAgICBuaXN0Q29udHJvbHNcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICByZXF1aXJlbWVudENvdW50Kys7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgcGFyc2VkICR7cmVxdWlyZW1lbnRDb3VudH0gcmVxdWlyZW1lbnRzIGZyb20gSFRNTGApO1xyXG4gICAgXHJcbiAgICAvLyBMb2cgc2V2ZXJpdHkgZGlzdHJpYnV0aW9uXHJcbiAgICBjb25zdCBzZXZlcml0eURpc3Q6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuICAgIHJlcXVpcmVtZW50cy5mb3JFYWNoKHJlcSA9PiB7XHJcbiAgICAgIHNldmVyaXR5RGlzdFtyZXEuc2V2ZXJpdHldID0gKHNldmVyaXR5RGlzdFtyZXEuc2V2ZXJpdHldIHx8IDApICsgMTtcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coYPCfk4ogQVBJIFNldmVyaXR5IERpc3RyaWJ1dGlvbjpgLCBzZXZlcml0eURpc3QpO1xyXG5cclxuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueSByZXF1aXJlbWVudHMgaW4gdGFibGUgZm9ybWF0LCB0cnkgYWx0ZXJuYXRpdmUgcGFyc2luZ1xyXG4gICAgaWYgKHJlcXVpcmVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTm8gcmVxdWlyZW1lbnRzIGZvdW5kIGluIHRhYmxlIGZvcm1hdCwgdHJ5aW5nIGFsdGVybmF0aXZlIHBhcnNpbmcuLi4nKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFRyeSB0byBmaW5kIGFsbCBWLSMjIyMgcGF0dGVybnMgYW5kIGNyZWF0ZSBiYXNpYyByZXF1aXJlbWVudHNcclxuICAgICAgY29uc3QgdnVsbklkUGF0dGVybiA9IC9WLVxcZCsvZztcclxuICAgICAgY29uc3QgdnVsbklkcyA9IFsuLi5uZXcgU2V0KGh0bWwubWF0Y2godnVsbklkUGF0dGVybikgfHwgW10pXTtcclxuICAgICAgXHJcbiAgICAgIHZ1bG5JZHMuZm9yRWFjaCgodnVsbklkLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIHJlcXVpcmVtZW50cy5wdXNoKHtcclxuICAgICAgICAgIHZ1bG5JZCxcclxuICAgICAgICAgIHJ1bGVJZDogYCR7dnVsbklkfS1ydWxlYCxcclxuICAgICAgICAgIHNldmVyaXR5OiAnbWVkaXVtJyxcclxuICAgICAgICAgIHRpdGxlOiBgJHtzdGlnTmFtZX0gLSAke3Z1bG5JZH1gLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBTZWN1cml0eSByZXF1aXJlbWVudCAke3Z1bG5JZH0gZnJvbSAke3N0aWdOYW1lfWAsXHJcbiAgICAgICAgICBjaGVja1RleHQ6ICdSZXZpZXcgdGhlIHN5c3RlbSBjb25maWd1cmF0aW9uIHRvIHZlcmlmeSBjb21wbGlhbmNlLiBEZXRhaWxlZCBjaGVjayBwcm9jZWR1cmUgYXZhaWxhYmxlIGluIHRoZSBmdWxsIFNUSUcgZG9jdW1lbnRhdGlvbi4nLFxyXG4gICAgICAgICAgZml4VGV4dDogJ0NvbmZpZ3VyZSB0aGUgc3lzdGVtIHRvIG1lZXQgdGhlIHNlY3VyaXR5IHJlcXVpcmVtZW50LiBEZXRhaWxlZCBmaXggcHJvY2VkdXJlIGF2YWlsYWJsZSBpbiB0aGUgZnVsbCBTVElHIGRvY3VtZW50YXRpb24uJyxcclxuICAgICAgICAgIGNjaTogWydDQ0ktMDAwMzY2J10sXHJcbiAgICAgICAgICBuaXN0Q29udHJvbHM6IFtdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYPCfk50gQ3JlYXRlZCAke3JlcXVpcmVtZW50cy5sZW5ndGh9IGJhc2ljIHJlcXVpcmVtZW50cyBmcm9tIFZ1bG4gSURzYCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RpZ0lkLFxyXG4gICAgICBzdGlnTmFtZSxcclxuICAgICAgdmVyc2lvbixcclxuICAgICAgcmVsZWFzZURhdGUsXHJcbiAgICAgIHJlcXVpcmVtZW50cyxcclxuICAgICAgdG90YWxSZXF1aXJlbWVudHM6IHJlcXVpcmVtZW50cy5sZW5ndGhcclxuICAgIH07XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgc3RpZ3ZpZXdlci5jb20gSFRNTDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdGlndmlld2VyLmNvbSBwYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgWENDREYgWE1MIGZpbGUgdG8gZXh0cmFjdCBTVElHIHJlcXVpcmVtZW50c1xyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VYY2NkZlhtbCh4bWxDb250ZW50OiBzdHJpbmcsIGZpbGVOYW1lOiBzdHJpbmcpOiBPbWl0PFN0aWdJbXBvcnRSZXN1bHQsICdzdWNjZXNzJyB8ICdzb3VyY2UnIHwgJ21lc3NhZ2UnPiB7XHJcbiAgY29uc3QgcmVxdWlyZW1lbnRzOiBTdGlnUmVxdWlyZW1lbnRbXSA9IFtdO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gRXh0cmFjdCBTVElHIElEIGZyb20gZmlsZW5hbWVcclxuICAgIGNvbnN0IHN0aWdJZCA9IGZpbGVOYW1lLnJlcGxhY2UoL1xcLnhtbHxcXC54Y2NkZi9naSwgJycpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnXycpO1xyXG5cclxuICAgIC8vIFBhcnNlIFhNTCB1c2luZyByZWdleCAoc2ltcGxpZmllZCAtIGluIHByb2R1Y3Rpb24gdXNlIGEgcHJvcGVyIFhNTCBwYXJzZXIpXHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgQmVuY2htYXJrIHRpdGxlXHJcbiAgICBjb25zdCB0aXRsZU1hdGNoID0geG1sQ29udGVudC5tYXRjaCgvPHRpdGxlW14+XSo+KFtePF0rKTxcXC90aXRsZT4vaSk7XHJcbiAgICBjb25zdCBzdGlnTmFtZSA9IHRpdGxlTWF0Y2ggPyB0aXRsZU1hdGNoWzFdLnRyaW0oKSA6IHN0aWdJZDtcclxuXHJcbiAgICAvLyBFeHRyYWN0IHZlcnNpb25cclxuICAgIGNvbnN0IHZlcnNpb25NYXRjaCA9IHhtbENvbnRlbnQubWF0Y2goLzx2ZXJzaW9uW14+XSo+KFtePF0rKTxcXC92ZXJzaW9uPi9pKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxDb250ZW50Lm1hdGNoKC9WZXJzaW9uWzpcXHNdKyhbVnZSclxcZC5dKykvaSk7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbk1hdGNoID8gdmVyc2lvbk1hdGNoWzFdIDogJ1Vua25vd24nO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgcmVsZWFzZSBkYXRlXHJcbiAgICBjb25zdCBkYXRlTWF0Y2ggPSB4bWxDb250ZW50Lm1hdGNoKC9yZWxlYXNlLWRhdGVbXj5dKj4oW148XSspPC9pKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICB4bWxDb250ZW50Lm1hdGNoKC8oXFxkezEsMn1cXHMrXFx3K1xccytcXGR7NH0pLyk7XHJcbiAgICBjb25zdCByZWxlYXNlRGF0ZSA9IGRhdGVNYXRjaCA/IGRhdGVNYXRjaFsxXSA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgYWxsIEdyb3VwIGVsZW1lbnRzIChyZXF1aXJlbWVudHMpXHJcbiAgICBjb25zdCBncm91cFBhdHRlcm4gPSAvPEdyb3VwW14+XSppZD1cIihbXlwiXSspXCJbXj5dKj4oW1xcc1xcU10qPyk8XFwvR3JvdXA+L2dpO1xyXG4gICAgbGV0IGdyb3VwTWF0Y2g7XHJcblxyXG4gICAgd2hpbGUgKChncm91cE1hdGNoID0gZ3JvdXBQYXR0ZXJuLmV4ZWMoeG1sQ29udGVudCkpICE9PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IGdyb3VwSWQgPSBncm91cE1hdGNoWzFdO1xyXG4gICAgICBjb25zdCBncm91cENvbnRlbnQgPSBncm91cE1hdGNoWzJdO1xyXG5cclxuICAgICAgLy8gRXh0cmFjdCBSdWxlIGZyb20gR3JvdXBcclxuICAgICAgY29uc3QgcnVsZU1hdGNoID0gZ3JvdXBDb250ZW50Lm1hdGNoKC88UnVsZVtePl0qaWQ9XCIoW15cIl0rKVwiW14+XSpzZXZlcml0eT1cIihbXlwiXSspXCJbXj5dKj4oW1xcc1xcU10qPyk8XFwvUnVsZT4vaSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAocnVsZU1hdGNoKSB7XHJcbiAgICAgICAgY29uc3QgcnVsZUlkID0gcnVsZU1hdGNoWzFdO1xyXG4gICAgICAgIGNvbnN0IHNldmVyaXR5ID0gcnVsZU1hdGNoWzJdLnRvTG93ZXJDYXNlKCkgYXMgJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JztcclxuICAgICAgICBjb25zdCBydWxlQ29udGVudCA9IHJ1bGVNYXRjaFszXTtcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCB0aXRsZVxyXG4gICAgICAgIGNvbnN0IHRpdGxlTWF0Y2ggPSBydWxlQ29udGVudC5tYXRjaCgvPHRpdGxlW14+XSo+KFtePF0rKTxcXC90aXRsZT4vaSk7XHJcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aXRsZU1hdGNoID8gdGl0bGVNYXRjaFsxXS50cmltKCkgOiBgUmVxdWlyZW1lbnQgJHtncm91cElkfWA7XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgZGVzY3JpcHRpb25cclxuICAgICAgICBjb25zdCBkZXNjTWF0Y2ggPSBydWxlQ29udGVudC5tYXRjaCgvPGRlc2NyaXB0aW9uW14+XSo+KFtcXHNcXFNdKj8pPFxcL2Rlc2NyaXB0aW9uPi9pKTtcclxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGRlc2NNYXRjaCA/IHN0cmlwSHRtbChkZXNjTWF0Y2hbMV0pIDogJyc7XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgY2hlY2sgdGV4dFxyXG4gICAgICAgIGNvbnN0IGNoZWNrTWF0Y2ggPSBydWxlQ29udGVudC5tYXRjaCgvPGNoZWNrLWNvbnRlbnRbXj5dKj4oW1xcc1xcU10qPyk8XFwvY2hlY2stY29udGVudD4vaSk7XHJcbiAgICAgICAgY29uc3QgY2hlY2tUZXh0ID0gY2hlY2tNYXRjaCA/IHN0cmlwSHRtbChjaGVja01hdGNoWzFdKSA6ICdObyBjaGVjayBwcm9jZWR1cmUgcHJvdmlkZWQnO1xyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IGZpeCB0ZXh0XHJcbiAgICAgICAgY29uc3QgZml4TWF0Y2ggPSBydWxlQ29udGVudC5tYXRjaCgvPGZpeHRleHRbXj5dKj4oW1xcc1xcU10qPyk8XFwvZml4dGV4dD4vaSk7XHJcbiAgICAgICAgY29uc3QgZml4VGV4dCA9IGZpeE1hdGNoID8gc3RyaXBIdG1sKGZpeE1hdGNoWzFdKSA6ICdObyBmaXggcHJvY2VkdXJlIHByb3ZpZGVkJztcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBDQ0kgcmVmZXJlbmNlc1xyXG4gICAgICAgIGNvbnN0IGNjaVBhdHRlcm4gPSAvPGlkZW50W14+XSpzeXN0ZW09XCJodHRwOlxcL1xcL2N5YmVyXFwubWlsXFwvbGVnYWN5XFwvY2NpXCJbXj5dKj4oW148XSspPFxcL2lkZW50Pi9naTtcclxuICAgICAgICBjb25zdCBjY2k6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgbGV0IGNjaU1hdGNoO1xyXG4gICAgICAgIHdoaWxlICgoY2NpTWF0Y2ggPSBjY2lQYXR0ZXJuLmV4ZWMocnVsZUNvbnRlbnQpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgY2NpLnB1c2goY2NpTWF0Y2hbMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBOSVNUIGNvbnRyb2xzXHJcbiAgICAgICAgY29uc3QgbmlzdFBhdHRlcm4gPSAvPHJlZmVyZW5jZVtePl0qPihbXFxzXFxTXSo/KU5JU1RbXjxdKihbQS1aXXsyfS1cXGQrKD86XFxzKlxcKFxcZCtcXCkpPyg/OlxccypbYS16XSk/KVtePF0qKFtcXHNcXFNdKj8pPFxcL3JlZmVyZW5jZT4vZ2k7XHJcbiAgICAgICAgY29uc3QgbmlzdENvbnRyb2xzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGxldCBuaXN0TWF0Y2g7XHJcbiAgICAgICAgd2hpbGUgKChuaXN0TWF0Y2ggPSBuaXN0UGF0dGVybi5leGVjKHJ1bGVDb250ZW50KSkgIT09IG51bGwpIHtcclxuICAgICAgICAgIGNvbnN0IGNvbnRyb2wgPSBuaXN0TWF0Y2hbMl0udHJpbSgpO1xyXG4gICAgICAgICAgaWYgKGNvbnRyb2wgJiYgIW5pc3RDb250cm9scy5pbmNsdWRlcyhjb250cm9sKSkge1xyXG4gICAgICAgICAgICBuaXN0Q29udHJvbHMucHVzaChjb250cm9sKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlcXVpcmVtZW50cy5wdXNoKHtcclxuICAgICAgICAgIHZ1bG5JZDogZ3JvdXBJZCxcclxuICAgICAgICAgIHJ1bGVJZCxcclxuICAgICAgICAgIHNldmVyaXR5LFxyXG4gICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24uc3Vic3RyaW5nKDAsIDUwMCksIC8vIExpbWl0IGRlc2NyaXB0aW9uIGxlbmd0aFxyXG4gICAgICAgICAgY2hlY2tUZXh0OiBjaGVja1RleHQuc3Vic3RyaW5nKDAsIDEwMDApLFxyXG4gICAgICAgICAgZml4VGV4dDogZml4VGV4dC5zdWJzdHJpbmcoMCwgMTAwMCksXHJcbiAgICAgICAgICBjY2k6IGNjaS5sZW5ndGggPiAwID8gY2NpIDogWydDQ0ktMDAwMDAwJ10sXHJcbiAgICAgICAgICBuaXN0Q29udHJvbHM6IG5pc3RDb250cm9scy5sZW5ndGggPiAwID8gbmlzdENvbnRyb2xzIDogWydBQy0xJ11cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXF1aXJlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVxdWlyZW1lbnRzIGZvdW5kIGluIFhNTC4gVGhlIGZpbGUgbWF5IG5vdCBiZSBhIHZhbGlkIFhDQ0RGIFNUSUcgZmlsZS4nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGlnSWQsXHJcbiAgICAgIHN0aWdOYW1lLFxyXG4gICAgICB2ZXJzaW9uLFxyXG4gICAgICByZWxlYXNlRGF0ZSxcclxuICAgICAgcmVxdWlyZW1lbnRzLFxyXG4gICAgICB0b3RhbFJlcXVpcmVtZW50czogcmVxdWlyZW1lbnRzLmxlbmd0aFxyXG4gICAgfTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBYQ0NERiBYTUw6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgWENDREYgWE1MOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU3RyaXAgSFRNTCB0YWdzIGFuZCBkZWNvZGUgZW50aXRpZXNcclxuICovXHJcbmZ1bmN0aW9uIHN0cmlwSHRtbChodG1sOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIHJldHVybiBodG1sXHJcbiAgICAucmVwbGFjZSgvPFtePl0rPi9nLCAnJykgLy8gUmVtb3ZlIEhUTUwgdGFnc1xyXG4gICAgLnJlcGxhY2UoLyZsdDsvZywgJzwnKVxyXG4gICAgLnJlcGxhY2UoLyZndDsvZywgJz4nKVxyXG4gICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJylcclxuICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcclxuICAgIC5yZXBsYWNlKC8mIzM5Oy9nLCBcIidcIilcclxuICAgIC5yZXBsYWNlKC8mbmJzcDsvZywgJyAnKVxyXG4gICAgLnJlcGxhY2UoL1xccysvZywgJyAnKSAvLyBOb3JtYWxpemUgd2hpdGVzcGFjZVxyXG4gICAgLnRyaW0oKTtcclxufVxyXG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiaHR0cHMiLCJoYXNMb2NhbFN0aWciLCJnZXRMb2NhbFN0aWdDb250ZW50IiwiZ2V0TG9jYWxTdGlnTWV0YWRhdGEiLCJHRVQiLCJyZXF1ZXN0Iiwic2VhcmNoUGFyYW1zIiwiVVJMIiwidXJsIiwic3RpZ0lkIiwiZ2V0IiwianNvbiIsImVycm9yIiwic3RhdHVzIiwiY29uc29sZSIsImxvZyIsIm1ldGFkYXRhIiwiY29udGVudCIsImZpbGVuYW1lIiwiaXNYbWwiLCJmb3JtYXQiLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwic3RpZ0RhdGEiLCJwYXJzZVhjY2RmWG1sIiwicmVxdWlyZW1lbnRzIiwibGVuZ3RoIiwic3VjY2VzcyIsInZlcnNpb24iLCJyZWxlYXNlRGF0ZSIsInNvdXJjZSIsIm1lc3NhZ2UiLCJwYXJzZVN0aWdDc3YiLCJzdGlnTmFtZSIsIm5hbWUiLCJsb2NhbEVycm9yIiwianNvblVybCIsImh0bWxVcmwiLCJhZ2VudCIsIkFnZW50IiwicmVqZWN0VW5hdXRob3JpemVkIiwianNvblJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJ0aW1lb3V0Iiwib2siLCJqc29uRGF0YSIsInBhcnNlU3RpZ1ZpZXdlckpzb24iLCJzdGF0dXNUZXh0IiwianNvbkVycm9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicmVzcG9uc2UiLCJFcnJvciIsImh0bWwiLCJ0ZXh0IiwicGFyc2VTdGlnVmlld2VySHRtbCIsImZldGNoRXJyb3IiLCJlcnJvckd1aWRhbmNlIiwiaW5jbHVkZXMiLCJpbnN0cnVjdGlvbnMiLCJzdGVwMSIsInN0ZXAyIiwic3RlcDMiLCJjc3ZDb250ZW50IiwiZmlsZU5hbWUiLCJsaW5lcyIsImN1cnJlbnRMaW5lIiwiaW5zaWRlUXVvdGVzIiwiaSIsImNoYXIiLCJuZXh0Q2hhciIsInRyaW0iLCJwdXNoIiwicmVwbGFjZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwidG90YWxSZXF1aXJlbWVudHMiLCJwYXJzZUNTVkxpbmUiLCJsaW5lIiwicmVzdWx0IiwiY3VycmVudCIsImluUXVvdGVzIiwiaGVhZGVyTGluZUluZGV4IiwiTWF0aCIsIm1pbiIsInBhcnNlZExpbmUiLCJsaW5lVGV4dCIsImpvaW4iLCJtYXAiLCJoIiwic2xpY2UiLCJnZXRJbmRleCIsIm5hbWVzIiwiaWR4IiwiZmluZEluZGV4Iiwic3RpZ0lkSWR4Iiwic2V2ZXJpdHlJZHgiLCJ0aXRsZUlkeCIsImRpc2N1c3Npb25JZHgiLCJjaGVja0lkeCIsImZpeElkeCIsImNjaUlkeCIsInJ1bGVJZElkeCIsInNldmVyaXR5IiwidGl0bGUiLCJkaXNjdXNzaW9uIiwiY2hlY2siLCJmaXgiLCJjY2kiLCJydWxlSWQiLCJ2YWx1ZXMiLCJiZW5jaG1hcmtJZHgiLCJ2ZXJzaW9uSWR4IiwidnVsbklkIiwic2V2ZXJpdHlWYWx1ZSIsImNjaVRleHQiLCJjY2lNYXRjaGVzIiwibWF0Y2giLCJkZXNjcmlwdGlvbiIsImNoZWNrVGV4dCIsImZpeFRleHQiLCJuaXN0Q29udHJvbHMiLCJQT1NUIiwiZm9ybURhdGEiLCJmaWxlIiwiaXNDc3YiLCJmaWxlQ29udGVudCIsImZldGNoUmVxdWlyZW1lbnREZXRhaWxzIiwiY2hlY2tNYXRjaCIsImZpeE1hdGNoIiwic3RpZyIsImRhdGUiLCJmaW5kaW5ncyIsInZ1bG5JZHMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImZpbmRpbmciLCJzZXZUZXh0IiwiY2F0IiwidG9TdHJpbmciLCJydWxlX2lkIiwicnVsZWlkIiwicnVsZVRpdGxlIiwicnVsZXRpdGxlIiwiY2hlY2t0ZXh0IiwiY2hlY2tfdGV4dCIsImZpeHRleHQiLCJmaXhfdGV4dCIsImNjaXMiLCJuaXN0Iiwic2V2ZXJpdHlEaXN0IiwicmVxIiwidGl0bGVNYXRjaCIsInZlcnNpb25NYXRjaCIsImRhdGVNYXRjaCIsInJlcVNlY3Rpb25QYXR0ZXJuIiwiZGV0YWlsZWRSZXFzIiwiZXhlYyIsInRhYmxlUm93cyIsInJvd1BhdHRlcm4iLCJyb3dNYXRjaCIsInJvd0h0bWwiLCJ2dWxuTWF0Y2giLCJjYXRNYXRjaCIsInNldk1hdGNoIiwidnVsbklkUGF0dGVybiIsImFsbFZ1bG5JZHMiLCJTZXQiLCJyZXFEYXRhIiwicmVxdWlyZW1lbnRDb3VudCIsInJhd1NldmVyaXR5IiwicnVsZVBhdHRlcm4iLCJSZWdFeHAiLCJydWxlTWF0Y2giLCJ2dWxuQ29udGV4dCIsInN1YnN0cmluZyIsIm1heCIsImluZGV4T2YiLCJuaXN0TWF0Y2hlcyIsIndhcm4iLCJpbmRleCIsInhtbENvbnRlbnQiLCJncm91cFBhdHRlcm4iLCJncm91cE1hdGNoIiwiZ3JvdXBJZCIsImdyb3VwQ29udGVudCIsInJ1bGVDb250ZW50IiwiZGVzY01hdGNoIiwic3RyaXBIdG1sIiwiY2NpUGF0dGVybiIsImNjaU1hdGNoIiwibmlzdFBhdHRlcm4iLCJuaXN0TWF0Y2giLCJjb250cm9sIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/import-stig/route.ts\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/./node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/./node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var C_Users_ronni_OneDrive_Desktop_Projects_SRTM_tool_app_api_import_stig_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./app/api/import-stig/route.ts */ \"(rsc)/./app/api/import-stig/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/import-stig/route\",\n        pathname: \"/api/import-stig\",\n        filename: \"route\",\n        bundlePath: \"app/api/import-stig/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"C:\\\\Users\\\\ronni\\\\OneDrive\\\\Desktop\\\\Projects\\\\SRTM-tool\\\\app\\\\api\\\\import-stig\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_ronni_OneDrive_Desktop_Projects_SRTM_tool_app_api_import_stig_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/import-stig/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZpbXBvcnQtc3RpZyUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGaW1wb3J0LXN0aWclMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZpbXBvcnQtc3RpZyUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNyb25uaSU1Q09uZURyaXZlJTVDRGVza3RvcCU1Q1Byb2plY3RzJTVDU1JUTS10b29sJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1DJTNBJTVDVXNlcnMlNUNyb25uaSU1Q09uZURyaXZlJTVDRGVza3RvcCU1Q1Byb2plY3RzJTVDU1JUTS10b29sJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PXN0YW5kYWxvbmUmcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCZpc0dsb2JhbE5vdEZvdW5kRW5hYmxlZD0hIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ3FCO0FBQ2Q7QUFDUztBQUNPO0FBQ0s7QUFDbUM7QUFDakQ7QUFDTztBQUNmO0FBQ3NDO0FBQ3pCO0FBQ007QUFDQztBQUNoQjtBQUNvRDtBQUN0SDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhLE9BQW9DLElBQUksQ0FBRTtBQUN2RCx3QkFBd0IsTUFBdUM7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NkNBQTZDLDBGQUFxQjtBQUNsRTtBQUNBLGtCQUFrQiw2RUFBWTtBQUM5QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2RUFBNkUsZ0ZBQWM7QUFDM0YsaUNBQWlDLFFBQVEsRUFBRSxRQUFRO0FBQ25ELDBCQUEwQix1RUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTiw2QkFBNkIsNkZBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkZBQW1CO0FBQ3JEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZFQUFZO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCB7IGdldFJlcXVlc3RNZXRhIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcmVxdWVzdC1tZXRhXCI7XG5pbXBvcnQgeyBnZXRUcmFjZXIsIFNwYW5LaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL3RyYWNlclwiO1xuaW1wb3J0IHsgbm9ybWFsaXplQXBwUGF0aCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYXBwLXBhdGhzXCI7XG5pbXBvcnQgeyBOb2RlTmV4dFJlcXVlc3QsIE5vZGVOZXh0UmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9iYXNlLWh0dHAvbm9kZVwiO1xuaW1wb3J0IHsgTmV4dFJlcXVlc3RBZGFwdGVyLCBzaWduYWxGcm9tTm9kZVJlc3BvbnNlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL25leHQtcmVxdWVzdFwiO1xuaW1wb3J0IHsgQmFzZVNlcnZlclNwYW4gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBnZXRSZXZhbGlkYXRlUmVhc29uIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvaW5zdHJ1bWVudGF0aW9uL3V0aWxzXCI7XG5pbXBvcnQgeyBzZW5kUmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9zZW5kLXJlc3BvbnNlXCI7XG5pbXBvcnQgeyBmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMsIHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci93ZWIvdXRpbHNcIjtcbmltcG9ydCB7IGdldENhY2hlQ29udHJvbEhlYWRlciB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9jYWNoZS1jb250cm9sXCI7XG5pbXBvcnQgeyBJTkZJTklURV9DQUNIRSwgTkVYVF9DQUNIRV9UQUdTX0hFQURFUiB9IGZyb20gXCJuZXh0L2Rpc3QvbGliL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgTm9GYWxsYmFja0Vycm9yIH0gZnJvbSBcIm5leHQvZGlzdC9zaGFyZWQvbGliL25vLWZhbGxiYWNrLWVycm9yLmV4dGVybmFsXCI7XG5pbXBvcnQgeyBDYWNoZWRSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZXNwb25zZS1jYWNoZVwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIkM6XFxcXFVzZXJzXFxcXHJvbm5pXFxcXE9uZURyaXZlXFxcXERlc2t0b3BcXFxcUHJvamVjdHNcXFxcU1JUTS10b29sXFxcXGFwcFxcXFxhcGlcXFxcaW1wb3J0LXN0aWdcXFxccm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwic3RhbmRhbG9uZVwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9pbXBvcnQtc3RpZy9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2ltcG9ydC1zdGlnXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9pbXBvcnQtc3RpZy9yb3V0ZVwiXG4gICAgfSxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcmVsYXRpdmVQcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJycsXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJDOlxcXFxVc2Vyc1xcXFxyb25uaVxcXFxPbmVEcml2ZVxcXFxEZXNrdG9wXFxcXFByb2plY3RzXFxcXFNSVE0tdG9vbFxcXFxhcHBcXFxcYXBpXFxcXGltcG9ydC1zdGlnXFxcXHJvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICAgICAgd29ya1VuaXRBc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIHBhdGNoRmV0Y2gsICB9O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMsIGN0eCkge1xuICAgIHZhciBfbmV4dENvbmZpZ19leHBlcmltZW50YWw7XG4gICAgbGV0IHNyY1BhZ2UgPSBcIi9hcGkvaW1wb3J0LXN0aWcvcm91dGVcIjtcbiAgICAvLyB0dXJib3BhY2sgZG9lc24ndCBub3JtYWxpemUgYC9pbmRleGAgaW4gdGhlIHBhZ2UgbmFtZVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gdG8gcHJvY2VzcyBkeW5hbWljIHJvdXRlcyBwcm9wZXJseVxuICAgIC8vIFRPRE86IGZpeCB0dXJib3BhY2sgcHJvdmlkaW5nIGRpZmZlcmluZyB2YWx1ZSBmcm9tIHdlYnBhY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIHNyY1BhZ2UgPSBzcmNQYWdlLnJlcGxhY2UoL1xcL2luZGV4JC8sICcnKSB8fCAnLyc7XG4gICAgfSBlbHNlIGlmIChzcmNQYWdlID09PSAnL2luZGV4Jykge1xuICAgICAgICAvLyB3ZSBhbHdheXMgbm9ybWFsaXplIC9pbmRleCBzcGVjaWZpY2FsbHlcbiAgICAgICAgc3JjUGFnZSA9ICcvJztcbiAgICB9XG4gICAgY29uc3QgbXVsdGlab25lRHJhZnRNb2RlID0gcHJvY2Vzcy5lbnYuX19ORVhUX01VTFRJX1pPTkVfRFJBRlRfTU9ERTtcbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlLFxuICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGVcbiAgICB9KTtcbiAgICBpZiAoIXByZXBhcmVSZXN1bHQpIHtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgIHJlcy5lbmQoJ0JhZCBSZXF1ZXN0Jyk7XG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVpbGRJZCwgcGFyYW1zLCBuZXh0Q29uZmlnLCBpc0RyYWZ0TW9kZSwgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQsIGlzT25EZW1hbmRSZXZhbGlkYXRlLCByZXZhbGlkYXRlT25seUdlbmVyYXRlZCwgcmVzb2x2ZWRQYXRobmFtZSB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICBjb25zdCBub3JtYWxpemVkU3JjUGFnZSA9IG5vcm1hbGl6ZUFwcFBhdGgoc3JjUGFnZSk7XG4gICAgbGV0IGlzSXNyID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSB8fCBwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgIGlmIChpc0lzciAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY29uc3QgaXNQcmVyZW5kZXJlZCA9IEJvb2xlYW4ocHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW3Jlc29sdmVkUGF0aG5hbWVdKTtcbiAgICAgICAgY29uc3QgcHJlcmVuZGVySW5mbyA9IHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdO1xuICAgICAgICBpZiAocHJlcmVuZGVySW5mbykge1xuICAgICAgICAgICAgaWYgKHByZXJlbmRlckluZm8uZmFsbGJhY2sgPT09IGZhbHNlICYmICFpc1ByZXJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vRmFsbGJhY2tFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjYWNoZUtleSA9IG51bGw7XG4gICAgaWYgKGlzSXNyICYmICFyb3V0ZU1vZHVsZS5pc0RldiAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY2FjaGVLZXkgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAvLyBlbnN1cmUgL2luZGV4IGFuZCAvIGlzIG5vcm1hbGl6ZWQgdG8gb25lIGtleVxuICAgICAgICBjYWNoZUtleSA9IGNhY2hlS2V5ID09PSAnL2luZGV4JyA/ICcvJyA6IGNhY2hlS2V5O1xuICAgIH1cbiAgICBjb25zdCBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSA9IC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50LCB3ZSBhbHdheXMgc3VwcG9ydCBkeW5hbWljIEhUTUxcbiAgICByb3V0ZU1vZHVsZS5pc0RldiA9PT0gdHJ1ZSB8fCAvLyBJZiB0aGlzIGlzIG5vdCBTU0cgb3IgZG9lcyBub3QgaGF2ZSBzdGF0aWMgcGF0aHMsIHRoZW4gaXQgc3VwcG9ydHNcbiAgICAvLyBkeW5hbWljIEhUTUwuXG4gICAgIWlzSXNyO1xuICAgIC8vIFRoaXMgaXMgYSByZXZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWNcbiAgICAvLyBwYWdlIGFuZCBpdCBpcyBub3QgYmVpbmcgcmVzdW1lZCBmcm9tIGEgcG9zdHBvbmVkIHJlbmRlciBhbmRcbiAgICAvLyBpdCBpcyBub3QgYSBkeW5hbWljIFJTQyByZXF1ZXN0IHRoZW4gaXQgaXMgYSByZXZhbGlkYXRpb25cbiAgICAvLyByZXF1ZXN0LlxuICAgIGNvbnN0IGlzUmV2YWxpZGF0ZSA9IGlzSXNyICYmICFzdXBwb3J0c0R5bmFtaWNSZXNwb25zZTtcbiAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsOiB7XG4gICAgICAgICAgICAgICAgY2FjaGVDb21wb25lbnRzOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmNhY2hlQ29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgYXV0aEludGVycnVwdHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuYXV0aEludGVycnVwdHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2UsXG4gICAgICAgICAgICBpbmNyZW1lbnRhbENhY2hlOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbmNyZW1lbnRhbENhY2hlJyksXG4gICAgICAgICAgICBjYWNoZUxpZmVQcm9maWxlczogKF9uZXh0Q29uZmlnX2V4cGVyaW1lbnRhbCA9IG5leHRDb25maWcuZXhwZXJpbWVudGFsKSA9PSBudWxsID8gdm9pZCAwIDogX25leHRDb25maWdfZXhwZXJpbWVudGFsLmNhY2hlTGlmZSxcbiAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbCxcbiAgICAgICAgICAgIG9uQ2xvc2U6IChjYik9PntcbiAgICAgICAgICAgICAgICByZXMub24oJ2Nsb3NlJywgY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQWZ0ZXJUYXNrRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uSW5zdHJ1bWVudGF0aW9uUmVxdWVzdEVycm9yOiAoZXJyb3IsIF9yZXF1ZXN0LCBlcnJvckNvbnRleHQpPT5yb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVycm9yLCBlcnJvckNvbnRleHQsIHJvdXRlclNlcnZlckNvbnRleHQpXG4gICAgICAgIH0sXG4gICAgICAgIHNoYXJlZENvbnRleHQ6IHtcbiAgICAgICAgICAgIGJ1aWxkSWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9kZU5leHRSZXEgPSBuZXcgTm9kZU5leHRSZXF1ZXN0KHJlcSk7XG4gICAgY29uc3Qgbm9kZU5leHRSZXMgPSBuZXcgTm9kZU5leHRSZXNwb25zZShyZXMpO1xuICAgIGNvbnN0IG5leHRSZXEgPSBOZXh0UmVxdWVzdEFkYXB0ZXIuZnJvbU5vZGVOZXh0UmVxdWVzdChub2RlTmV4dFJlcSwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZShyZXMpKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnZva2VSb3V0ZU1vZHVsZSA9IGFzeW5jIChzcGFuKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlTW9kdWxlLmhhbmRsZShuZXh0UmVxLCBjb250ZXh0KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gYXN5bmMgKGN1cnJlbnRTcGFuKT0+e1xuICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VHZW5lcmF0b3IgPSBhc3luYyAoeyBwcmV2aW91c0NhY2hlRW50cnkgfSk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiYgaXNPbkRlbWFuZFJldmFsaWRhdGUgJiYgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQgJiYgIXByZXZpb3VzQ2FjaGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbi1kZW1hbmQgcmV2YWxpZGF0ZSBhbHdheXMgc2V0cyB0aGlzIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCAnUkVWQUxJREFURUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW52b2tlUm91dGVNb2R1bGUoY3VycmVudFNwYW4pO1xuICAgICAgICAgICAgICAgICAgICByZXEuZmV0Y2hNZXRyaWNzID0gY29udGV4dC5yZW5kZXJPcHRzLmZldGNoTWV0cmljcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlbmRpbmdXYWl0VW50aWwgPSBjb250ZXh0LnJlbmRlck9wdHMucGVuZGluZ1dhaXRVbnRpbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB1c2luZyBwcm92aWRlZCB3YWl0VW50aWwgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHdlIGZhbGxiYWNrIHRvIHNlbmRSZXNwb25zZSdzIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nV2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LndhaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC53YWl0VW50aWwocGVuZGluZ1dhaXRVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dhaXRVbnRpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZVRhZ3MgPSBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkVGFncztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgZm9yIGEgc3RhdGljIHJlc3BvbnNlLCB3ZSBjYW4gY2FjaGUgaXQgc28gbG9uZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIG5vdCBlZGdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJc3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBoZWFkZXJzIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tORVhUX0NBQ0hFX1RBR1NfSEVBREVSXSA9IGNhY2hlVGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyc1snY29udGVudC10eXBlJ10gJiYgYmxvYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBibG9iLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gdHlwZW9mIGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZSA+PSBJTkZJTklURV9DQUNIRSA/IGZhbHNlIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA+PSBJTkZJTklURV9DQUNIRSA/IHVuZGVmaW5lZCA6IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRFeHBpcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNhY2hlIGVudHJ5IGZvciB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBCdWZmZXIuZnJvbShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCByZXNwb25zZSB3aXRob3V0IGNhY2hpbmcgaWYgbm90IElTUlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VuZFJlc3BvbnNlKG5vZGVOZXh0UmVxLCBub2RlTmV4dFJlcywgcmVzcG9uc2UsIGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBiYWNrZ3JvdW5kIHJldmFsaWRhdGUgd2UgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgZXJyb3IgaGVyZSBhcyBpdCB3b24ndCBiZSBidWJibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NhY2hlRW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzQ2FjaGVFbnRyeS5pc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVyciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcktpbmQ6ICdBcHAgUm91dGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVBhdGg6IHNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJvdXRlclNlcnZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGF3YWl0IHJvdXRlTW9kdWxlLmhhbmRsZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlR2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjcmVhdGUgYSBjYWNoZUVudHJ5IGZvciBJU1JcbiAgICAgICAgICAgIGlmICghaXNJc3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlLmtpbmQpICE9PSBDYWNoZWRSb3V0ZUtpbmQuQVBQX1JPVVRFKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlMTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhcmlhbnQ6IGFwcC1yb3V0ZSByZWNlaXZlZCBpbnZhbGlkIGNhY2hlIGVudHJ5ICR7Y2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlMSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZTEua2luZH1gKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU3MDFcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCBpc09uRGVtYW5kUmV2YWxpZGF0ZSA/ICdSRVZBTElEQVRFRCcgOiBjYWNoZUVudHJ5LmlzTWlzcyA/ICdNSVNTJyA6IGNhY2hlRW50cnkuaXNTdGFsZSA/ICdTVEFMRScgOiAnSElUJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcmFmdCBtb2RlIHNob3VsZCBuZXZlciBiZSBjYWNoZWRcbiAgICAgICAgICAgIGlmIChpc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCAncHJpdmF0ZSwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtYXgtYWdlPTAsIG11c3QtcmV2YWxpZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhjYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKCEoZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc0lzcikpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmRlbGV0ZShORVhUX0NBQ0hFX1RBR1NfSEVBREVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGNhY2hlIGNvbnRyb2wgaXMgYWxyZWFkeSBzZXQgb24gdGhlIHJlc3BvbnNlIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBvdmVycmlkZSBpdCB0byBhbGxvdyB1c2VycyB0byBjdXN0b21pemUgaXQgdmlhIG5leHQuY29uZmlnXG4gICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wgJiYgIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSAmJiAhaGVhZGVycy5nZXQoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdDYWNoZS1Db250cm9sJywgZ2V0Q2FjaGVDb250cm9sSGVhZGVyKGNhY2hlRW50cnkuY2FjaGVDb250cm9sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UoY2FjaGVFbnRyeS52YWx1ZS5ib2R5LCB7XG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlRW50cnkudmFsdWUuc3RhdHVzIHx8IDIwMFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVSZXNwb25zZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVSZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIE5vRmFsbGJhY2tFcnJvcikpIHtcbiAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogbm9ybWFsaXplZFNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldGhyb3cgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHNlcnZpbmcgZXJyb3IgcGFnZVxuICAgICAgICAvLyBJZiB0aGlzIGlzIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbiwgdGhyb3cgdGhlIGVycm9yIGFnYWluLlxuICAgICAgICBpZiAoaXNJc3IpIHRocm93IGVycjtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZW5kIGEgNTAwIHJlc3BvbnNlLlxuICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./utils/localStigLibrary.ts":
/*!***********************************!*\
  !*** ./utils/localStigLibrary.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLocalStigContent: () => (/* binding */ getLocalStigContent),\n/* harmony export */   getLocalStigMetadata: () => (/* binding */ getLocalStigMetadata),\n/* harmony export */   getLocalStigStats: () => (/* binding */ getLocalStigStats),\n/* harmony export */   getStigDirectory: () => (/* binding */ getStigDirectory),\n/* harmony export */   hasLocalStig: () => (/* binding */ hasLocalStig),\n/* harmony export */   listLocalStigs: () => (/* binding */ listLocalStigs)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/**\r\n * Local STIG Library Management\r\n * Handles reading and serving STIG files from the local public/stigs directory\r\n */ \n\n/**\r\n * Get the path to the local STIG directory\r\n */ function getStigDirectory() {\n    return path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'stigs');\n}\n/**\r\n * Check if a STIG exists in the local library\r\n */ function hasLocalStig(stigId) {\n    const stigDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(getStigDirectory(), stigId);\n    return fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(stigDir);\n}\n/**\r\n * Get metadata for a local STIG\r\n */ function getLocalStigMetadata(stigId) {\n    try {\n        const metadataPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(getStigDirectory(), stigId, 'metadata.json');\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(metadataPath)) {\n            const metadata = JSON.parse(fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(metadataPath, 'utf-8'));\n            return metadata;\n        }\n        // Try to auto-detect if no metadata file\n        const stigDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(getStigDirectory(), stigId);\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(stigDir)) {\n            const files = fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(stigDir);\n            const xmlFile = files.find((f)=>f.endsWith('.xml') || f.endsWith('.xccdf'));\n            const csvFile = files.find((f)=>f.endsWith('.csv'));\n            if (xmlFile || csvFile) {\n                return {\n                    stigId,\n                    name: stigId.replace(/_/g, ' ').replace(/\\b\\w/g, (l)=>l.toUpperCase()),\n                    version: 'Unknown',\n                    releaseDate: new Date().toISOString().split('T')[0],\n                    filename: xmlFile || csvFile || '',\n                    format: xmlFile ? 'xml' : 'csv'\n                };\n            }\n        }\n        return null;\n    } catch (error) {\n        console.error(`Error reading metadata for ${stigId}:`, error);\n        return null;\n    }\n}\n/**\r\n * Read local STIG file content\r\n */ function getLocalStigContent(stigId) {\n    try {\n        const metadata = getLocalStigMetadata(stigId);\n        if (!metadata) return null;\n        const filePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(getStigDirectory(), stigId, metadata.filename);\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(filePath)) {\n            return fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(filePath, 'utf-8');\n        }\n        return null;\n    } catch (error) {\n        console.error(`Error reading STIG file for ${stigId}:`, error);\n        return null;\n    }\n}\n/**\r\n * List all available local STIGs\r\n */ function listLocalStigs() {\n    try {\n        const stigsDir = getStigDirectory();\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(stigsDir)) {\n            return [];\n        }\n        const directories = fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(stigsDir, {\n            withFileTypes: true\n        }).filter((dirent)=>dirent.isDirectory()).map((dirent)=>dirent.name);\n        const stigs = [];\n        for (const stigId of directories){\n            const metadata = getLocalStigMetadata(stigId);\n            if (metadata) {\n                stigs.push(metadata);\n            }\n        }\n        return stigs.sort((a, b)=>a.name.localeCompare(b.name));\n    } catch (error) {\n        console.error('Error listing local STIGs:', error);\n        return [];\n    }\n}\n/**\r\n * Get statistics about local STIG library\r\n */ function getLocalStigStats() {\n    const stigs = listLocalStigs();\n    return {\n        total: stigs.length,\n        byFormat: {\n            xml: stigs.filter((s)=>s.format === 'xml').length,\n            csv: stigs.filter((s)=>s.format === 'csv').length\n        },\n        stigs: stigs.map((s)=>({\n                id: s.stigId,\n                name: s.name,\n                version: s.version\n            }))\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDbkM7WUFDYjtRQUNGO1FBRUEsT0FBT2tDLE1BQU1FLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFMUIsSUFBSSxDQUFDNEIsYUFBYSxDQUFDRCxFQUFFM0IsSUFBSTtJQUN6RCxFQUFFLE9BQU9XLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBTyxFQUFFO0lBQ1g7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU2tCO0lBQ2QsTUFBTU4sUUFBUVI7SUFFZCxPQUFPO1FBQ0xlLE9BQU9QLE1BQU1RLE1BQU07UUFDbkJDLFVBQVU7WUFDUkMsS0FBS1YsTUFBTUosTUFBTSxDQUFDZSxDQUFBQSxJQUFLQSxFQUFFeEIsTUFBTSxLQUFLLE9BQU9xQixNQUFNO1lBQ2pESSxLQUFLWixNQUFNSixNQUFNLENBQUNlLENBQUFBLElBQUtBLEVBQUV4QixNQUFNLEtBQUssT0FBT3FCLE1BQU07UUFDbkQ7UUFDQVIsT0FBT0EsTUFBTUQsR0FBRyxDQUFDWSxDQUFBQSxJQUFNO2dCQUNyQkUsSUFBSUYsRUFBRWxELE1BQU07Z0JBQ1pnQixNQUFNa0MsRUFBRWxDLElBQUk7Z0JBQ1pJLFNBQVM4QixFQUFFOUIsT0FBTztZQUNwQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xccm9ubmlcXE9uZURyaXZlXFxEZXNrdG9wXFxQcm9qZWN0c1xcU1JUTS10b29sXFx1dGlsc1xcbG9jYWxTdGlnTGlicmFyeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTG9jYWwgU1RJRyBMaWJyYXJ5IE1hbmFnZW1lbnRcclxuICogSGFuZGxlcyByZWFkaW5nIGFuZCBzZXJ2aW5nIFNUSUcgZmlsZXMgZnJvbSB0aGUgbG9jYWwgcHVibGljL3N0aWdzIGRpcmVjdG9yeVxyXG4gKi9cclxuXHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMb2NhbFN0aWdNZXRhZGF0YSB7XHJcbiAgc3RpZ0lkOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIHZlcnNpb246IHN0cmluZztcclxuICByZWxlYXNlRGF0ZTogc3RyaW5nO1xyXG4gIGZpbGVuYW1lOiBzdHJpbmc7XHJcbiAgZm9ybWF0PzogJ3htbCcgfCAnY3N2JztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcGF0aCB0byB0aGUgbG9jYWwgU1RJRyBkaXJlY3RvcnlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGlnRGlyZWN0b3J5KCk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ3N0aWdzJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIFNUSUcgZXhpc3RzIGluIHRoZSBsb2NhbCBsaWJyYXJ5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzTG9jYWxTdGlnKHN0aWdJZDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgY29uc3Qgc3RpZ0RpciA9IHBhdGguam9pbihnZXRTdGlnRGlyZWN0b3J5KCksIHN0aWdJZCk7XHJcbiAgcmV0dXJuIGZzLmV4aXN0c1N5bmMoc3RpZ0Rpcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgbWV0YWRhdGEgZm9yIGEgbG9jYWwgU1RJR1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsU3RpZ01ldGFkYXRhKHN0aWdJZDogc3RyaW5nKTogTG9jYWxTdGlnTWV0YWRhdGEgfCBudWxsIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgbWV0YWRhdGFQYXRoID0gcGF0aC5qb2luKGdldFN0aWdEaXJlY3RvcnkoKSwgc3RpZ0lkLCAnbWV0YWRhdGEuanNvbicpO1xyXG4gICAgXHJcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhtZXRhZGF0YVBhdGgpKSB7XHJcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMobWV0YWRhdGFQYXRoLCAndXRmLTgnKSk7XHJcbiAgICAgIHJldHVybiBtZXRhZGF0YTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVHJ5IHRvIGF1dG8tZGV0ZWN0IGlmIG5vIG1ldGFkYXRhIGZpbGVcclxuICAgIGNvbnN0IHN0aWdEaXIgPSBwYXRoLmpvaW4oZ2V0U3RpZ0RpcmVjdG9yeSgpLCBzdGlnSWQpO1xyXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoc3RpZ0RpcikpIHtcclxuICAgICAgY29uc3QgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhzdGlnRGlyKTtcclxuICAgICAgY29uc3QgeG1sRmlsZSA9IGZpbGVzLmZpbmQoZiA9PiBmLmVuZHNXaXRoKCcueG1sJykgfHwgZi5lbmRzV2l0aCgnLnhjY2RmJykpO1xyXG4gICAgICBjb25zdCBjc3ZGaWxlID0gZmlsZXMuZmluZChmID0+IGYuZW5kc1dpdGgoJy5jc3YnKSk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoeG1sRmlsZSB8fCBjc3ZGaWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN0aWdJZCxcclxuICAgICAgICAgIG5hbWU6IHN0aWdJZC5yZXBsYWNlKC9fL2csICcgJykucmVwbGFjZSgvXFxiXFx3L2csIGwgPT4gbC50b1VwcGVyQ2FzZSgpKSxcclxuICAgICAgICAgIHZlcnNpb246ICdVbmtub3duJyxcclxuICAgICAgICAgIHJlbGVhc2VEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcclxuICAgICAgICAgIGZpbGVuYW1lOiB4bWxGaWxlIHx8IGNzdkZpbGUgfHwgJycsXHJcbiAgICAgICAgICBmb3JtYXQ6IHhtbEZpbGUgPyAneG1sJyA6ICdjc3YnXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBtZXRhZGF0YSBmb3IgJHtzdGlnSWR9OmAsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlYWQgbG9jYWwgU1RJRyBmaWxlIGNvbnRlbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhbFN0aWdDb250ZW50KHN0aWdJZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0TG9jYWxTdGlnTWV0YWRhdGEoc3RpZ0lkKTtcclxuICAgIGlmICghbWV0YWRhdGEpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihnZXRTdGlnRGlyZWN0b3J5KCksIHN0aWdJZCwgbWV0YWRhdGEuZmlsZW5hbWUpO1xyXG4gICAgXHJcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkpIHtcclxuICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0Zi04Jyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWFkaW5nIFNUSUcgZmlsZSBmb3IgJHtzdGlnSWR9OmAsIGVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3QgYWxsIGF2YWlsYWJsZSBsb2NhbCBTVElHc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RMb2NhbFN0aWdzKCk6IExvY2FsU3RpZ01ldGFkYXRhW10ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzdGlnc0RpciA9IGdldFN0aWdEaXJlY3RvcnkoKTtcclxuICAgIFxyXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHN0aWdzRGlyKSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGRpcmVjdG9yaWVzID0gZnMucmVhZGRpclN5bmMoc3RpZ3NEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxyXG4gICAgICAuZmlsdGVyKGRpcmVudCA9PiBkaXJlbnQuaXNEaXJlY3RvcnkoKSlcclxuICAgICAgLm1hcChkaXJlbnQgPT4gZGlyZW50Lm5hbWUpO1xyXG4gICAgXHJcbiAgICBjb25zdCBzdGlnczogTG9jYWxTdGlnTWV0YWRhdGFbXSA9IFtdO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IHN0aWdJZCBvZiBkaXJlY3Rvcmllcykge1xyXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGdldExvY2FsU3RpZ01ldGFkYXRhKHN0aWdJZCk7XHJcbiAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgIHN0aWdzLnB1c2gobWV0YWRhdGEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBzdGlncy5zb3J0KChhLCBiKSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbGlzdGluZyBsb2NhbCBTVElHczonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHN0YXRpc3RpY3MgYWJvdXQgbG9jYWwgU1RJRyBsaWJyYXJ5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYWxTdGlnU3RhdHMoKSB7XHJcbiAgY29uc3Qgc3RpZ3MgPSBsaXN0TG9jYWxTdGlncygpO1xyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICB0b3RhbDogc3RpZ3MubGVuZ3RoLFxyXG4gICAgYnlGb3JtYXQ6IHtcclxuICAgICAgeG1sOiBzdGlncy5maWx0ZXIocyA9PiBzLmZvcm1hdCA9PT0gJ3htbCcpLmxlbmd0aCxcclxuICAgICAgY3N2OiBzdGlncy5maWx0ZXIocyA9PiBzLmZvcm1hdCA9PT0gJ2NzdicpLmxlbmd0aFxyXG4gICAgfSxcclxuICAgIHN0aWdzOiBzdGlncy5tYXAocyA9PiAoe1xyXG4gICAgICBpZDogcy5zdGlnSWQsXHJcbiAgICAgIG5hbWU6IHMubmFtZSxcclxuICAgICAgdmVyc2lvbjogcy52ZXJzaW9uXHJcbiAgICB9KSlcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJmcyIsInBhdGgiLCJnZXRTdGlnRGlyZWN0b3J5Iiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJoYXNMb2NhbFN0aWciLCJzdGlnSWQiLCJzdGlnRGlyIiwiZXhpc3RzU3luYyIsImdldExvY2FsU3RpZ01ldGFkYXRhIiwibWV0YWRhdGFQYXRoIiwibWV0YWRhdGEiLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZVN5bmMiLCJmaWxlcyIsInJlYWRkaXJTeW5jIiwieG1sRmlsZSIsImZpbmQiLCJmIiwiZW5kc1dpdGgiLCJjc3ZGaWxlIiwibmFtZSIsInJlcGxhY2UiLCJsIiwidG9VcHBlckNhc2UiLCJ2ZXJzaW9uIiwicmVsZWFzZURhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImZpbGVuYW1lIiwiZm9ybWF0IiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0TG9jYWxTdGlnQ29udGVudCIsImZpbGVQYXRoIiwibGlzdExvY2FsU3RpZ3MiLCJzdGlnc0RpciIsImRpcmVjdG9yaWVzIiwid2l0aEZpbGVUeXBlcyIsImZpbHRlciIsImRpcmVudCIsImlzRGlyZWN0b3J5IiwibWFwIiwic3RpZ3MiLCJwdXNoIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImdldExvY2FsU3RpZ1N0YXRzIiwidG90YWwiLCJsZW5ndGgiLCJieUZvcm1hdCIsInhtbCIsInMiLCJjc3YiLCJpZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./utils/localStigLibrary.ts\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();