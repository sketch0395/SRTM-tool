/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/import-stig/route";
exports.ids = ["app/api/import-stig/route"];
exports.modules = {

/***/ "(rsc)/./app/api/import-stig/route.ts":
/*!**************************************!*\
  !*** ./app/api/import-stig/route.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/**\r\n * GET - Fetch STIG from stigviewer.com\r\n * Query params: stigId (e.g., 'apache_server_2.4_unix')\r\n */ async function GET(request) {\n    try {\n        const { searchParams } = new URL(request.url);\n        const stigId = searchParams.get('stigId');\n        if (!stigId) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'stigId parameter is required'\n            }, {\n                status: 400\n            });\n        }\n        console.log(`üîç Fetching STIG from stigviewer.com: ${stigId}`);\n        // Try JSON API first (has complete severity data)\n        const jsonUrl = `https://stigviewer.com/stigs/${stigId}/json`;\n        const htmlUrl = `https://stigviewer.com/stigs/${stigId}/`;\n        // Create custom agent to bypass SSL certificate validation\n        const agent = new (https__WEBPACK_IMPORTED_MODULE_1___default().Agent)({\n            rejectUnauthorized: false\n        });\n        try {\n            // Attempt JSON API first\n            console.log(`üì• Attempting JSON API...`);\n            const jsonResponse = await fetch(jsonUrl, {\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n                    'Accept': 'application/json, text/html, */*',\n                    'Accept-Language': 'en-US,en;q=0.9',\n                    'Accept-Encoding': 'gzip, deflate, br',\n                    'Referer': 'https://stigviewer.com/',\n                    'Connection': 'keep-alive',\n                    'Cache-Control': 'no-cache',\n                    'Pragma': 'no-cache'\n                },\n                // @ts-ignore\n                agent,\n                signal: AbortSignal.timeout(15000)\n            });\n            if (jsonResponse.ok) {\n                const jsonData = await jsonResponse.json();\n                console.log(`‚úÖ JSON API successful`);\n                const stigData = parseStigViewerJson(jsonData, stigId);\n                if (stigData.requirements.length > 0) {\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        success: true,\n                        ...stigData,\n                        source: 'stigviewer',\n                        message: `Successfully imported ${stigData.requirements.length} requirements from JSON API`\n                    });\n                }\n            } else {\n                console.log(`‚ö†Ô∏è JSON API returned ${jsonResponse.status}: ${jsonResponse.statusText}`);\n            }\n        } catch (jsonError) {\n            console.log(`‚ö†Ô∏è JSON API failed: ${jsonError.message}, trying HTML...`);\n        }\n        // Fallback to HTML parsing\n        try {\n            console.log(`üì• Attempting HTML parsing...`);\n            // Add a small delay to avoid rate limiting\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n            const response = await fetch(htmlUrl, {\n                headers: {\n                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',\n                    'Accept-Language': 'en-US,en;q=0.9',\n                    'Accept-Encoding': 'gzip, deflate, br',\n                    'Referer': 'https://stigviewer.com/',\n                    'Connection': 'keep-alive',\n                    'Cache-Control': 'no-cache',\n                    'Pragma': 'no-cache',\n                    'Sec-Fetch-Dest': 'document',\n                    'Sec-Fetch-Mode': 'navigate',\n                    'Sec-Fetch-Site': 'same-origin',\n                    'Upgrade-Insecure-Requests': '1'\n                },\n                // @ts-ignore\n                agent,\n                signal: AbortSignal.timeout(15000)\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            const html = await response.text();\n            // Parse STIG information from HTML\n            const stigData = await parseStigViewerHtml(html, stigId);\n            if (stigData.requirements.length === 0) {\n                throw new Error('No requirements found in STIG data');\n            }\n            console.log(`‚úÖ Successfully fetched ${stigData.requirements.length} requirements from stigviewer.com`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: true,\n                ...stigData,\n                source: 'stigviewer',\n                message: `Successfully imported ${stigData.requirements.length} requirements from stigviewer.com`\n            });\n        } catch (fetchError) {\n            console.error('‚ùå Error fetching from stigviewer.com:', fetchError.message);\n            // Provide specific guidance based on error type\n            let errorGuidance = 'Failed to fetch from stigviewer.com. Please try again or upload STIG manually.';\n            if (fetchError.message.includes('403') || fetchError.message.includes('Forbidden')) {\n                errorGuidance = 'stigviewer.com is blocking automated requests (403 Forbidden). This may be due to rate limiting or access restrictions. Please wait a few minutes and try again, or download and upload the STIG manually.';\n            } else if (fetchError.message.includes('timeout')) {\n                errorGuidance = 'Request timed out. The server may be slow or unavailable. Please try again.';\n            }\n            // Return error with instructions for manual upload\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                stigId,\n                error: fetchError.message,\n                message: errorGuidance,\n                instructions: {\n                    step1: 'Download STIG XML from DISA Cyber Exchange: https://public.cyber.mil/stigs/downloads/',\n                    step2: 'Or download from STIGViewer: https://stigviewer.com/stigs',\n                    step3: 'Upload the XCCDF XML file using the manual upload option'\n                }\n            }, {\n                status: 503\n            });\n        }\n    } catch (error) {\n        console.error('‚ùå Error in STIG import:', error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error.message,\n            message: 'An error occurred while importing STIG'\n        }, {\n            status: 500\n        });\n    }\n}\n/**\r\n * Parse DISA STIG CSV file\r\n * CSV format from DISA Cyber Exchange\r\n */ function parseStigCsv(csvContent, fileName) {\n    const requirements = [];\n    // Properly split CSV content into lines, handling multi-line quoted fields\n    const lines = [];\n    let currentLine = '';\n    let insideQuotes = false;\n    for(let i = 0; i < csvContent.length; i++){\n        const char = csvContent[i];\n        const nextChar = csvContent[i + 1];\n        if (char === '\"') {\n            // Check if it's an escaped quote\n            if (nextChar === '\"') {\n                currentLine += char + nextChar;\n                i++; // Skip next quote\n            } else {\n                insideQuotes = !insideQuotes;\n                currentLine += char;\n            }\n        } else if (char === '\\n' && !insideQuotes) {\n            if (currentLine.trim()) {\n                lines.push(currentLine);\n            }\n            currentLine = '';\n        } else if (char === '\\r') {\n            continue;\n        } else {\n            currentLine += char;\n        }\n    }\n    // Add the last line if not empty\n    if (currentLine.trim()) {\n        lines.push(currentLine);\n    }\n    console.log(`üìÑ Split CSV into ${lines.length} lines`);\n    if (lines.length < 2) {\n        return {\n            stigId: fileName.replace(/\\.csv$/i, ''),\n            stigName: 'Imported STIG',\n            version: 'Unknown',\n            releaseDate: new Date().toISOString().split('T')[0],\n            requirements: [],\n            totalRequirements: 0\n        };\n    }\n    // Parse header row - handle quoted CSV fields\n    const parseCSVLine = (line)=>{\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        for(let i = 0; i < line.length; i++){\n            const char = line[i];\n            const nextChar = line[i + 1];\n            if (char === '\"') {\n                if (inQuotes && nextChar === '\"') {\n                    // Escaped quote\n                    current += '\"';\n                    i++;\n                } else {\n                    inQuotes = !inQuotes;\n                }\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        return result;\n    };\n    // Find the header row (skip classification banners like \"~~~~~~~ Unclassified ~~~~~~\")\n    let headerLineIndex = 0;\n    let headers = [];\n    for(let i = 0; i < Math.min(5, lines.length); i++){\n        const parsedLine = parseCSVLine(lines[i]);\n        const lineText = parsedLine.join('').toLowerCase();\n        // Skip classification banners and empty lines\n        if (lineText.includes('unclassified') || lineText.includes('~~~~~') || parsedLine.length < 5) {\n            continue;\n        }\n        // Check if this looks like a header row (has common STIG column names)\n        if (lineText.includes('stig') || lineText.includes('severity') || lineText.includes('rule')) {\n            headerLineIndex = i;\n            headers = parsedLine.map((h)=>h.toLowerCase().trim());\n            console.log(`üìã Found header row at line ${i + 1}`);\n            break;\n        }\n    }\n    if (headers.length === 0) {\n        console.error('‚ùå Could not find valid header row in CSV');\n        return {\n            stigId: fileName.replace(/\\.csv$/i, ''),\n            stigName: 'Imported STIG',\n            version: 'Unknown',\n            releaseDate: new Date().toISOString().split('T')[0],\n            requirements: [],\n            totalRequirements: 0\n        };\n    }\n    console.log(`üìã CSV Headers found: ${headers.slice(0, 10).join(', ')}...`);\n    console.log(`üìã All headers (first 15):`, headers.slice(0, 15));\n    // Find column indices\n    const getIndex = (names)=>{\n        for (const name of names){\n            const idx = headers.findIndex((h)=>h.includes(name));\n            if (idx !== -1) {\n                console.log(`‚úÖ Found \"${name}\" at index ${idx}: \"${headers[idx]}\"`);\n                return idx;\n            }\n        }\n        console.log(`‚ùå Could not find any of: ${names.join(', ')}`);\n        return -1;\n    };\n    const stigIdIdx = getIndex([\n        'stig id',\n        'stigid'\n    ]);\n    const severityIdx = getIndex([\n        'severity'\n    ]);\n    const titleIdx = getIndex([\n        'rule title',\n        'ruletitle'\n    ]);\n    const discussionIdx = getIndex([\n        'discussion'\n    ]);\n    const checkIdx = getIndex([\n        'check content',\n        'checkcontent'\n    ]);\n    const fixIdx = getIndex([\n        'fix text',\n        'fixtext'\n    ]);\n    const cciIdx = getIndex([\n        'ccis',\n        'cci'\n    ]);\n    const ruleIdIdx = getIndex([\n        'rule id',\n        'ruleid'\n    ]);\n    console.log(`üìä Column indices:`, {\n        stigId: stigIdIdx,\n        severity: severityIdx,\n        title: titleIdx,\n        discussion: discussionIdx,\n        check: checkIdx,\n        fix: fixIdx,\n        cci: cciIdx,\n        ruleId: ruleIdIdx\n    });\n    let stigName = 'Imported STIG';\n    let version = 'Unknown';\n    console.log(`üìÑ Processing ${lines.length - headerLineIndex - 1} data rows from CSV`);\n    // Parse data rows (start after header row)\n    for(let i = headerLineIndex + 1; i < lines.length; i++){\n        const line = lines[i].trim();\n        if (!line) continue;\n        const values = parseCSVLine(line);\n        if (i === headerLineIndex + 1) {\n            console.log(`üìù First data row has ${values.length} values`);\n        }\n        // Extract STIG name from first data row if available\n        if (i === headerLineIndex + 1 && values.length > 0) {\n            const benchmarkIdx = headers.findIndex((h)=>h.includes('benchmark'));\n            if (benchmarkIdx !== -1 && values[benchmarkIdx]) {\n                stigName = values[benchmarkIdx];\n            }\n            const versionIdx = headers.findIndex((h)=>h.includes('version') || h.includes('release'));\n            if (versionIdx !== -1 && values[versionIdx]) {\n                version = values[versionIdx];\n            }\n        }\n        const vulnId = stigIdIdx !== -1 ? values[stigIdIdx] : '';\n        const ruleId = ruleIdIdx !== -1 ? values[ruleIdIdx] : vulnId;\n        if (!vulnId) {\n            if (i <= headerLineIndex + 3) {\n                console.log(`‚ö†Ô∏è Line ${i}: No STIG ID found`);\n            }\n            continue;\n        }\n        if (i === headerLineIndex + 1) {\n            console.log(`‚úÖ First requirement found: ${vulnId}`);\n        }\n        // Parse severity - handle multiple formats\n        const severityValue = severityIdx !== -1 ? values[severityIdx].toLowerCase().trim() : 'medium';\n        let severity = 'medium';\n        // Direct severity values\n        if (severityValue === 'high' || severityValue.includes('cat i') || severityValue.includes('cat 1') || severityValue.includes('cati')) {\n            severity = 'high';\n        } else if (severityValue === 'low' || severityValue.includes('cat iii') || severityValue.includes('cat 3') || severityValue.includes('catiii')) {\n            severity = 'low';\n        } else if (severityValue === 'medium' || severityValue.includes('cat ii') || severityValue.includes('cat 2') || severityValue.includes('catii')) {\n            severity = 'medium';\n        }\n        // Log first few for debugging\n        if (i <= headerLineIndex + 3) {\n            console.log(`üìä Row ${i - headerLineIndex}: vulnId=\"${vulnId}\", severity=\"${severityValue}\" ‚Üí ${severity}`);\n        }\n        // Extract CCI references\n        const cciText = cciIdx !== -1 ? values[cciIdx] : '';\n        const cciMatches = cciText.match(/CCI-\\d+/g);\n        const cci = cciMatches || [\n            'CCI-000366'\n        ];\n        requirements.push({\n            vulnId,\n            ruleId,\n            severity,\n            title: titleIdx !== -1 ? values[titleIdx] : `Requirement ${vulnId}`,\n            description: discussionIdx !== -1 ? values[discussionIdx] : 'No description provided',\n            checkText: checkIdx !== -1 ? values[checkIdx] : 'Review system configuration per STIG guidance.',\n            fixText: fixIdx !== -1 ? values[fixIdx] : 'Configure system per STIG guidance.',\n            cci,\n            nistControls: []\n        });\n    }\n    console.log(`‚úÖ CSV parsing complete: ${requirements.length} requirements found`);\n    return {\n        stigId: fileName.replace(/\\.csv$/i, ''),\n        stigName,\n        version,\n        releaseDate: new Date().toISOString().split('T')[0],\n        requirements,\n        totalRequirements: requirements.length\n    };\n}\n/**\r\n * POST - Manual STIG upload (XML or CSV file)\r\n * Body: FormData with 'file' field containing XCCDF XML or DISA CSV\r\n */ async function POST(request) {\n    try {\n        const formData = await request.formData();\n        const file = formData.get('file');\n        if (!file) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'No file provided'\n            }, {\n                status: 400\n            });\n        }\n        // Validate file type\n        const fileName = file.name.toLowerCase();\n        const isXml = fileName.endsWith('.xml') || fileName.endsWith('.xccdf');\n        const isCsv = fileName.endsWith('.csv');\n        if (!isXml && !isCsv) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Invalid file type. Please upload an XCCDF XML file or DISA CSV file.'\n            }, {\n                status: 400\n            });\n        }\n        console.log(`üìÅ Processing manual STIG upload: ${file.name}`);\n        // Read file content\n        const fileContent = await file.text();\n        let stigData;\n        if (isCsv) {\n            // Parse CSV file\n            stigData = parseStigCsv(fileContent, fileName);\n        } else {\n            // Parse XCCDF XML\n            stigData = parseXccdfXml(fileContent, fileName);\n        }\n        if (stigData.requirements.length === 0) {\n            throw new Error(`No requirements found in ${isCsv ? 'CSV' : 'XML'} file. Please ensure this is a valid DISA STIG file.`);\n        }\n        console.log(`‚úÖ Successfully parsed ${stigData.requirements.length} requirements from manual upload`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            ...stigData,\n            source: 'manual',\n            message: `Successfully imported ${stigData.requirements.length} requirements from ${file.name}`\n        });\n    } catch (error) {\n        console.error('‚ùå Error processing manual upload:', error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: error.message,\n            message: 'Failed to parse STIG file. Please ensure this is a valid XCCDF XML file.'\n        }, {\n            status: 500\n        });\n    }\n}\n/**\r\n * Fetch detailed requirement page from stigviewer.com\r\n * Returns check and fix text for a specific vulnerability\r\n */ async function fetchRequirementDetails(stigId, vulnId) {\n    try {\n        const agent = new (https__WEBPACK_IMPORTED_MODULE_1___default().Agent)({\n            rejectUnauthorized: false\n        });\n        const url = `https://stigviewer.com/stig/${stigId}/requirement/${vulnId}`;\n        const response = await fetch(url, {\n            headers: {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n            },\n            // @ts-ignore\n            agent,\n            signal: AbortSignal.timeout(10000)\n        });\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}`);\n        }\n        const html = await response.text();\n        // Extract check text\n        const checkMatch = html.match(/<div[^>]*(?:id|class)=\"[^\"]*check[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i) || html.match(/Check Text[:\\s]*<[^>]*>([\\s\\S]*?)<\\/(?:div|pre|p)>/i) || html.match(/<pre[^>]*>([\\s\\S]*?)<\\/pre>/i);\n        const checkText = checkMatch ? checkMatch[1].replace(/<[^>]+>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '\"').replace(/\\s+/g, ' ').trim() : 'Review the system configuration to verify compliance with the security requirement.';\n        // Extract fix text  \n        const fixMatch = html.match(/<div[^>]*(?:id|class)=\"[^\"]*fix[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/i) || html.match(/Fix Text[:\\s]*<[^>]*>([\\s\\S]*?)<\\/(?:div|pre|p)>/i);\n        const fixText = fixMatch ? fixMatch[1].replace(/<[^>]+>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '\"').replace(/\\s+/g, ' ').trim() : 'Configure the system to meet the security requirement as specified in the STIG documentation.';\n        return {\n            checkText,\n            fixText\n        };\n    } catch (error) {\n        // Return defaults if fetch fails\n        return {\n            checkText: 'Review the system configuration to verify compliance with the security requirement. Detailed check procedure available in the full STIG documentation.',\n            fixText: 'Configure the system to meet the security requirement. Detailed fix procedure available in the full STIG documentation.'\n        };\n    }\n}\n/**\r\n * Parse stig viewer.com JSON API response\r\n * JSON format has complete data including severity for each requirement\r\n */ function parseStigViewerJson(jsonData, stigId) {\n    const requirements = [];\n    try {\n        const stig = jsonData.stig || jsonData;\n        const stigName = stig.title || stigId;\n        const version = stig.version || 'Unknown';\n        const releaseDate = stig.date || new Date().toISOString().split('T')[0];\n        console.log(`üìã Parsing JSON: ${stigName}, Version: ${version}, Release: ${releaseDate}`);\n        const findings = stig.findings || {};\n        const vulnIds = Object.keys(findings);\n        console.log(`üîç Found ${vulnIds.length} requirements in JSON`);\n        vulnIds.forEach((vulnId)=>{\n            const finding = findings[vulnId];\n            if (!finding) return;\n            // Extract severity from finding\n            // JSON might have severity as \"high\", \"medium\", \"low\" or \"CAT I\", \"CAT II\", \"CAT III\"\n            let severity = 'medium';\n            const sevText = (finding.severity || finding.cat || 'medium').toString().toLowerCase();\n            if (sevText.includes('high') || sevText.includes('cat i') || sevText === 'i' || sevText === '1') {\n                severity = 'high';\n            } else if (sevText.includes('low') || sevText.includes('cat iii') || sevText === 'iii' || sevText === '3') {\n                severity = 'low';\n            } else {\n                severity = 'medium';\n            }\n            requirements.push({\n                vulnId,\n                ruleId: finding.ruleId || finding.rule_id || finding.ruleid || `${vulnId}-rule`,\n                severity,\n                title: finding.title || finding.ruleTitle || finding.ruletitle || `Requirement ${vulnId}`,\n                description: finding.discussion || finding.description || finding.title || '',\n                checkText: finding.checktext || finding.checkText || finding.check_text || finding.check || 'Review system configuration per STIG guidance.',\n                fixText: finding.fixtext || finding.fixText || finding.fix_text || finding.fix || 'Configure system per STIG guidance.',\n                cci: finding.cci || finding.ccis || [\n                    'CCI-000366'\n                ],\n                nistControls: finding.nistControls || finding.nist || []\n            });\n        });\n        console.log(`‚úÖ Successfully parsed ${requirements.length} requirements from JSON`);\n        // Log severity distribution\n        const severityDist = {};\n        requirements.forEach((req)=>{\n            severityDist[req.severity] = (severityDist[req.severity] || 0) + 1;\n        });\n        console.log(`üìä JSON Severity Distribution:`, severityDist);\n        return {\n            stigId,\n            stigName,\n            version,\n            releaseDate,\n            requirements,\n            totalRequirements: requirements.length\n        };\n    } catch (error) {\n        console.error('Error parsing stigviewer.com JSON:', error);\n        throw new Error(`Failed to parse stigviewer.com JSON: ${error.message}`);\n    }\n}\n/**\r\n * Parse stigviewer.com HTML to extract STIG requirements\r\n * Fetches full requirement details including check and fix text\r\n */ async function parseStigViewerHtml(html, stigId) {\n    const requirements = [];\n    try {\n        // Extract STIG metadata from page title and headers\n        const titleMatch = html.match(/<title>([^<]+)<\\/title>/i);\n        const stigName = titleMatch ? titleMatch[1].replace(' | STIGViewer', '').trim() : stigId;\n        // Extract version from page\n        const versionMatch = html.match(/Version[:\\s]+([VvRr\\d.]+)/i) || html.match(/class=\"[^\"]*version[^\"]*\"[^>]*>([^<]+)</i);\n        const version = versionMatch ? versionMatch[1].trim() : 'Unknown';\n        // Extract release date\n        const dateMatch = html.match(/Release[:\\s]+(\\d{1,2}\\s+\\w+\\s+\\d{4})/i) || html.match(/Date[:\\s]+(\\d{4}-\\d{2}-\\d{2})/i) || html.match(/(\\d{4}-\\d{2}-\\d{2})/);\n        const releaseDate = dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0];\n        console.log(`üìã Parsing STIG: ${stigName}, Version: ${version}, Release: ${releaseDate}`);\n        // Method 1: Extract complete requirement entries with all details\n        // stigviewer.com has links like: href=\"/stig/{stigId}/requirement/V-#####\"\n        // Pattern to match entire requirement sections with severity info\n        const reqSectionPattern = /(?:CAT\\s+(I{1,3})|severity[^>]*?(high|medium|low))[^V]*(V-\\d+)[^<]*<a[^>]*href=\"[^\"]*\\/requirement\\/\\3\"[^>]*>([^<]+)</gi;\n        let match;\n        const detailedReqs = [];\n        while((match = reqSectionPattern.exec(html)) !== null){\n            const severity = match[1] || match[2]; // CAT I/II/III or high/medium/low\n            const vulnId = match[3];\n            const title = match[4].trim();\n            detailedReqs.push({\n                vulnId,\n                severity,\n                title\n            });\n        }\n        console.log(`üîç Method 1: Found ${detailedReqs.length} requirements with severity info`);\n        // Method 2: Extract from table rows if available\n        const tableRows = [];\n        const rowPattern = /<tr[^>]*>([\\s\\S]*?)<\\/tr>/gi;\n        let rowMatch;\n        while((rowMatch = rowPattern.exec(html)) !== null){\n            const rowHtml = rowMatch[1];\n            // Check if this row has a vuln ID\n            const vulnMatch = rowHtml.match(/>(V-\\d+)</);\n            if (!vulnMatch) continue;\n            const vulnId = vulnMatch[1];\n            // Extract severity from this row\n            const catMatch = rowHtml.match(/CAT\\s+(I{1,3})/i);\n            const sevMatch = rowHtml.match(/>(high|medium|low)</i);\n            const severity = catMatch ? catMatch[1] : sevMatch ? sevMatch[1] : 'II';\n            // Extract title\n            const titleMatch = rowHtml.match(/<a[^>]*href=\"[^\"]*\\/requirement\\/[^\"]*\"[^>]*>([^<]+)</i);\n            const title = titleMatch ? titleMatch[1].trim() : `Requirement ${vulnId}`;\n            tableRows.push({\n                vulnId,\n                severity,\n                title\n            });\n        }\n        console.log(`üîç Method 2: Found ${tableRows.length} requirements from table rows`);\n        // Method 3: Fallback - extract all V-#### with default data\n        const vulnIdPattern = /V-\\d+/g;\n        const allVulnIds = [\n            ...new Set(html.match(vulnIdPattern) || [])\n        ];\n        console.log(`üîç Method 3: Found ${allVulnIds.length} total V-#### patterns`);\n        // Use the method that found the most requirements\n        let reqData = [];\n        if (detailedReqs.length >= tableRows.length && detailedReqs.length > 0) {\n            reqData = detailedReqs;\n            console.log(`‚úì Using Method 1: ${detailedReqs.length} requirements with severity`);\n        } else if (tableRows.length > 0) {\n            reqData = tableRows;\n            console.log(`‚úì Using Method 2: ${tableRows.length} requirements from tables`);\n        } else {\n            // Fallback: create basic entries\n            reqData = allVulnIds.map((vulnId)=>({\n                    vulnId,\n                    severity: 'II',\n                    title: `${stigName} - ${vulnId}`\n                }));\n            console.log(`‚úì Using Method 3: ${allVulnIds.length} basic requirements`);\n        }\n        console.log(`üìù Processing ${reqData.length} requirements...`);\n        let requirementCount = 0;\n        for (const req of reqData){\n            const { vulnId, severity: rawSeverity, title } = req;\n            // Extract Rule ID if available\n            const rulePattern = new RegExp(`${vulnId}[^S]*?(SV-\\\\d+r\\\\d+_rule)`, 'i');\n            const ruleMatch = html.match(rulePattern);\n            const ruleId = ruleMatch ? ruleMatch[1] : `${vulnId}-rule`;\n            // Normalize severity\n            let severity = 'medium';\n            const sevText = rawSeverity.toLowerCase();\n            if (sevText.includes('i') && !sevText.includes('ii') || sevText === 'high' || sevText === '1') {\n                severity = 'high';\n            } else if (sevText.includes('iii') || sevText === 'low' || sevText === '3') {\n                severity = 'low';\n            } else {\n                severity = 'medium';\n            }\n            // Description defaults to title\n            const description = title;\n            // Extract CCI references - search for this vulnId in HTML\n            const vulnContext = html.substring(Math.max(0, html.indexOf(vulnId) - 300), Math.min(html.length, html.indexOf(vulnId) + 300));\n            const cciMatches = vulnContext.match(/CCI-\\d+/g);\n            const cci = cciMatches && cciMatches.length > 0 ? [\n                ...new Set(cciMatches)\n            ] : [\n                'CCI-000366'\n            ];\n            // Default check and fix text with note about full documentation\n            const checkText = `Review the system configuration to verify compliance with ${vulnId}. Refer to the full STIG documentation for detailed check procedures.`;\n            const fixText = `Configure the system to meet the requirements specified in ${vulnId}. Refer to the full STIG documentation for detailed fix procedures.`;\n            // Extract NIST controls from context\n            const nistMatches = vulnContext.match(/([A-Z]{2}-\\d+(?:\\s*\\([a-z0-9]+\\))?)/g);\n            const nistControls = nistMatches ? [\n                ...new Set(nistMatches)\n            ] : [];\n            requirements.push({\n                vulnId,\n                ruleId,\n                severity,\n                title,\n                description,\n                checkText,\n                fixText,\n                cci,\n                nistControls\n            });\n            requirementCount++;\n        }\n        console.log(`‚úÖ Successfully parsed ${requirementCount} requirements from HTML`);\n        // Log severity distribution\n        const severityDist = {};\n        requirements.forEach((req)=>{\n            severityDist[req.severity] = (severityDist[req.severity] || 0) + 1;\n        });\n        console.log(`üìä API Severity Distribution:`, severityDist);\n        // If we didn't find any requirements in table format, try alternative parsing\n        if (requirements.length === 0) {\n            console.warn('‚ö†Ô∏è No requirements found in table format, trying alternative parsing...');\n            // Try to find all V-#### patterns and create basic requirements\n            const vulnIdPattern = /V-\\d+/g;\n            const vulnIds = [\n                ...new Set(html.match(vulnIdPattern) || [])\n            ];\n            vulnIds.forEach((vulnId, index)=>{\n                requirements.push({\n                    vulnId,\n                    ruleId: `${vulnId}-rule`,\n                    severity: 'medium',\n                    title: `${stigName} - ${vulnId}`,\n                    description: `Security requirement ${vulnId} from ${stigName}`,\n                    checkText: 'Review the system configuration to verify compliance. Detailed check procedure available in the full STIG documentation.',\n                    fixText: 'Configure the system to meet the security requirement. Detailed fix procedure available in the full STIG documentation.',\n                    cci: [\n                        'CCI-000366'\n                    ],\n                    nistControls: []\n                });\n            });\n            console.log(`üìù Created ${requirements.length} basic requirements from Vuln IDs`);\n        }\n        return {\n            stigId,\n            stigName,\n            version,\n            releaseDate,\n            requirements,\n            totalRequirements: requirements.length\n        };\n    } catch (error) {\n        console.error('Error parsing stigviewer.com HTML:', error);\n        throw new Error(`Failed to parse stigviewer.com page: ${error.message}`);\n    }\n}\n/**\r\n * Parse XCCDF XML file to extract STIG requirements\r\n */ function parseXccdfXml(xmlContent, fileName) {\n    const requirements = [];\n    try {\n        // Extract STIG ID from filename\n        const stigId = fileName.replace(/\\.xml|\\.xccdf/gi, '').toLowerCase().replace(/\\s+/g, '_');\n        // Parse XML using regex (simplified - in production use a proper XML parser)\n        // Extract Benchmark title\n        const titleMatch = xmlContent.match(/<title[^>]*>([^<]+)<\\/title>/i);\n        const stigName = titleMatch ? titleMatch[1].trim() : stigId;\n        // Extract version\n        const versionMatch = xmlContent.match(/<version[^>]*>([^<]+)<\\/version>/i) || xmlContent.match(/Version[:\\s]+([VvRr\\d.]+)/i);\n        const version = versionMatch ? versionMatch[1] : 'Unknown';\n        // Extract release date\n        const dateMatch = xmlContent.match(/release-date[^>]*>([^<]+)</i) || xmlContent.match(/(\\d{1,2}\\s+\\w+\\s+\\d{4})/);\n        const releaseDate = dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0];\n        // Extract all Group elements (requirements)\n        const groupPattern = /<Group[^>]*id=\"([^\"]+)\"[^>]*>([\\s\\S]*?)<\\/Group>/gi;\n        let groupMatch;\n        while((groupMatch = groupPattern.exec(xmlContent)) !== null){\n            const groupId = groupMatch[1];\n            const groupContent = groupMatch[2];\n            // Extract Rule from Group\n            const ruleMatch = groupContent.match(/<Rule[^>]*id=\"([^\"]+)\"[^>]*severity=\"([^\"]+)\"[^>]*>([\\s\\S]*?)<\\/Rule>/i);\n            if (ruleMatch) {\n                const ruleId = ruleMatch[1];\n                const severity = ruleMatch[2].toLowerCase();\n                const ruleContent = ruleMatch[3];\n                // Extract title\n                const titleMatch = ruleContent.match(/<title[^>]*>([^<]+)<\\/title>/i);\n                const title = titleMatch ? titleMatch[1].trim() : `Requirement ${groupId}`;\n                // Extract description\n                const descMatch = ruleContent.match(/<description[^>]*>([\\s\\S]*?)<\\/description>/i);\n                const description = descMatch ? stripHtml(descMatch[1]) : '';\n                // Extract check text\n                const checkMatch = ruleContent.match(/<check-content[^>]*>([\\s\\S]*?)<\\/check-content>/i);\n                const checkText = checkMatch ? stripHtml(checkMatch[1]) : 'No check procedure provided';\n                // Extract fix text\n                const fixMatch = ruleContent.match(/<fixtext[^>]*>([\\s\\S]*?)<\\/fixtext>/i);\n                const fixText = fixMatch ? stripHtml(fixMatch[1]) : 'No fix procedure provided';\n                // Extract CCI references\n                const cciPattern = /<ident[^>]*system=\"http:\\/\\/cyber\\.mil\\/legacy\\/cci\"[^>]*>([^<]+)<\\/ident>/gi;\n                const cci = [];\n                let cciMatch;\n                while((cciMatch = cciPattern.exec(ruleContent)) !== null){\n                    cci.push(cciMatch[1]);\n                }\n                // Extract NIST controls\n                const nistPattern = /<reference[^>]*>([\\s\\S]*?)NIST[^<]*([A-Z]{2}-\\d+(?:\\s*\\(\\d+\\))?(?:\\s*[a-z])?)[^<]*([\\s\\S]*?)<\\/reference>/gi;\n                const nistControls = [];\n                let nistMatch;\n                while((nistMatch = nistPattern.exec(ruleContent)) !== null){\n                    const control = nistMatch[2].trim();\n                    if (control && !nistControls.includes(control)) {\n                        nistControls.push(control);\n                    }\n                }\n                requirements.push({\n                    vulnId: groupId,\n                    ruleId,\n                    severity,\n                    title,\n                    description: description.substring(0, 500),\n                    checkText: checkText.substring(0, 1000),\n                    fixText: fixText.substring(0, 1000),\n                    cci: cci.length > 0 ? cci : [\n                        'CCI-000000'\n                    ],\n                    nistControls: nistControls.length > 0 ? nistControls : [\n                        'AC-1'\n                    ]\n                });\n            }\n        }\n        if (requirements.length === 0) {\n            throw new Error('No requirements found in XML. The file may not be a valid XCCDF STIG file.');\n        }\n        return {\n            stigId,\n            stigName,\n            version,\n            releaseDate,\n            requirements,\n            totalRequirements: requirements.length\n        };\n    } catch (error) {\n        console.error('Error parsing XCCDF XML:', error);\n        throw new Error(`Failed to parse XCCDF XML: ${error.message}`);\n    }\n}\n/**\r\n * Strip HTML tags and decode entities\r\n */ function stripHtml(html) {\n    return html.replace(/<[^>]+>/g, '') // Remove HTML tags\n    .replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '\"').replace(/&#39;/g, \"'\").replace(/&nbsp;/g, ' ').replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUc7WUFDN0IsTUFBTSxJQUFJVSxNQUFNO1FBQ2xCO1FBRUEsT0FBTztZQUNMakM7WUFDQXdEO1lBQ0FDO1lBQ0FDO1lBQ0FwQztZQUNBd0MsbUJBQW1CeEMsYUFBYUMsTUFBTTtRQUN4QztJQUVGLEVBQUUsT0FBT3BCLE9BQVk7UUFDbkJFLFFBQVFGLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzFDLE1BQU0sSUFBSThCLE1BQU0sQ0FBQywyQkFBMkIsRUFBRTlCLE1BQU11QixPQUFPLEVBQUU7SUFDL0Q7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBUzBKLFVBQVVsSixJQUFZO0lBQzdCLE9BQU9BLEtBQ0pxQixPQUFPLENBQUMsWUFBWSxJQUFJLG1CQUFtQjtLQUMzQ0EsT0FBTyxDQUFDLFNBQVMsS0FDakJBLE9BQU8sQ0FBQyxTQUFTLEtBQ2pCQSxPQUFPLENBQUMsVUFBVSxLQUNsQkEsT0FBTyxDQUFDLFdBQVcsS0FDbkJBLE9BQU8sQ0FBQyxVQUFVLEtBQ2xCQSxPQUFPLENBQUMsV0FBVyxLQUNuQkEsT0FBTyxDQUFDLFFBQVEsS0FBSyx1QkFBdUI7S0FDNUNGLElBQUk7QUFDVCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxyb25uaVxcT25lRHJpdmVcXERlc2t0b3BcXFByb2plY3RzXFxTUlRNLXRvb2xcXGFwcFxcYXBpXFxpbXBvcnQtc3RpZ1xccm91dGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcclxuXHJcbi8qKlxyXG4gKiBTVElHIEltcG9ydCBBUElcclxuICogRmV0Y2hlcyBTVElHIHJlcXVpcmVtZW50cyBmcm9tIHN0aWd2aWV3ZXIuY29tIG9yIGFjY2VwdHMgbWFudWFsIHVwbG9hZFxyXG4gKiBcclxuICogTm90ZTogc3RpZ3ZpZXdlci5jb20gaGFzIFNTTCBjZXJ0aWZpY2F0ZSBpc3N1ZXMsIHNvIHdlIGJ5cGFzcyBjZXJ0IHZhbGlkYXRpb25cclxuICovXHJcblxyXG5pbnRlcmZhY2UgU3RpZ1JlcXVpcmVtZW50IHtcclxuICB2dWxuSWQ6IHN0cmluZztcclxuICBydWxlSWQ6IHN0cmluZztcclxuICBzZXZlcml0eTogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgY2hlY2tUZXh0OiBzdHJpbmc7XHJcbiAgZml4VGV4dDogc3RyaW5nO1xyXG4gIGNjaTogc3RyaW5nW107XHJcbiAgbmlzdENvbnRyb2xzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFN0aWdJbXBvcnRSZXN1bHQge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgc3RpZ0lkOiBzdHJpbmc7XHJcbiAgc3RpZ05hbWU6IHN0cmluZztcclxuICB2ZXJzaW9uOiBzdHJpbmc7XHJcbiAgcmVsZWFzZURhdGU6IHN0cmluZztcclxuICByZXF1aXJlbWVudHM6IFN0aWdSZXF1aXJlbWVudFtdO1xyXG4gIHRvdGFsUmVxdWlyZW1lbnRzOiBudW1iZXI7XHJcbiAgc291cmNlOiAnc3RpZ3ZpZXdlcicgfCAnbWFudWFsJyB8ICdjYWNoZSc7XHJcbiAgbWVzc2FnZT86IHN0cmluZztcclxuICBlcnJvcj86IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdFVCAtIEZldGNoIFNUSUcgZnJvbSBzdGlndmlld2VyLmNvbVxyXG4gKiBRdWVyeSBwYXJhbXM6IHN0aWdJZCAoZS5nLiwgJ2FwYWNoZV9zZXJ2ZXJfMi40X3VuaXgnKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XHJcbiAgICBjb25zdCBzdGlnSWQgPSBzZWFyY2hQYXJhbXMuZ2V0KCdzdGlnSWQnKTtcclxuXHJcbiAgICBpZiAoIXN0aWdJZCkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBlcnJvcjogJ3N0aWdJZCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYPCflI0gRmV0Y2hpbmcgU1RJRyBmcm9tIHN0aWd2aWV3ZXIuY29tOiAke3N0aWdJZH1gKTtcclxuXHJcbiAgICAvLyBUcnkgSlNPTiBBUEkgZmlyc3QgKGhhcyBjb21wbGV0ZSBzZXZlcml0eSBkYXRhKVxyXG4gICAgY29uc3QganNvblVybCA9IGBodHRwczovL3N0aWd2aWV3ZXIuY29tL3N0aWdzLyR7c3RpZ0lkfS9qc29uYDtcclxuICAgIGNvbnN0IGh0bWxVcmwgPSBgaHR0cHM6Ly9zdGlndmlld2VyLmNvbS9zdGlncy8ke3N0aWdJZH0vYDtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGN1c3RvbSBhZ2VudCB0byBieXBhc3MgU1NMIGNlcnRpZmljYXRlIHZhbGlkYXRpb25cclxuICAgIGNvbnN0IGFnZW50ID0gbmV3IGh0dHBzLkFnZW50KHtcclxuICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEF0dGVtcHQgSlNPTiBBUEkgZmlyc3RcclxuICAgICAgY29uc29sZS5sb2coYPCfk6UgQXR0ZW1wdGluZyBKU09OIEFQSS4uLmApO1xyXG4gICAgICBjb25zdCBqc29uUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChqc29uVXJsLCB7XHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEyMC4wLjAuMCBTYWZhcmkvNTM3LjM2JyxcclxuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9odG1sLCAqLyonLFxyXG4gICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6ICdlbi1VUyxlbjtxPTAuOScsXHJcbiAgICAgICAgICAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAsIGRlZmxhdGUsIGJyJyxcclxuICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vc3RpZ3ZpZXdlci5jb20vJyxcclxuICAgICAgICAgICdDb25uZWN0aW9uJzogJ2tlZXAtYWxpdmUnLFxyXG4gICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxyXG4gICAgICAgICAgJ1ByYWdtYSc6ICduby1jYWNoZScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgYWdlbnQsXHJcbiAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDE1MDAwKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoanNvblJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QganNvbkRhdGEgPSBhd2FpdCBqc29uUmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgSlNPTiBBUEkgc3VjY2Vzc2Z1bGApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHN0aWdEYXRhID0gcGFyc2VTdGlnVmlld2VySnNvbihqc29uRGF0YSwgc3RpZ0lkKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoc3RpZ0RhdGEucmVxdWlyZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICAgIC4uLnN0aWdEYXRhLFxyXG4gICAgICAgICAgICBzb3VyY2U6ICdzdGlndmlld2VyJyxcclxuICAgICAgICAgICAgbWVzc2FnZTogYFN1Y2Nlc3NmdWxseSBpbXBvcnRlZCAke3N0aWdEYXRhLnJlcXVpcmVtZW50cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmcm9tIEpTT04gQVBJYFxyXG4gICAgICAgICAgfSBhcyBTdGlnSW1wb3J0UmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBKU09OIEFQSSByZXR1cm5lZCAke2pzb25SZXNwb25zZS5zdGF0dXN9OiAke2pzb25SZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChqc29uRXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPIEpTT04gQVBJIGZhaWxlZDogJHtqc29uRXJyb3IubWVzc2FnZX0sIHRyeWluZyBIVE1MLi4uYCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEZhbGxiYWNrIHRvIEhUTUwgcGFyc2luZ1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYPCfk6UgQXR0ZW1wdGluZyBIVE1MIHBhcnNpbmcuLi5gKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIGF2b2lkIHJhdGUgbGltaXRpbmdcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChodG1sVXJsLCB7XHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEyMC4wLjAuMCBTYWZhcmkvNTM3LjM2JyxcclxuICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44JyxcclxuICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnZW4tVVMsZW47cT0wLjknLFxyXG4gICAgICAgICAgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlLCBicicsXHJcbiAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3N0aWd2aWV3ZXIuY29tLycsXHJcbiAgICAgICAgICAnQ29ubmVjdGlvbic6ICdrZWVwLWFsaXZlJyxcclxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcclxuICAgICAgICAgICdQcmFnbWEnOiAnbm8tY2FjaGUnLFxyXG4gICAgICAgICAgJ1NlYy1GZXRjaC1EZXN0JzogJ2RvY3VtZW50JyxcclxuICAgICAgICAgICdTZWMtRmV0Y2gtTW9kZSc6ICduYXZpZ2F0ZScsXHJcbiAgICAgICAgICAnU2VjLUZldGNoLVNpdGUnOiAnc2FtZS1vcmlnaW4nLFxyXG4gICAgICAgICAgJ1VwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHMnOiAnMScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgYWdlbnQsXHJcbiAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDE1MDAwKSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBodG1sID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG5cclxuICAgICAgLy8gUGFyc2UgU1RJRyBpbmZvcm1hdGlvbiBmcm9tIEhUTUxcclxuICAgICAgY29uc3Qgc3RpZ0RhdGEgPSBhd2FpdCBwYXJzZVN0aWdWaWV3ZXJIdG1sKGh0bWwsIHN0aWdJZCk7XHJcblxyXG4gICAgICBpZiAoc3RpZ0RhdGEucmVxdWlyZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVxdWlyZW1lbnRzIGZvdW5kIGluIFNUSUcgZGF0YScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBmZXRjaGVkICR7c3RpZ0RhdGEucmVxdWlyZW1lbnRzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZyb20gc3RpZ3ZpZXdlci5jb21gKTtcclxuXHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XHJcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICAuLi5zdGlnRGF0YSxcclxuICAgICAgICBzb3VyY2U6ICdzdGlndmlld2VyJyxcclxuICAgICAgICBtZXNzYWdlOiBgU3VjY2Vzc2Z1bGx5IGltcG9ydGVkICR7c3RpZ0RhdGEucmVxdWlyZW1lbnRzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZyb20gc3RpZ3ZpZXdlci5jb21gXHJcbiAgICAgIH0gYXMgU3RpZ0ltcG9ydFJlc3VsdCk7XHJcblxyXG4gICAgfSBjYXRjaCAoZmV0Y2hFcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBmcm9tIHN0aWd2aWV3ZXIuY29tOicsIGZldGNoRXJyb3IubWVzc2FnZSk7XHJcblxyXG4gICAgICAvLyBQcm92aWRlIHNwZWNpZmljIGd1aWRhbmNlIGJhc2VkIG9uIGVycm9yIHR5cGVcclxuICAgICAgbGV0IGVycm9yR3VpZGFuY2UgPSAnRmFpbGVkIHRvIGZldGNoIGZyb20gc3RpZ3ZpZXdlci5jb20uIFBsZWFzZSB0cnkgYWdhaW4gb3IgdXBsb2FkIFNUSUcgbWFudWFsbHkuJztcclxuICAgICAgaWYgKGZldGNoRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnNDAzJykgfHwgZmV0Y2hFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdGb3JiaWRkZW4nKSkge1xyXG4gICAgICAgIGVycm9yR3VpZGFuY2UgPSAnc3RpZ3ZpZXdlci5jb20gaXMgYmxvY2tpbmcgYXV0b21hdGVkIHJlcXVlc3RzICg0MDMgRm9yYmlkZGVuKS4gVGhpcyBtYXkgYmUgZHVlIHRvIHJhdGUgbGltaXRpbmcgb3IgYWNjZXNzIHJlc3RyaWN0aW9ucy4gUGxlYXNlIHdhaXQgYSBmZXcgbWludXRlcyBhbmQgdHJ5IGFnYWluLCBvciBkb3dubG9hZCBhbmQgdXBsb2FkIHRoZSBTVElHIG1hbnVhbGx5Lic7XHJcbiAgICAgIH0gZWxzZSBpZiAoZmV0Y2hFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcclxuICAgICAgICBlcnJvckd1aWRhbmNlID0gJ1JlcXVlc3QgdGltZWQgb3V0LiBUaGUgc2VydmVyIG1heSBiZSBzbG93IG9yIHVuYXZhaWxhYmxlLiBQbGVhc2UgdHJ5IGFnYWluLic7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJldHVybiBlcnJvciB3aXRoIGluc3RydWN0aW9ucyBmb3IgbWFudWFsIHVwbG9hZFxyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIHN0aWdJZCxcclxuICAgICAgICBlcnJvcjogZmV0Y2hFcnJvci5tZXNzYWdlLFxyXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yR3VpZGFuY2UsXHJcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiB7XHJcbiAgICAgICAgICBzdGVwMTogJ0Rvd25sb2FkIFNUSUcgWE1MIGZyb20gRElTQSBDeWJlciBFeGNoYW5nZTogaHR0cHM6Ly9wdWJsaWMuY3liZXIubWlsL3N0aWdzL2Rvd25sb2Fkcy8nLFxyXG4gICAgICAgICAgc3RlcDI6ICdPciBkb3dubG9hZCBmcm9tIFNUSUdWaWV3ZXI6IGh0dHBzOi8vc3RpZ3ZpZXdlci5jb20vc3RpZ3MnLFxyXG4gICAgICAgICAgc3RlcDM6ICdVcGxvYWQgdGhlIFhDQ0RGIFhNTCBmaWxlIHVzaW5nIHRoZSBtYW51YWwgdXBsb2FkIG9wdGlvbidcclxuICAgICAgICB9XHJcbiAgICAgIH0sIHsgc3RhdHVzOiA1MDMgfSk7XHJcbiAgICB9XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBTVElHIGltcG9ydDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgIHsgXHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXHJcbiAgICAgICAgbWVzc2FnZTogJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGltcG9ydGluZyBTVElHJ1xyXG4gICAgICB9LFxyXG4gICAgICB7IHN0YXR1czogNTAwIH1cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgRElTQSBTVElHIENTViBmaWxlXHJcbiAqIENTViBmb3JtYXQgZnJvbSBESVNBIEN5YmVyIEV4Y2hhbmdlXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVN0aWdDc3YoY3N2Q29udGVudDogc3RyaW5nLCBmaWxlTmFtZTogc3RyaW5nKTogT21pdDxTdGlnSW1wb3J0UmVzdWx0LCAnc3VjY2VzcycgfCAnc291cmNlJyB8ICdtZXNzYWdlJz4ge1xyXG4gIGNvbnN0IHJlcXVpcmVtZW50czogU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuICBcclxuICAvLyBQcm9wZXJseSBzcGxpdCBDU1YgY29udGVudCBpbnRvIGxpbmVzLCBoYW5kbGluZyBtdWx0aS1saW5lIHF1b3RlZCBmaWVsZHNcclxuICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcclxuICBsZXQgY3VycmVudExpbmUgPSAnJztcclxuICBsZXQgaW5zaWRlUXVvdGVzID0gZmFsc2U7XHJcbiAgXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc3ZDb250ZW50Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjaGFyID0gY3N2Q29udGVudFtpXTtcclxuICAgIGNvbnN0IG5leHRDaGFyID0gY3N2Q29udGVudFtpICsgMV07XHJcbiAgICBcclxuICAgIGlmIChjaGFyID09PSAnXCInKSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gZXNjYXBlZCBxdW90ZVxyXG4gICAgICBpZiAobmV4dENoYXIgPT09ICdcIicpIHtcclxuICAgICAgICBjdXJyZW50TGluZSArPSBjaGFyICsgbmV4dENoYXI7XHJcbiAgICAgICAgaSsrOyAvLyBTa2lwIG5leHQgcXVvdGVcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnNpZGVRdW90ZXMgPSAhaW5zaWRlUXVvdGVzO1xyXG4gICAgICAgIGN1cnJlbnRMaW5lICs9IGNoYXI7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ1xcbicgJiYgIWluc2lkZVF1b3Rlcykge1xyXG4gICAgICBpZiAoY3VycmVudExpbmUudHJpbSgpKSB7XHJcbiAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XHJcbiAgICAgIH1cclxuICAgICAgY3VycmVudExpbmUgPSAnJztcclxuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ1xccicpIHtcclxuICAgICAgLy8gU2tpcCBjYXJyaWFnZSByZXR1cm5zXHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3VycmVudExpbmUgKz0gY2hhcjtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gQWRkIHRoZSBsYXN0IGxpbmUgaWYgbm90IGVtcHR5XHJcbiAgaWYgKGN1cnJlbnRMaW5lLnRyaW0oKSkge1xyXG4gICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnNvbGUubG9nKGDwn5OEIFNwbGl0IENTViBpbnRvICR7bGluZXMubGVuZ3RofSBsaW5lc2ApO1xyXG4gIFxyXG4gIGlmIChsaW5lcy5sZW5ndGggPCAyKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGlnSWQ6IGZpbGVOYW1lLnJlcGxhY2UoL1xcLmNzdiQvaSwgJycpLFxyXG4gICAgICBzdGlnTmFtZTogJ0ltcG9ydGVkIFNUSUcnLFxyXG4gICAgICB2ZXJzaW9uOiAnVW5rbm93bicsXHJcbiAgICAgIHJlbGVhc2VEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcclxuICAgICAgcmVxdWlyZW1lbnRzOiBbXSxcclxuICAgICAgdG90YWxSZXF1aXJlbWVudHM6IDBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQYXJzZSBoZWFkZXIgcm93IC0gaGFuZGxlIHF1b3RlZCBDU1YgZmllbGRzXHJcbiAgY29uc3QgcGFyc2VDU1ZMaW5lID0gKGxpbmU6IHN0cmluZyk6IHN0cmluZ1tdID0+IHtcclxuICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcclxuICAgIGxldCBjdXJyZW50ID0gJyc7XHJcbiAgICBsZXQgaW5RdW90ZXMgPSBmYWxzZTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgY2hhciA9IGxpbmVbaV07XHJcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gbGluZVtpICsgMV07XHJcbiAgICAgIFxyXG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xyXG4gICAgICAgIGlmIChpblF1b3RlcyAmJiBuZXh0Q2hhciA9PT0gJ1wiJykge1xyXG4gICAgICAgICAgLy8gRXNjYXBlZCBxdW90ZVxyXG4gICAgICAgICAgY3VycmVudCArPSAnXCInO1xyXG4gICAgICAgICAgaSsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpblF1b3RlcyA9ICFpblF1b3RlcztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJywnICYmICFpblF1b3Rlcykge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQudHJpbSgpKTtcclxuICAgICAgICBjdXJyZW50ID0gJyc7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3VycmVudCArPSBjaGFyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQucHVzaChjdXJyZW50LnRyaW0oKSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIEZpbmQgdGhlIGhlYWRlciByb3cgKHNraXAgY2xhc3NpZmljYXRpb24gYmFubmVycyBsaWtlIFwifn5+fn5+fiBVbmNsYXNzaWZpZWQgfn5+fn5+XCIpXHJcbiAgbGV0IGhlYWRlckxpbmVJbmRleCA9IDA7XHJcbiAgbGV0IGhlYWRlcnM6IHN0cmluZ1tdID0gW107XHJcbiAgXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbig1LCBsaW5lcy5sZW5ndGgpOyBpKyspIHtcclxuICAgIGNvbnN0IHBhcnNlZExpbmUgPSBwYXJzZUNTVkxpbmUobGluZXNbaV0pO1xyXG4gICAgY29uc3QgbGluZVRleHQgPSBwYXJzZWRMaW5lLmpvaW4oJycpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBcclxuICAgIC8vIFNraXAgY2xhc3NpZmljYXRpb24gYmFubmVycyBhbmQgZW1wdHkgbGluZXNcclxuICAgIGlmIChsaW5lVGV4dC5pbmNsdWRlcygndW5jbGFzc2lmaWVkJykgfHwgbGluZVRleHQuaW5jbHVkZXMoJ35+fn5+JykgfHwgcGFyc2VkTGluZS5sZW5ndGggPCA1KSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiB0aGlzIGxvb2tzIGxpa2UgYSBoZWFkZXIgcm93IChoYXMgY29tbW9uIFNUSUcgY29sdW1uIG5hbWVzKVxyXG4gICAgaWYgKGxpbmVUZXh0LmluY2x1ZGVzKCdzdGlnJykgfHwgbGluZVRleHQuaW5jbHVkZXMoJ3NldmVyaXR5JykgfHwgbGluZVRleHQuaW5jbHVkZXMoJ3J1bGUnKSkge1xyXG4gICAgICBoZWFkZXJMaW5lSW5kZXggPSBpO1xyXG4gICAgICBoZWFkZXJzID0gcGFyc2VkTGluZS5tYXAoaCA9PiBoLnRvTG93ZXJDYXNlKCkudHJpbSgpKTtcclxuICAgICAgY29uc29sZS5sb2coYPCfk4sgRm91bmQgaGVhZGVyIHJvdyBhdCBsaW5lICR7aSArIDF9YCk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICBpZiAoaGVhZGVycy5sZW5ndGggPT09IDApIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBDb3VsZCBub3QgZmluZCB2YWxpZCBoZWFkZXIgcm93IGluIENTVicpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RpZ0lkOiBmaWxlTmFtZS5yZXBsYWNlKC9cXC5jc3YkL2ksICcnKSxcclxuICAgICAgc3RpZ05hbWU6ICdJbXBvcnRlZCBTVElHJyxcclxuICAgICAgdmVyc2lvbjogJ1Vua25vd24nLFxyXG4gICAgICByZWxlYXNlRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXHJcbiAgICAgIHJlcXVpcmVtZW50czogW10sXHJcbiAgICAgIHRvdGFsUmVxdWlyZW1lbnRzOiAwXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coYPCfk4sgQ1NWIEhlYWRlcnMgZm91bmQ6ICR7aGVhZGVycy5zbGljZSgwLCAxMCkuam9pbignLCAnKX0uLi5gKTtcclxuICBjb25zb2xlLmxvZyhg8J+TiyBBbGwgaGVhZGVycyAoZmlyc3QgMTUpOmAsIGhlYWRlcnMuc2xpY2UoMCwgMTUpKTtcclxuICBcclxuICAvLyBGaW5kIGNvbHVtbiBpbmRpY2VzXHJcbiAgY29uc3QgZ2V0SW5kZXggPSAobmFtZXM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcclxuICAgICAgY29uc3QgaWR4ID0gaGVhZGVycy5maW5kSW5kZXgoaCA9PiBoLmluY2x1ZGVzKG5hbWUpKTtcclxuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIFwiJHtuYW1lfVwiIGF0IGluZGV4ICR7aWR4fTogXCIke2hlYWRlcnNbaWR4XX1cImApO1xyXG4gICAgICAgIHJldHVybiBpZHg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKGDinYwgQ291bGQgbm90IGZpbmQgYW55IG9mOiAke25hbWVzLmpvaW4oJywgJyl9YCk7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgc3RpZ0lkSWR4ID0gZ2V0SW5kZXgoWydzdGlnIGlkJywgJ3N0aWdpZCddKTtcclxuICBjb25zdCBzZXZlcml0eUlkeCA9IGdldEluZGV4KFsnc2V2ZXJpdHknXSk7XHJcbiAgY29uc3QgdGl0bGVJZHggPSBnZXRJbmRleChbJ3J1bGUgdGl0bGUnLCAncnVsZXRpdGxlJ10pO1xyXG4gIGNvbnN0IGRpc2N1c3Npb25JZHggPSBnZXRJbmRleChbJ2Rpc2N1c3Npb24nXSk7XHJcbiAgY29uc3QgY2hlY2tJZHggPSBnZXRJbmRleChbJ2NoZWNrIGNvbnRlbnQnLCAnY2hlY2tjb250ZW50J10pO1xyXG4gIGNvbnN0IGZpeElkeCA9IGdldEluZGV4KFsnZml4IHRleHQnLCAnZml4dGV4dCddKTtcclxuICBjb25zdCBjY2lJZHggPSBnZXRJbmRleChbJ2NjaXMnLCAnY2NpJ10pO1xyXG4gIGNvbnN0IHJ1bGVJZElkeCA9IGdldEluZGV4KFsncnVsZSBpZCcsICdydWxlaWQnXSk7XHJcbiAgXHJcbiAgY29uc29sZS5sb2coYPCfk4ogQ29sdW1uIGluZGljZXM6YCwge1xyXG4gICAgc3RpZ0lkOiBzdGlnSWRJZHgsXHJcbiAgICBzZXZlcml0eTogc2V2ZXJpdHlJZHgsXHJcbiAgICB0aXRsZTogdGl0bGVJZHgsXHJcbiAgICBkaXNjdXNzaW9uOiBkaXNjdXNzaW9uSWR4LFxyXG4gICAgY2hlY2s6IGNoZWNrSWR4LFxyXG4gICAgZml4OiBmaXhJZHgsXHJcbiAgICBjY2k6IGNjaUlkeCxcclxuICAgIHJ1bGVJZDogcnVsZUlkSWR4XHJcbiAgfSk7XHJcblxyXG4gIGxldCBzdGlnTmFtZSA9ICdJbXBvcnRlZCBTVElHJztcclxuICBsZXQgdmVyc2lvbiA9ICdVbmtub3duJztcclxuICBcclxuICBjb25zb2xlLmxvZyhg8J+ThCBQcm9jZXNzaW5nICR7bGluZXMubGVuZ3RoIC0gaGVhZGVyTGluZUluZGV4IC0gMX0gZGF0YSByb3dzIGZyb20gQ1NWYCk7XHJcbiAgXHJcbiAgLy8gUGFyc2UgZGF0YSByb3dzIChzdGFydCBhZnRlciBoZWFkZXIgcm93KVxyXG4gIGZvciAobGV0IGkgPSBoZWFkZXJMaW5lSW5kZXggKyAxOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XHJcbiAgICBpZiAoIWxpbmUpIGNvbnRpbnVlO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlcyA9IHBhcnNlQ1NWTGluZShsaW5lKTtcclxuICAgIFxyXG4gICAgaWYgKGkgPT09IGhlYWRlckxpbmVJbmRleCArIDEpIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfk50gRmlyc3QgZGF0YSByb3cgaGFzICR7dmFsdWVzLmxlbmd0aH0gdmFsdWVzYCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgU1RJRyBuYW1lIGZyb20gZmlyc3QgZGF0YSByb3cgaWYgYXZhaWxhYmxlXHJcbiAgICBpZiAoaSA9PT0gaGVhZGVyTGluZUluZGV4ICsgMSAmJiB2YWx1ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBiZW5jaG1hcmtJZHggPSBoZWFkZXJzLmZpbmRJbmRleChoID0+IGguaW5jbHVkZXMoJ2JlbmNobWFyaycpKTtcclxuICAgICAgaWYgKGJlbmNobWFya0lkeCAhPT0gLTEgJiYgdmFsdWVzW2JlbmNobWFya0lkeF0pIHtcclxuICAgICAgICBzdGlnTmFtZSA9IHZhbHVlc1tiZW5jaG1hcmtJZHhdO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHZlcnNpb25JZHggPSBoZWFkZXJzLmZpbmRJbmRleChoID0+IGguaW5jbHVkZXMoJ3ZlcnNpb24nKSB8fCBoLmluY2x1ZGVzKCdyZWxlYXNlJykpO1xyXG4gICAgICBpZiAodmVyc2lvbklkeCAhPT0gLTEgJiYgdmFsdWVzW3ZlcnNpb25JZHhdKSB7XHJcbiAgICAgICAgdmVyc2lvbiA9IHZhbHVlc1t2ZXJzaW9uSWR4XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHZ1bG5JZCA9IHN0aWdJZElkeCAhPT0gLTEgPyB2YWx1ZXNbc3RpZ0lkSWR4XSA6ICcnO1xyXG4gICAgY29uc3QgcnVsZUlkID0gcnVsZUlkSWR4ICE9PSAtMSA/IHZhbHVlc1tydWxlSWRJZHhdIDogdnVsbklkO1xyXG4gICAgXHJcbiAgICBpZiAoIXZ1bG5JZCkge1xyXG4gICAgICBpZiAoaSA8PSBoZWFkZXJMaW5lSW5kZXggKyAzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBMaW5lICR7aX06IE5vIFNUSUcgSUQgZm91bmRgKTtcclxuICAgICAgfVxyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKGkgPT09IGhlYWRlckxpbmVJbmRleCArIDEpIHtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBGaXJzdCByZXF1aXJlbWVudCBmb3VuZDogJHt2dWxuSWR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2Ugc2V2ZXJpdHkgLSBoYW5kbGUgbXVsdGlwbGUgZm9ybWF0c1xyXG4gICAgY29uc3Qgc2V2ZXJpdHlWYWx1ZSA9IHNldmVyaXR5SWR4ICE9PSAtMSA/IHZhbHVlc1tzZXZlcml0eUlkeF0udG9Mb3dlckNhc2UoKS50cmltKCkgOiAnbWVkaXVtJztcclxuICAgIGxldCBzZXZlcml0eTogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JyA9ICdtZWRpdW0nO1xyXG4gICAgXHJcbiAgICAvLyBEaXJlY3Qgc2V2ZXJpdHkgdmFsdWVzXHJcbiAgICBpZiAoc2V2ZXJpdHlWYWx1ZSA9PT0gJ2hpZ2gnIHx8IHNldmVyaXR5VmFsdWUuaW5jbHVkZXMoJ2NhdCBpJykgfHwgc2V2ZXJpdHlWYWx1ZS5pbmNsdWRlcygnY2F0IDEnKSB8fCBzZXZlcml0eVZhbHVlLmluY2x1ZGVzKCdjYXRpJykpIHtcclxuICAgICAgc2V2ZXJpdHkgPSAnaGlnaCc7XHJcbiAgICB9IGVsc2UgaWYgKHNldmVyaXR5VmFsdWUgPT09ICdsb3cnIHx8IHNldmVyaXR5VmFsdWUuaW5jbHVkZXMoJ2NhdCBpaWknKSB8fCBzZXZlcml0eVZhbHVlLmluY2x1ZGVzKCdjYXQgMycpIHx8IHNldmVyaXR5VmFsdWUuaW5jbHVkZXMoJ2NhdGlpaScpKSB7XHJcbiAgICAgIHNldmVyaXR5ID0gJ2xvdyc7XHJcbiAgICB9IGVsc2UgaWYgKHNldmVyaXR5VmFsdWUgPT09ICdtZWRpdW0nIHx8IHNldmVyaXR5VmFsdWUuaW5jbHVkZXMoJ2NhdCBpaScpIHx8IHNldmVyaXR5VmFsdWUuaW5jbHVkZXMoJ2NhdCAyJykgfHwgc2V2ZXJpdHlWYWx1ZS5pbmNsdWRlcygnY2F0aWknKSkge1xyXG4gICAgICBzZXZlcml0eSA9ICdtZWRpdW0nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBMb2cgZmlyc3QgZmV3IGZvciBkZWJ1Z2dpbmdcclxuICAgIGlmIChpIDw9IGhlYWRlckxpbmVJbmRleCArIDMpIHtcclxuICAgICAgY29uc29sZS5sb2coYPCfk4ogUm93ICR7aSAtIGhlYWRlckxpbmVJbmRleH06IHZ1bG5JZD1cIiR7dnVsbklkfVwiLCBzZXZlcml0eT1cIiR7c2V2ZXJpdHlWYWx1ZX1cIiDihpIgJHtzZXZlcml0eX1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeHRyYWN0IENDSSByZWZlcmVuY2VzXHJcbiAgICBjb25zdCBjY2lUZXh0ID0gY2NpSWR4ICE9PSAtMSA/IHZhbHVlc1tjY2lJZHhdIDogJyc7XHJcbiAgICBjb25zdCBjY2lNYXRjaGVzID0gY2NpVGV4dC5tYXRjaCgvQ0NJLVxcZCsvZyk7XHJcbiAgICBjb25zdCBjY2kgPSBjY2lNYXRjaGVzIHx8IFsnQ0NJLTAwMDM2NiddO1xyXG5cclxuICAgIHJlcXVpcmVtZW50cy5wdXNoKHtcclxuICAgICAgdnVsbklkLFxyXG4gICAgICBydWxlSWQsXHJcbiAgICAgIHNldmVyaXR5LFxyXG4gICAgICB0aXRsZTogdGl0bGVJZHggIT09IC0xID8gdmFsdWVzW3RpdGxlSWR4XSA6IGBSZXF1aXJlbWVudCAke3Z1bG5JZH1gLFxyXG4gICAgICBkZXNjcmlwdGlvbjogZGlzY3Vzc2lvbklkeCAhPT0gLTEgPyB2YWx1ZXNbZGlzY3Vzc2lvbklkeF0gOiAnTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQnLFxyXG4gICAgICBjaGVja1RleHQ6IGNoZWNrSWR4ICE9PSAtMSA/IHZhbHVlc1tjaGVja0lkeF0gOiAnUmV2aWV3IHN5c3RlbSBjb25maWd1cmF0aW9uIHBlciBTVElHIGd1aWRhbmNlLicsXHJcbiAgICAgIGZpeFRleHQ6IGZpeElkeCAhPT0gLTEgPyB2YWx1ZXNbZml4SWR4XSA6ICdDb25maWd1cmUgc3lzdGVtIHBlciBTVElHIGd1aWRhbmNlLicsXHJcbiAgICAgIGNjaSxcclxuICAgICAgbmlzdENvbnRyb2xzOiBbXVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjb25zb2xlLmxvZyhg4pyFIENTViBwYXJzaW5nIGNvbXBsZXRlOiAke3JlcXVpcmVtZW50cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmb3VuZGApO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3RpZ0lkOiBmaWxlTmFtZS5yZXBsYWNlKC9cXC5jc3YkL2ksICcnKSxcclxuICAgIHN0aWdOYW1lLFxyXG4gICAgdmVyc2lvbixcclxuICAgIHJlbGVhc2VEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcclxuICAgIHJlcXVpcmVtZW50cyxcclxuICAgIHRvdGFsUmVxdWlyZW1lbnRzOiByZXF1aXJlbWVudHMubGVuZ3RoXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBPU1QgLSBNYW51YWwgU1RJRyB1cGxvYWQgKFhNTCBvciBDU1YgZmlsZSlcclxuICogQm9keTogRm9ybURhdGEgd2l0aCAnZmlsZScgZmllbGQgY29udGFpbmluZyBYQ0NERiBYTUwgb3IgRElTQSBDU1ZcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xyXG4gICAgY29uc3QgZmlsZSA9IGZvcm1EYXRhLmdldCgnZmlsZScpIGFzIEZpbGU7XHJcblxyXG4gICAgaWYgKCFmaWxlKSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IGVycm9yOiAnTm8gZmlsZSBwcm92aWRlZCcgfSxcclxuICAgICAgICB7IHN0YXR1czogNDAwIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBmaWxlIHR5cGVcclxuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCBpc1htbCA9IGZpbGVOYW1lLmVuZHNXaXRoKCcueG1sJykgfHwgZmlsZU5hbWUuZW5kc1dpdGgoJy54Y2NkZicpO1xyXG4gICAgY29uc3QgaXNDc3YgPSBmaWxlTmFtZS5lbmRzV2l0aCgnLmNzdicpO1xyXG4gICAgXHJcbiAgICBpZiAoIWlzWG1sICYmICFpc0Nzdikge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBlcnJvcjogJ0ludmFsaWQgZmlsZSB0eXBlLiBQbGVhc2UgdXBsb2FkIGFuIFhDQ0RGIFhNTCBmaWxlIG9yIERJU0EgQ1NWIGZpbGUuJyB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnNvbGUubG9nKGDwn5OBIFByb2Nlc3NpbmcgbWFudWFsIFNUSUcgdXBsb2FkOiAke2ZpbGUubmFtZX1gKTtcclxuXHJcbiAgICAvLyBSZWFkIGZpbGUgY29udGVudFxyXG4gICAgY29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCBmaWxlLnRleHQoKTtcclxuXHJcbiAgICBsZXQgc3RpZ0RhdGE7XHJcbiAgICBcclxuICAgIGlmIChpc0Nzdikge1xyXG4gICAgICAvLyBQYXJzZSBDU1YgZmlsZVxyXG4gICAgICBzdGlnRGF0YSA9IHBhcnNlU3RpZ0NzdihmaWxlQ29udGVudCwgZmlsZU5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gUGFyc2UgWENDREYgWE1MXHJcbiAgICAgIHN0aWdEYXRhID0gcGFyc2VYY2NkZlhtbChmaWxlQ29udGVudCwgZmlsZU5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGlnRGF0YS5yZXF1aXJlbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcmVxdWlyZW1lbnRzIGZvdW5kIGluICR7aXNDc3YgPyAnQ1NWJyA6ICdYTUwnfSBmaWxlLiBQbGVhc2UgZW5zdXJlIHRoaXMgaXMgYSB2YWxpZCBESVNBIFNUSUcgZmlsZS5gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBwYXJzZWQgJHtzdGlnRGF0YS5yZXF1aXJlbWVudHMubGVuZ3RofSByZXF1aXJlbWVudHMgZnJvbSBtYW51YWwgdXBsb2FkYCk7XHJcblxyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgLi4uc3RpZ0RhdGEsXHJcbiAgICAgIHNvdXJjZTogJ21hbnVhbCcsXHJcbiAgICAgIG1lc3NhZ2U6IGBTdWNjZXNzZnVsbHkgaW1wb3J0ZWQgJHtzdGlnRGF0YS5yZXF1aXJlbWVudHMubGVuZ3RofSByZXF1aXJlbWVudHMgZnJvbSAke2ZpbGUubmFtZX1gXHJcbiAgICB9IGFzIFN0aWdJbXBvcnRSZXN1bHQpO1xyXG5cclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgcHJvY2Vzc2luZyBtYW51YWwgdXBsb2FkOicsIGVycm9yKTtcclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgeyBcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcclxuICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIHBhcnNlIFNUSUcgZmlsZS4gUGxlYXNlIGVuc3VyZSB0aGlzIGlzIGEgdmFsaWQgWENDREYgWE1MIGZpbGUuJ1xyXG4gICAgICB9LFxyXG4gICAgICB7IHN0YXR1czogNTAwIH1cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRmV0Y2ggZGV0YWlsZWQgcmVxdWlyZW1lbnQgcGFnZSBmcm9tIHN0aWd2aWV3ZXIuY29tXHJcbiAqIFJldHVybnMgY2hlY2sgYW5kIGZpeCB0ZXh0IGZvciBhIHNwZWNpZmljIHZ1bG5lcmFiaWxpdHlcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVxdWlyZW1lbnREZXRhaWxzKHN0aWdJZDogc3RyaW5nLCB2dWxuSWQ6IHN0cmluZyk6IFByb21pc2U8e2NoZWNrVGV4dDogc3RyaW5nLCBmaXhUZXh0OiBzdHJpbmd9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGFnZW50ID0gbmV3IGh0dHBzLkFnZW50KHsgcmVqZWN0VW5hdXRob3JpemVkOiBmYWxzZSB9KTtcclxuICAgIGNvbnN0IHVybCA9IGBodHRwczovL3N0aWd2aWV3ZXIuY29tL3N0aWcvJHtzdGlnSWR9L3JlcXVpcmVtZW50LyR7dnVsbklkfWA7XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnVXNlci1BZ2VudCc6ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYnLFxyXG4gICAgICB9LFxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIGFnZW50LFxyXG4gICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoMTAwMDApLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBodG1sID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGNoZWNrIHRleHRcclxuICAgIGNvbnN0IGNoZWNrTWF0Y2ggPSBodG1sLm1hdGNoKC88ZGl2W14+XSooPzppZHxjbGFzcyk9XCJbXlwiXSpjaGVja1teXCJdKlwiW14+XSo+KFtcXHNcXFNdKj8pPFxcL2Rpdj4vaSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgIGh0bWwubWF0Y2goL0NoZWNrIFRleHRbOlxcc10qPFtePl0qPihbXFxzXFxTXSo/KTxcXC8oPzpkaXZ8cHJlfHApPi9pKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgaHRtbC5tYXRjaCgvPHByZVtePl0qPihbXFxzXFxTXSo/KTxcXC9wcmU+L2kpO1xyXG4gICAgXHJcbiAgICBjb25zdCBjaGVja1RleHQgPSBjaGVja01hdGNoID8gXHJcbiAgICAgIGNoZWNrTWF0Y2hbMV1cclxuICAgICAgICAucmVwbGFjZSgvPFtePl0rPi9nLCAnJylcclxuICAgICAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpXHJcbiAgICAgICAgLnJlcGxhY2UoLyZndDsvZywgJz4nKVxyXG4gICAgICAgIC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpXHJcbiAgICAgICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJylcclxuICAgICAgICAudHJpbSgpIDogXHJcbiAgICAgICdSZXZpZXcgdGhlIHN5c3RlbSBjb25maWd1cmF0aW9uIHRvIHZlcmlmeSBjb21wbGlhbmNlIHdpdGggdGhlIHNlY3VyaXR5IHJlcXVpcmVtZW50Lic7XHJcbiAgICBcclxuICAgIC8vIEV4dHJhY3QgZml4IHRleHQgIFxyXG4gICAgY29uc3QgZml4TWF0Y2ggPSBodG1sLm1hdGNoKC88ZGl2W14+XSooPzppZHxjbGFzcyk9XCJbXlwiXSpmaXhbXlwiXSpcIltePl0qPihbXFxzXFxTXSo/KTxcXC9kaXY+L2kpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbC5tYXRjaCgvRml4IFRleHRbOlxcc10qPFtePl0qPihbXFxzXFxTXSo/KTxcXC8oPzpkaXZ8cHJlfHApPi9pKTtcclxuICAgIFxyXG4gICAgY29uc3QgZml4VGV4dCA9IGZpeE1hdGNoID8gXHJcbiAgICAgIGZpeE1hdGNoWzFdXHJcbiAgICAgICAgLnJlcGxhY2UoLzxbXj5dKz4vZywgJycpXHJcbiAgICAgICAgLnJlcGxhY2UoLyZsdDsvZywgJzwnKVxyXG4gICAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csICc+JylcclxuICAgICAgICAucmVwbGFjZSgvJmFtcDsvZywgJyYnKVxyXG4gICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcclxuICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXHJcbiAgICAgICAgLnRyaW0oKSA6IFxyXG4gICAgICAnQ29uZmlndXJlIHRoZSBzeXN0ZW0gdG8gbWVldCB0aGUgc2VjdXJpdHkgcmVxdWlyZW1lbnQgYXMgc3BlY2lmaWVkIGluIHRoZSBTVElHIGRvY3VtZW50YXRpb24uJztcclxuICAgIFxyXG4gICAgcmV0dXJuIHsgY2hlY2tUZXh0LCBmaXhUZXh0IH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIC8vIFJldHVybiBkZWZhdWx0cyBpZiBmZXRjaCBmYWlsc1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2hlY2tUZXh0OiAnUmV2aWV3IHRoZSBzeXN0ZW0gY29uZmlndXJhdGlvbiB0byB2ZXJpZnkgY29tcGxpYW5jZSB3aXRoIHRoZSBzZWN1cml0eSByZXF1aXJlbWVudC4gRGV0YWlsZWQgY2hlY2sgcHJvY2VkdXJlIGF2YWlsYWJsZSBpbiB0aGUgZnVsbCBTVElHIGRvY3VtZW50YXRpb24uJyxcclxuICAgICAgZml4VGV4dDogJ0NvbmZpZ3VyZSB0aGUgc3lzdGVtIHRvIG1lZXQgdGhlIHNlY3VyaXR5IHJlcXVpcmVtZW50LiBEZXRhaWxlZCBmaXggcHJvY2VkdXJlIGF2YWlsYWJsZSBpbiB0aGUgZnVsbCBTVElHIGRvY3VtZW50YXRpb24uJ1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBzdGlnIHZpZXdlci5jb20gSlNPTiBBUEkgcmVzcG9uc2VcclxuICogSlNPTiBmb3JtYXQgaGFzIGNvbXBsZXRlIGRhdGEgaW5jbHVkaW5nIHNldmVyaXR5IGZvciBlYWNoIHJlcXVpcmVtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVN0aWdWaWV3ZXJKc29uKGpzb25EYXRhOiBhbnksIHN0aWdJZDogc3RyaW5nKTogT21pdDxTdGlnSW1wb3J0UmVzdWx0LCAnc3VjY2VzcycgfCAnc291cmNlJyB8ICdtZXNzYWdlJz4ge1xyXG4gIGNvbnN0IHJlcXVpcmVtZW50czogU3RpZ1JlcXVpcmVtZW50W10gPSBbXTtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHN0aWcgPSBqc29uRGF0YS5zdGlnIHx8IGpzb25EYXRhO1xyXG4gICAgY29uc3Qgc3RpZ05hbWUgPSBzdGlnLnRpdGxlIHx8IHN0aWdJZDtcclxuICAgIGNvbnN0IHZlcnNpb24gPSBzdGlnLnZlcnNpb24gfHwgJ1Vua25vd24nO1xyXG4gICAgY29uc3QgcmVsZWFzZURhdGUgPSBzdGlnLmRhdGUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGDwn5OLIFBhcnNpbmcgSlNPTjogJHtzdGlnTmFtZX0sIFZlcnNpb246ICR7dmVyc2lvbn0sIFJlbGVhc2U6ICR7cmVsZWFzZURhdGV9YCk7XHJcblxyXG4gICAgY29uc3QgZmluZGluZ3MgPSBzdGlnLmZpbmRpbmdzIHx8IHt9O1xyXG4gICAgY29uc3QgdnVsbklkcyA9IE9iamVjdC5rZXlzKGZpbmRpbmdzKTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCflI0gRm91bmQgJHt2dWxuSWRzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGluIEpTT05gKTtcclxuXHJcbiAgICB2dWxuSWRzLmZvckVhY2goKHZ1bG5JZCkgPT4ge1xyXG4gICAgICBjb25zdCBmaW5kaW5nID0gZmluZGluZ3NbdnVsbklkXTtcclxuICAgICAgaWYgKCFmaW5kaW5nKSByZXR1cm47XHJcblxyXG4gICAgICAvLyBFeHRyYWN0IHNldmVyaXR5IGZyb20gZmluZGluZ1xyXG4gICAgICAvLyBKU09OIG1pZ2h0IGhhdmUgc2V2ZXJpdHkgYXMgXCJoaWdoXCIsIFwibWVkaXVtXCIsIFwibG93XCIgb3IgXCJDQVQgSVwiLCBcIkNBVCBJSVwiLCBcIkNBVCBJSUlcIlxyXG4gICAgICBsZXQgc2V2ZXJpdHk6ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdycgPSAnbWVkaXVtJztcclxuICAgICAgY29uc3Qgc2V2VGV4dCA9IChmaW5kaW5nLnNldmVyaXR5IHx8IGZpbmRpbmcuY2F0IHx8ICdtZWRpdW0nKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoc2V2VGV4dC5pbmNsdWRlcygnaGlnaCcpIHx8IHNldlRleHQuaW5jbHVkZXMoJ2NhdCBpJykgfHwgc2V2VGV4dCA9PT0gJ2knIHx8IHNldlRleHQgPT09ICcxJykge1xyXG4gICAgICAgIHNldmVyaXR5ID0gJ2hpZ2gnO1xyXG4gICAgICB9IGVsc2UgaWYgKHNldlRleHQuaW5jbHVkZXMoJ2xvdycpIHx8IHNldlRleHQuaW5jbHVkZXMoJ2NhdCBpaWknKSB8fCBzZXZUZXh0ID09PSAnaWlpJyB8fCBzZXZUZXh0ID09PSAnMycpIHtcclxuICAgICAgICBzZXZlcml0eSA9ICdsb3cnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldmVyaXR5ID0gJ21lZGl1bSc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlcXVpcmVtZW50cy5wdXNoKHtcclxuICAgICAgICB2dWxuSWQsXHJcbiAgICAgICAgcnVsZUlkOiBmaW5kaW5nLnJ1bGVJZCB8fCBmaW5kaW5nLnJ1bGVfaWQgfHwgZmluZGluZy5ydWxlaWQgfHwgYCR7dnVsbklkfS1ydWxlYCxcclxuICAgICAgICBzZXZlcml0eSxcclxuICAgICAgICB0aXRsZTogZmluZGluZy50aXRsZSB8fCBmaW5kaW5nLnJ1bGVUaXRsZSB8fCBmaW5kaW5nLnJ1bGV0aXRsZSB8fCBgUmVxdWlyZW1lbnQgJHt2dWxuSWR9YCxcclxuICAgICAgICBkZXNjcmlwdGlvbjogZmluZGluZy5kaXNjdXNzaW9uIHx8IGZpbmRpbmcuZGVzY3JpcHRpb24gfHwgZmluZGluZy50aXRsZSB8fCAnJyxcclxuICAgICAgICBjaGVja1RleHQ6IGZpbmRpbmcuY2hlY2t0ZXh0IHx8IGZpbmRpbmcuY2hlY2tUZXh0IHx8IGZpbmRpbmcuY2hlY2tfdGV4dCB8fCBmaW5kaW5nLmNoZWNrIHx8ICdSZXZpZXcgc3lzdGVtIGNvbmZpZ3VyYXRpb24gcGVyIFNUSUcgZ3VpZGFuY2UuJyxcclxuICAgICAgICBmaXhUZXh0OiBmaW5kaW5nLmZpeHRleHQgfHwgZmluZGluZy5maXhUZXh0IHx8IGZpbmRpbmcuZml4X3RleHQgfHwgZmluZGluZy5maXggfHwgJ0NvbmZpZ3VyZSBzeXN0ZW0gcGVyIFNUSUcgZ3VpZGFuY2UuJyxcclxuICAgICAgICBjY2k6IGZpbmRpbmcuY2NpIHx8IGZpbmRpbmcuY2NpcyB8fCBbJ0NDSS0wMDAzNjYnXSxcclxuICAgICAgICBuaXN0Q29udHJvbHM6IGZpbmRpbmcubmlzdENvbnRyb2xzIHx8IGZpbmRpbmcubmlzdCB8fCBbXVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IHBhcnNlZCAke3JlcXVpcmVtZW50cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmcm9tIEpTT05gKTtcclxuICAgIFxyXG4gICAgLy8gTG9nIHNldmVyaXR5IGRpc3RyaWJ1dGlvblxyXG4gICAgY29uc3Qgc2V2ZXJpdHlEaXN0OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XHJcbiAgICByZXF1aXJlbWVudHMuZm9yRWFjaChyZXEgPT4ge1xyXG4gICAgICBzZXZlcml0eURpc3RbcmVxLnNldmVyaXR5XSA9IChzZXZlcml0eURpc3RbcmVxLnNldmVyaXR5XSB8fCAwKSArIDE7XHJcbiAgICB9KTtcclxuICAgIGNvbnNvbGUubG9nKGDwn5OKIEpTT04gU2V2ZXJpdHkgRGlzdHJpYnV0aW9uOmAsIHNldmVyaXR5RGlzdCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RpZ0lkLFxyXG4gICAgICBzdGlnTmFtZSxcclxuICAgICAgdmVyc2lvbixcclxuICAgICAgcmVsZWFzZURhdGUsXHJcbiAgICAgIHJlcXVpcmVtZW50cyxcclxuICAgICAgdG90YWxSZXF1aXJlbWVudHM6IHJlcXVpcmVtZW50cy5sZW5ndGhcclxuICAgIH07XHJcblxyXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgc3RpZ3ZpZXdlci5jb20gSlNPTjonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdGlndmlld2VyLmNvbSBKU09OOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGFyc2Ugc3RpZ3ZpZXdlci5jb20gSFRNTCB0byBleHRyYWN0IFNUSUcgcmVxdWlyZW1lbnRzXHJcbiAqIEZldGNoZXMgZnVsbCByZXF1aXJlbWVudCBkZXRhaWxzIGluY2x1ZGluZyBjaGVjayBhbmQgZml4IHRleHRcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlU3RpZ1ZpZXdlckh0bWwoaHRtbDogc3RyaW5nLCBzdGlnSWQ6IHN0cmluZyk6IFByb21pc2U8T21pdDxTdGlnSW1wb3J0UmVzdWx0LCAnc3VjY2VzcycgfCAnc291cmNlJyB8ICdtZXNzYWdlJz4+IHtcclxuICBjb25zdCByZXF1aXJlbWVudHM6IFN0aWdSZXF1aXJlbWVudFtdID0gW107XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBFeHRyYWN0IFNUSUcgbWV0YWRhdGEgZnJvbSBwYWdlIHRpdGxlIGFuZCBoZWFkZXJzXHJcbiAgICBjb25zdCB0aXRsZU1hdGNoID0gaHRtbC5tYXRjaCgvPHRpdGxlPihbXjxdKyk8XFwvdGl0bGU+L2kpO1xyXG4gICAgY29uc3Qgc3RpZ05hbWUgPSB0aXRsZU1hdGNoID8gdGl0bGVNYXRjaFsxXS5yZXBsYWNlKCcgfCBTVElHVmlld2VyJywgJycpLnRyaW0oKSA6IHN0aWdJZDtcclxuXHJcbiAgICAvLyBFeHRyYWN0IHZlcnNpb24gZnJvbSBwYWdlXHJcbiAgICBjb25zdCB2ZXJzaW9uTWF0Y2ggPSBodG1sLm1hdGNoKC9WZXJzaW9uWzpcXHNdKyhbVnZSclxcZC5dKykvaSkgfHwgaHRtbC5tYXRjaCgvY2xhc3M9XCJbXlwiXSp2ZXJzaW9uW15cIl0qXCJbXj5dKj4oW148XSspPC9pKTtcclxuICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uTWF0Y2ggPyB2ZXJzaW9uTWF0Y2hbMV0udHJpbSgpIDogJ1Vua25vd24nO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgcmVsZWFzZSBkYXRlXHJcbiAgICBjb25zdCBkYXRlTWF0Y2ggPSBodG1sLm1hdGNoKC9SZWxlYXNlWzpcXHNdKyhcXGR7MSwyfVxccytcXHcrXFxzK1xcZHs0fSkvaSkgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgIGh0bWwubWF0Y2goL0RhdGVbOlxcc10rKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KS9pKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICBodG1sLm1hdGNoKC8oXFxkezR9LVxcZHsyfS1cXGR7Mn0pLyk7XHJcbiAgICBjb25zdCByZWxlYXNlRGF0ZSA9IGRhdGVNYXRjaCA/IGRhdGVNYXRjaFsxXSA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGDwn5OLIFBhcnNpbmcgU1RJRzogJHtzdGlnTmFtZX0sIFZlcnNpb246ICR7dmVyc2lvbn0sIFJlbGVhc2U6ICR7cmVsZWFzZURhdGV9YCk7XHJcblxyXG4gICAgLy8gTWV0aG9kIDE6IEV4dHJhY3QgY29tcGxldGUgcmVxdWlyZW1lbnQgZW50cmllcyB3aXRoIGFsbCBkZXRhaWxzXHJcbiAgICAvLyBzdGlndmlld2VyLmNvbSBoYXMgbGlua3MgbGlrZTogaHJlZj1cIi9zdGlnL3tzdGlnSWR9L3JlcXVpcmVtZW50L1YtIyMjIyNcIlxyXG4gICAgLy8gUGF0dGVybiB0byBtYXRjaCBlbnRpcmUgcmVxdWlyZW1lbnQgc2VjdGlvbnMgd2l0aCBzZXZlcml0eSBpbmZvXHJcbiAgICBjb25zdCByZXFTZWN0aW9uUGF0dGVybiA9IC8oPzpDQVRcXHMrKEl7MSwzfSl8c2V2ZXJpdHlbXj5dKj8oaGlnaHxtZWRpdW18bG93KSlbXlZdKihWLVxcZCspW148XSo8YVtePl0qaHJlZj1cIlteXCJdKlxcL3JlcXVpcmVtZW50XFwvXFwzXCJbXj5dKj4oW148XSspPC9naTtcclxuICAgIGxldCBtYXRjaDtcclxuICAgIGNvbnN0IGRldGFpbGVkUmVxczogQXJyYXk8e3Z1bG5JZDogc3RyaW5nLCBzZXZlcml0eTogc3RyaW5nLCB0aXRsZTogc3RyaW5nfT4gPSBbXTtcclxuICAgIFxyXG4gICAgd2hpbGUgKChtYXRjaCA9IHJlcVNlY3Rpb25QYXR0ZXJuLmV4ZWMoaHRtbCkpICE9PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IHNldmVyaXR5ID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl07IC8vIENBVCBJL0lJL0lJSSBvciBoaWdoL21lZGl1bS9sb3dcclxuICAgICAgY29uc3QgdnVsbklkID0gbWF0Y2hbM107XHJcbiAgICAgIGNvbnN0IHRpdGxlID0gbWF0Y2hbNF0udHJpbSgpO1xyXG4gICAgICBkZXRhaWxlZFJlcXMucHVzaCh7IHZ1bG5JZCwgc2V2ZXJpdHksIHRpdGxlIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhg8J+UjSBNZXRob2QgMTogRm91bmQgJHtkZXRhaWxlZFJlcXMubGVuZ3RofSByZXF1aXJlbWVudHMgd2l0aCBzZXZlcml0eSBpbmZvYCk7XHJcblxyXG4gICAgLy8gTWV0aG9kIDI6IEV4dHJhY3QgZnJvbSB0YWJsZSByb3dzIGlmIGF2YWlsYWJsZVxyXG4gICAgY29uc3QgdGFibGVSb3dzOiBBcnJheTx7dnVsbklkOiBzdHJpbmcsIHNldmVyaXR5OiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9PiA9IFtdO1xyXG4gICAgY29uc3Qgcm93UGF0dGVybiA9IC88dHJbXj5dKj4oW1xcc1xcU10qPyk8XFwvdHI+L2dpO1xyXG4gICAgbGV0IHJvd01hdGNoO1xyXG4gICAgXHJcbiAgICB3aGlsZSAoKHJvd01hdGNoID0gcm93UGF0dGVybi5leGVjKGh0bWwpKSAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCByb3dIdG1sID0gcm93TWF0Y2hbMV07XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHJvdyBoYXMgYSB2dWxuIElEXHJcbiAgICAgIGNvbnN0IHZ1bG5NYXRjaCA9IHJvd0h0bWwubWF0Y2goLz4oVi1cXGQrKTwvKTtcclxuICAgICAgaWYgKCF2dWxuTWF0Y2gpIGNvbnRpbnVlO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdnVsbklkID0gdnVsbk1hdGNoWzFdO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBzZXZlcml0eSBmcm9tIHRoaXMgcm93XHJcbiAgICAgIGNvbnN0IGNhdE1hdGNoID0gcm93SHRtbC5tYXRjaCgvQ0FUXFxzKyhJezEsM30pL2kpO1xyXG4gICAgICBjb25zdCBzZXZNYXRjaCA9IHJvd0h0bWwubWF0Y2goLz4oaGlnaHxtZWRpdW18bG93KTwvaSk7XHJcbiAgICAgIGNvbnN0IHNldmVyaXR5ID0gY2F0TWF0Y2ggPyBjYXRNYXRjaFsxXSA6IChzZXZNYXRjaCA/IHNldk1hdGNoWzFdIDogJ0lJJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IHRpdGxlXHJcbiAgICAgIGNvbnN0IHRpdGxlTWF0Y2ggPSByb3dIdG1sLm1hdGNoKC88YVtePl0qaHJlZj1cIlteXCJdKlxcL3JlcXVpcmVtZW50XFwvW15cIl0qXCJbXj5dKj4oW148XSspPC9pKTtcclxuICAgICAgY29uc3QgdGl0bGUgPSB0aXRsZU1hdGNoID8gdGl0bGVNYXRjaFsxXS50cmltKCkgOiBgUmVxdWlyZW1lbnQgJHt2dWxuSWR9YDtcclxuICAgICAgXHJcbiAgICAgIHRhYmxlUm93cy5wdXNoKHsgdnVsbklkLCBzZXZlcml0eSwgdGl0bGUgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGDwn5SNIE1ldGhvZCAyOiBGb3VuZCAke3RhYmxlUm93cy5sZW5ndGh9IHJlcXVpcmVtZW50cyBmcm9tIHRhYmxlIHJvd3NgKTtcclxuXHJcbiAgICAvLyBNZXRob2QgMzogRmFsbGJhY2sgLSBleHRyYWN0IGFsbCBWLSMjIyMgd2l0aCBkZWZhdWx0IGRhdGFcclxuICAgIGNvbnN0IHZ1bG5JZFBhdHRlcm4gPSAvVi1cXGQrL2c7XHJcbiAgICBjb25zdCBhbGxWdWxuSWRzID0gWy4uLm5ldyBTZXQoaHRtbC5tYXRjaCh2dWxuSWRQYXR0ZXJuKSB8fCBbXSldO1xyXG4gICAgY29uc29sZS5sb2coYPCflI0gTWV0aG9kIDM6IEZvdW5kICR7YWxsVnVsbklkcy5sZW5ndGh9IHRvdGFsIFYtIyMjIyBwYXR0ZXJuc2ApO1xyXG5cclxuICAgIC8vIFVzZSB0aGUgbWV0aG9kIHRoYXQgZm91bmQgdGhlIG1vc3QgcmVxdWlyZW1lbnRzXHJcbiAgICBsZXQgcmVxRGF0YTogQXJyYXk8e3Z1bG5JZDogc3RyaW5nLCBzZXZlcml0eTogc3RyaW5nLCB0aXRsZTogc3RyaW5nfT4gPSBbXTtcclxuICAgIFxyXG4gICAgaWYgKGRldGFpbGVkUmVxcy5sZW5ndGggPj0gdGFibGVSb3dzLmxlbmd0aCAmJiBkZXRhaWxlZFJlcXMubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXFEYXRhID0gZGV0YWlsZWRSZXFzO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyTIFVzaW5nIE1ldGhvZCAxOiAke2RldGFpbGVkUmVxcy5sZW5ndGh9IHJlcXVpcmVtZW50cyB3aXRoIHNldmVyaXR5YCk7XHJcbiAgICB9IGVsc2UgaWYgKHRhYmxlUm93cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHJlcURhdGEgPSB0YWJsZVJvd3M7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinJMgVXNpbmcgTWV0aG9kIDI6ICR7dGFibGVSb3dzLmxlbmd0aH0gcmVxdWlyZW1lbnRzIGZyb20gdGFibGVzYCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBGYWxsYmFjazogY3JlYXRlIGJhc2ljIGVudHJpZXNcclxuICAgICAgcmVxRGF0YSA9IGFsbFZ1bG5JZHMubWFwKHZ1bG5JZCA9PiAoe1xyXG4gICAgICAgIHZ1bG5JZCxcclxuICAgICAgICBzZXZlcml0eTogJ0lJJywgLy8gZGVmYXVsdFxyXG4gICAgICAgIHRpdGxlOiBgJHtzdGlnTmFtZX0gLSAke3Z1bG5JZH1gXHJcbiAgICAgIH0pKTtcclxuICAgICAgY29uc29sZS5sb2coYOKckyBVc2luZyBNZXRob2QgMzogJHthbGxWdWxuSWRzLmxlbmd0aH0gYmFzaWMgcmVxdWlyZW1lbnRzYCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5sb2coYPCfk50gUHJvY2Vzc2luZyAke3JlcURhdGEubGVuZ3RofSByZXF1aXJlbWVudHMuLi5gKTtcclxuXHJcbiAgICBsZXQgcmVxdWlyZW1lbnRDb3VudCA9IDA7XHJcbiAgICBcclxuICAgIGZvciAoY29uc3QgcmVxIG9mIHJlcURhdGEpIHtcclxuICAgICAgY29uc3QgeyB2dWxuSWQsIHNldmVyaXR5OiByYXdTZXZlcml0eSwgdGl0bGUgfSA9IHJlcTtcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgUnVsZSBJRCBpZiBhdmFpbGFibGVcclxuICAgICAgY29uc3QgcnVsZVBhdHRlcm4gPSBuZXcgUmVnRXhwKGAke3Z1bG5JZH1bXlNdKj8oU1YtXFxcXGQrclxcXFxkK19ydWxlKWAsICdpJyk7XHJcbiAgICAgIGNvbnN0IHJ1bGVNYXRjaCA9IGh0bWwubWF0Y2gocnVsZVBhdHRlcm4pO1xyXG4gICAgICBjb25zdCBydWxlSWQgPSBydWxlTWF0Y2ggPyBydWxlTWF0Y2hbMV0gOiBgJHt2dWxuSWR9LXJ1bGVgO1xyXG4gICAgICBcclxuICAgICAgLy8gTm9ybWFsaXplIHNldmVyaXR5XHJcbiAgICAgIGxldCBzZXZlcml0eTogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JyA9ICdtZWRpdW0nO1xyXG4gICAgICBjb25zdCBzZXZUZXh0ID0gcmF3U2V2ZXJpdHkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgaWYgKHNldlRleHQuaW5jbHVkZXMoJ2knKSAmJiAhc2V2VGV4dC5pbmNsdWRlcygnaWknKSB8fCBzZXZUZXh0ID09PSAnaGlnaCcgfHwgc2V2VGV4dCA9PT0gJzEnKSB7XHJcbiAgICAgICAgc2V2ZXJpdHkgPSAnaGlnaCc7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2V2VGV4dC5pbmNsdWRlcygnaWlpJykgfHwgc2V2VGV4dCA9PT0gJ2xvdycgfHwgc2V2VGV4dCA9PT0gJzMnKSB7XHJcbiAgICAgICAgc2V2ZXJpdHkgPSAnbG93JztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZXZlcml0eSA9ICdtZWRpdW0nO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBEZXNjcmlwdGlvbiBkZWZhdWx0cyB0byB0aXRsZVxyXG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRpdGxlO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBDQ0kgcmVmZXJlbmNlcyAtIHNlYXJjaCBmb3IgdGhpcyB2dWxuSWQgaW4gSFRNTFxyXG4gICAgICBjb25zdCB2dWxuQ29udGV4dCA9IGh0bWwuc3Vic3RyaW5nKFxyXG4gICAgICAgIE1hdGgubWF4KDAsIGh0bWwuaW5kZXhPZih2dWxuSWQpIC0gMzAwKSxcclxuICAgICAgICBNYXRoLm1pbihodG1sLmxlbmd0aCwgaHRtbC5pbmRleE9mKHZ1bG5JZCkgKyAzMDApXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IGNjaU1hdGNoZXMgPSB2dWxuQ29udGV4dC5tYXRjaCgvQ0NJLVxcZCsvZyk7XHJcbiAgICAgIGNvbnN0IGNjaSA9IGNjaU1hdGNoZXMgJiYgY2NpTWF0Y2hlcy5sZW5ndGggPiAwID8gWy4uLm5ldyBTZXQoY2NpTWF0Y2hlcyldIDogWydDQ0ktMDAwMzY2J107XHJcbiAgICAgIFxyXG4gICAgICAvLyBEZWZhdWx0IGNoZWNrIGFuZCBmaXggdGV4dCB3aXRoIG5vdGUgYWJvdXQgZnVsbCBkb2N1bWVudGF0aW9uXHJcbiAgICAgIGNvbnN0IGNoZWNrVGV4dCA9IGBSZXZpZXcgdGhlIHN5c3RlbSBjb25maWd1cmF0aW9uIHRvIHZlcmlmeSBjb21wbGlhbmNlIHdpdGggJHt2dWxuSWR9LiBSZWZlciB0byB0aGUgZnVsbCBTVElHIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbGVkIGNoZWNrIHByb2NlZHVyZXMuYDtcclxuICAgICAgY29uc3QgZml4VGV4dCA9IGBDb25maWd1cmUgdGhlIHN5c3RlbSB0byBtZWV0IHRoZSByZXF1aXJlbWVudHMgc3BlY2lmaWVkIGluICR7dnVsbklkfS4gUmVmZXIgdG8gdGhlIGZ1bGwgU1RJRyBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxlZCBmaXggcHJvY2VkdXJlcy5gO1xyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBOSVNUIGNvbnRyb2xzIGZyb20gY29udGV4dFxyXG4gICAgICBjb25zdCBuaXN0TWF0Y2hlcyA9IHZ1bG5Db250ZXh0Lm1hdGNoKC8oW0EtWl17Mn0tXFxkKyg/OlxccypcXChbYS16MC05XStcXCkpPykvZyk7XHJcbiAgICAgIGNvbnN0IG5pc3RDb250cm9scyA9IG5pc3RNYXRjaGVzID8gWy4uLm5ldyBTZXQobmlzdE1hdGNoZXMpXSA6IFtdO1xyXG4gICAgICBcclxuICAgICAgcmVxdWlyZW1lbnRzLnB1c2goe1xyXG4gICAgICAgIHZ1bG5JZCxcclxuICAgICAgICBydWxlSWQsXHJcbiAgICAgICAgc2V2ZXJpdHksXHJcbiAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgZGVzY3JpcHRpb24sXHJcbiAgICAgICAgY2hlY2tUZXh0LFxyXG4gICAgICAgIGZpeFRleHQsXHJcbiAgICAgICAgY2NpLFxyXG4gICAgICAgIG5pc3RDb250cm9sc1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHJlcXVpcmVtZW50Q291bnQrKztcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBwYXJzZWQgJHtyZXF1aXJlbWVudENvdW50fSByZXF1aXJlbWVudHMgZnJvbSBIVE1MYCk7XHJcbiAgICBcclxuICAgIC8vIExvZyBzZXZlcml0eSBkaXN0cmlidXRpb25cclxuICAgIGNvbnN0IHNldmVyaXR5RGlzdDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gICAgcmVxdWlyZW1lbnRzLmZvckVhY2gocmVxID0+IHtcclxuICAgICAgc2V2ZXJpdHlEaXN0W3JlcS5zZXZlcml0eV0gPSAoc2V2ZXJpdHlEaXN0W3JlcS5zZXZlcml0eV0gfHwgMCkgKyAxO1xyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZyhg8J+TiiBBUEkgU2V2ZXJpdHkgRGlzdHJpYnV0aW9uOmAsIHNldmVyaXR5RGlzdCk7XHJcblxyXG4gICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55IHJlcXVpcmVtZW50cyBpbiB0YWJsZSBmb3JtYXQsIHRyeSBhbHRlcm5hdGl2ZSBwYXJzaW5nXHJcbiAgICBpZiAocmVxdWlyZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyByZXF1aXJlbWVudHMgZm91bmQgaW4gdGFibGUgZm9ybWF0LCB0cnlpbmcgYWx0ZXJuYXRpdmUgcGFyc2luZy4uLicpO1xyXG4gICAgICBcclxuICAgICAgLy8gVHJ5IHRvIGZpbmQgYWxsIFYtIyMjIyBwYXR0ZXJucyBhbmQgY3JlYXRlIGJhc2ljIHJlcXVpcmVtZW50c1xyXG4gICAgICBjb25zdCB2dWxuSWRQYXR0ZXJuID0gL1YtXFxkKy9nO1xyXG4gICAgICBjb25zdCB2dWxuSWRzID0gWy4uLm5ldyBTZXQoaHRtbC5tYXRjaCh2dWxuSWRQYXR0ZXJuKSB8fCBbXSldO1xyXG4gICAgICBcclxuICAgICAgdnVsbklkcy5mb3JFYWNoKCh2dWxuSWQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgcmVxdWlyZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgdnVsbklkLFxyXG4gICAgICAgICAgcnVsZUlkOiBgJHt2dWxuSWR9LXJ1bGVgLFxyXG4gICAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxyXG4gICAgICAgICAgdGl0bGU6IGAke3N0aWdOYW1lfSAtICR7dnVsbklkfWAsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYFNlY3VyaXR5IHJlcXVpcmVtZW50ICR7dnVsbklkfSBmcm9tICR7c3RpZ05hbWV9YCxcclxuICAgICAgICAgIGNoZWNrVGV4dDogJ1JldmlldyB0aGUgc3lzdGVtIGNvbmZpZ3VyYXRpb24gdG8gdmVyaWZ5IGNvbXBsaWFuY2UuIERldGFpbGVkIGNoZWNrIHByb2NlZHVyZSBhdmFpbGFibGUgaW4gdGhlIGZ1bGwgU1RJRyBkb2N1bWVudGF0aW9uLicsXHJcbiAgICAgICAgICBmaXhUZXh0OiAnQ29uZmlndXJlIHRoZSBzeXN0ZW0gdG8gbWVldCB0aGUgc2VjdXJpdHkgcmVxdWlyZW1lbnQuIERldGFpbGVkIGZpeCBwcm9jZWR1cmUgYXZhaWxhYmxlIGluIHRoZSBmdWxsIFNUSUcgZG9jdW1lbnRhdGlvbi4nLFxyXG4gICAgICAgICAgY2NpOiBbJ0NDSS0wMDAzNjYnXSxcclxuICAgICAgICAgIG5pc3RDb250cm9sczogW11cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+TnSBDcmVhdGVkICR7cmVxdWlyZW1lbnRzLmxlbmd0aH0gYmFzaWMgcmVxdWlyZW1lbnRzIGZyb20gVnVsbiBJRHNgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGlnSWQsXHJcbiAgICAgIHN0aWdOYW1lLFxyXG4gICAgICB2ZXJzaW9uLFxyXG4gICAgICByZWxlYXNlRGF0ZSxcclxuICAgICAgcmVxdWlyZW1lbnRzLFxyXG4gICAgICB0b3RhbFJlcXVpcmVtZW50czogcmVxdWlyZW1lbnRzLmxlbmd0aFxyXG4gICAgfTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBzdGlndmlld2VyLmNvbSBIVE1MOicsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0aWd2aWV3ZXIuY29tIHBhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBYQ0NERiBYTUwgZmlsZSB0byBleHRyYWN0IFNUSUcgcmVxdWlyZW1lbnRzXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVhjY2RmWG1sKHhtbENvbnRlbnQ6IHN0cmluZywgZmlsZU5hbWU6IHN0cmluZyk6IE9taXQ8U3RpZ0ltcG9ydFJlc3VsdCwgJ3N1Y2Nlc3MnIHwgJ3NvdXJjZScgfCAnbWVzc2FnZSc+IHtcclxuICBjb25zdCByZXF1aXJlbWVudHM6IFN0aWdSZXF1aXJlbWVudFtdID0gW107XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBFeHRyYWN0IFNUSUcgSUQgZnJvbSBmaWxlbmFtZVxyXG4gICAgY29uc3Qgc3RpZ0lkID0gZmlsZU5hbWUucmVwbGFjZSgvXFwueG1sfFxcLnhjY2RmL2dpLCAnJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICdfJyk7XHJcblxyXG4gICAgLy8gUGFyc2UgWE1MIHVzaW5nIHJlZ2V4IChzaW1wbGlmaWVkIC0gaW4gcHJvZHVjdGlvbiB1c2UgYSBwcm9wZXIgWE1MIHBhcnNlcilcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBCZW5jaG1hcmsgdGl0bGVcclxuICAgIGNvbnN0IHRpdGxlTWF0Y2ggPSB4bWxDb250ZW50Lm1hdGNoKC88dGl0bGVbXj5dKj4oW148XSspPFxcL3RpdGxlPi9pKTtcclxuICAgIGNvbnN0IHN0aWdOYW1lID0gdGl0bGVNYXRjaCA/IHRpdGxlTWF0Y2hbMV0udHJpbSgpIDogc3RpZ0lkO1xyXG5cclxuICAgIC8vIEV4dHJhY3QgdmVyc2lvblxyXG4gICAgY29uc3QgdmVyc2lvbk1hdGNoID0geG1sQ29udGVudC5tYXRjaCgvPHZlcnNpb25bXj5dKj4oW148XSspPFxcL3ZlcnNpb24+L2kpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbENvbnRlbnQubWF0Y2goL1ZlcnNpb25bOlxcc10rKFtWdlJyXFxkLl0rKS9pKTtcclxuICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uTWF0Y2ggPyB2ZXJzaW9uTWF0Y2hbMV0gOiAnVW5rbm93bic7XHJcblxyXG4gICAgLy8gRXh0cmFjdCByZWxlYXNlIGRhdGVcclxuICAgIGNvbnN0IGRhdGVNYXRjaCA9IHhtbENvbnRlbnQubWF0Y2goL3JlbGVhc2UtZGF0ZVtePl0qPihbXjxdKyk8L2kpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIHhtbENvbnRlbnQubWF0Y2goLyhcXGR7MSwyfVxccytcXHcrXFxzK1xcZHs0fSkvKTtcclxuICAgIGNvbnN0IHJlbGVhc2VEYXRlID0gZGF0ZU1hdGNoID8gZGF0ZU1hdGNoWzFdIDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XHJcblxyXG4gICAgLy8gRXh0cmFjdCBhbGwgR3JvdXAgZWxlbWVudHMgKHJlcXVpcmVtZW50cylcclxuICAgIGNvbnN0IGdyb3VwUGF0dGVybiA9IC88R3JvdXBbXj5dKmlkPVwiKFteXCJdKylcIltePl0qPihbXFxzXFxTXSo/KTxcXC9Hcm91cD4vZ2k7XHJcbiAgICBsZXQgZ3JvdXBNYXRjaDtcclxuXHJcbiAgICB3aGlsZSAoKGdyb3VwTWF0Y2ggPSBncm91cFBhdHRlcm4uZXhlYyh4bWxDb250ZW50KSkgIT09IG51bGwpIHtcclxuICAgICAgY29uc3QgZ3JvdXBJZCA9IGdyb3VwTWF0Y2hbMV07XHJcbiAgICAgIGNvbnN0IGdyb3VwQ29udGVudCA9IGdyb3VwTWF0Y2hbMl07XHJcblxyXG4gICAgICAvLyBFeHRyYWN0IFJ1bGUgZnJvbSBHcm91cFxyXG4gICAgICBjb25zdCBydWxlTWF0Y2ggPSBncm91cENvbnRlbnQubWF0Y2goLzxSdWxlW14+XSppZD1cIihbXlwiXSspXCJbXj5dKnNldmVyaXR5PVwiKFteXCJdKylcIltePl0qPihbXFxzXFxTXSo/KTxcXC9SdWxlPi9pKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChydWxlTWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBydWxlSWQgPSBydWxlTWF0Y2hbMV07XHJcbiAgICAgICAgY29uc3Qgc2V2ZXJpdHkgPSBydWxlTWF0Y2hbMl0udG9Mb3dlckNhc2UoKSBhcyAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnO1xyXG4gICAgICAgIGNvbnN0IHJ1bGVDb250ZW50ID0gcnVsZU1hdGNoWzNdO1xyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IHRpdGxlXHJcbiAgICAgICAgY29uc3QgdGl0bGVNYXRjaCA9IHJ1bGVDb250ZW50Lm1hdGNoKC88dGl0bGVbXj5dKj4oW148XSspPFxcL3RpdGxlPi9pKTtcclxuICAgICAgICBjb25zdCB0aXRsZSA9IHRpdGxlTWF0Y2ggPyB0aXRsZU1hdGNoWzFdLnRyaW0oKSA6IGBSZXF1aXJlbWVudCAke2dyb3VwSWR9YDtcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBkZXNjcmlwdGlvblxyXG4gICAgICAgIGNvbnN0IGRlc2NNYXRjaCA9IHJ1bGVDb250ZW50Lm1hdGNoKC88ZGVzY3JpcHRpb25bXj5dKj4oW1xcc1xcU10qPyk8XFwvZGVzY3JpcHRpb24+L2kpO1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZGVzY01hdGNoID8gc3RyaXBIdG1sKGRlc2NNYXRjaFsxXSkgOiAnJztcclxuXHJcbiAgICAgICAgLy8gRXh0cmFjdCBjaGVjayB0ZXh0XHJcbiAgICAgICAgY29uc3QgY2hlY2tNYXRjaCA9IHJ1bGVDb250ZW50Lm1hdGNoKC88Y2hlY2stY29udGVudFtePl0qPihbXFxzXFxTXSo/KTxcXC9jaGVjay1jb250ZW50Pi9pKTtcclxuICAgICAgICBjb25zdCBjaGVja1RleHQgPSBjaGVja01hdGNoID8gc3RyaXBIdG1sKGNoZWNrTWF0Y2hbMV0pIDogJ05vIGNoZWNrIHByb2NlZHVyZSBwcm92aWRlZCc7XHJcblxyXG4gICAgICAgIC8vIEV4dHJhY3QgZml4IHRleHRcclxuICAgICAgICBjb25zdCBmaXhNYXRjaCA9IHJ1bGVDb250ZW50Lm1hdGNoKC88Zml4dGV4dFtePl0qPihbXFxzXFxTXSo/KTxcXC9maXh0ZXh0Pi9pKTtcclxuICAgICAgICBjb25zdCBmaXhUZXh0ID0gZml4TWF0Y2ggPyBzdHJpcEh0bWwoZml4TWF0Y2hbMV0pIDogJ05vIGZpeCBwcm9jZWR1cmUgcHJvdmlkZWQnO1xyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IENDSSByZWZlcmVuY2VzXHJcbiAgICAgICAgY29uc3QgY2NpUGF0dGVybiA9IC88aWRlbnRbXj5dKnN5c3RlbT1cImh0dHA6XFwvXFwvY3liZXJcXC5taWxcXC9sZWdhY3lcXC9jY2lcIltePl0qPihbXjxdKyk8XFwvaWRlbnQ+L2dpO1xyXG4gICAgICAgIGNvbnN0IGNjaTogc3RyaW5nW10gPSBbXTtcclxuICAgICAgICBsZXQgY2NpTWF0Y2g7XHJcbiAgICAgICAgd2hpbGUgKChjY2lNYXRjaCA9IGNjaVBhdHRlcm4uZXhlYyhydWxlQ29udGVudCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBjY2kucHVzaChjY2lNYXRjaFsxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeHRyYWN0IE5JU1QgY29udHJvbHNcclxuICAgICAgICBjb25zdCBuaXN0UGF0dGVybiA9IC88cmVmZXJlbmNlW14+XSo+KFtcXHNcXFNdKj8pTklTVFtePF0qKFtBLVpdezJ9LVxcZCsoPzpcXHMqXFwoXFxkK1xcKSk/KD86XFxzKlthLXpdKT8pW148XSooW1xcc1xcU10qPyk8XFwvcmVmZXJlbmNlPi9naTtcclxuICAgICAgICBjb25zdCBuaXN0Q29udHJvbHM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgbGV0IG5pc3RNYXRjaDtcclxuICAgICAgICB3aGlsZSAoKG5pc3RNYXRjaCA9IG5pc3RQYXR0ZXJuLmV4ZWMocnVsZUNvbnRlbnQpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgY29uc3QgY29udHJvbCA9IG5pc3RNYXRjaFsyXS50cmltKCk7XHJcbiAgICAgICAgICBpZiAoY29udHJvbCAmJiAhbmlzdENvbnRyb2xzLmluY2x1ZGVzKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgIG5pc3RDb250cm9scy5wdXNoKGNvbnRyb2wpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVxdWlyZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgdnVsbklkOiBncm91cElkLFxyXG4gICAgICAgICAgcnVsZUlkLFxyXG4gICAgICAgICAgc2V2ZXJpdHksXHJcbiAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbi5zdWJzdHJpbmcoMCwgNTAwKSwgLy8gTGltaXQgZGVzY3JpcHRpb24gbGVuZ3RoXHJcbiAgICAgICAgICBjaGVja1RleHQ6IGNoZWNrVGV4dC5zdWJzdHJpbmcoMCwgMTAwMCksXHJcbiAgICAgICAgICBmaXhUZXh0OiBmaXhUZXh0LnN1YnN0cmluZygwLCAxMDAwKSxcclxuICAgICAgICAgIGNjaTogY2NpLmxlbmd0aCA+IDAgPyBjY2kgOiBbJ0NDSS0wMDAwMDAnXSxcclxuICAgICAgICAgIG5pc3RDb250cm9sczogbmlzdENvbnRyb2xzLmxlbmd0aCA+IDAgPyBuaXN0Q29udHJvbHMgOiBbJ0FDLTEnXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlcXVpcmVtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXF1aXJlbWVudHMgZm91bmQgaW4gWE1MLiBUaGUgZmlsZSBtYXkgbm90IGJlIGEgdmFsaWQgWENDREYgU1RJRyBmaWxlLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0aWdJZCxcclxuICAgICAgc3RpZ05hbWUsXHJcbiAgICAgIHZlcnNpb24sXHJcbiAgICAgIHJlbGVhc2VEYXRlLFxyXG4gICAgICByZXF1aXJlbWVudHMsXHJcbiAgICAgIHRvdGFsUmVxdWlyZW1lbnRzOiByZXF1aXJlbWVudHMubGVuZ3RoXHJcbiAgICB9O1xyXG5cclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIFhDQ0RGIFhNTDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBYQ0NERiBYTUw6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdHJpcCBIVE1MIHRhZ3MgYW5kIGRlY29kZSBlbnRpdGllc1xyXG4gKi9cclxuZnVuY3Rpb24gc3RyaXBIdG1sKGh0bWw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGh0bWxcclxuICAgIC5yZXBsYWNlKC88W14+XSs+L2csICcnKSAvLyBSZW1vdmUgSFRNTCB0YWdzXHJcbiAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpXHJcbiAgICAucmVwbGFjZSgvJmd0Oy9nLCAnPicpXHJcbiAgICAucmVwbGFjZSgvJmFtcDsvZywgJyYnKVxyXG4gICAgLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKVxyXG4gICAgLnJlcGxhY2UoLyYjMzk7L2csIFwiJ1wiKVxyXG4gICAgLnJlcGxhY2UoLyZuYnNwOy9nLCAnICcpXHJcbiAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIE5vcm1hbGl6ZSB3aGl0ZXNwYWNlXHJcbiAgICAudHJpbSgpO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJodHRwcyIsIkdFVCIsInJlcXVlc3QiLCJzZWFyY2hQYXJhbXMiLCJVUkwiLCJ1cmwiLCJzdGlnSWQiLCJnZXQiLCJqc29uIiwiZXJyb3IiLCJzdGF0dXMiLCJjb25zb2xlIiwibG9nIiwianNvblVybCIsImh0bWxVcmwiLCJhZ2VudCIsIkFnZW50IiwicmVqZWN0VW5hdXRob3JpemVkIiwianNvblJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJ0aW1lb3V0Iiwib2siLCJqc29uRGF0YSIsInN0aWdEYXRhIiwicGFyc2VTdGlnVmlld2VySnNvbiIsInJlcXVpcmVtZW50cyIsImxlbmd0aCIsInN1Y2Nlc3MiLCJzb3VyY2UiLCJtZXNzYWdlIiwic3RhdHVzVGV4dCIsImpzb25FcnJvciIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInJlc3BvbnNlIiwiRXJyb3IiLCJodG1sIiwidGV4dCIsInBhcnNlU3RpZ1ZpZXdlckh0bWwiLCJmZXRjaEVycm9yIiwiZXJyb3JHdWlkYW5jZSIsImluY2x1ZGVzIiwiaW5zdHJ1Y3Rpb25zIiwic3RlcDEiLCJzdGVwMiIsInN0ZXAzIiwicGFyc2VTdGlnQ3N2IiwiY3N2Q29udGVudCIsImZpbGVOYW1lIiwibGluZXMiLCJjdXJyZW50TGluZSIsImluc2lkZVF1b3RlcyIsImkiLCJjaGFyIiwibmV4dENoYXIiLCJ0cmltIiwicHVzaCIsInJlcGxhY2UiLCJzdGlnTmFtZSIsInZlcnNpb24iLCJyZWxlYXNlRGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwidG90YWxSZXF1aXJlbWVudHMiLCJwYXJzZUNTVkxpbmUiLCJsaW5lIiwicmVzdWx0IiwiY3VycmVudCIsImluUXVvdGVzIiwiaGVhZGVyTGluZUluZGV4IiwiTWF0aCIsIm1pbiIsInBhcnNlZExpbmUiLCJsaW5lVGV4dCIsImpvaW4iLCJ0b0xvd2VyQ2FzZSIsIm1hcCIsImgiLCJzbGljZSIsImdldEluZGV4IiwibmFtZXMiLCJuYW1lIiwiaWR4IiwiZmluZEluZGV4Iiwic3RpZ0lkSWR4Iiwic2V2ZXJpdHlJZHgiLCJ0aXRsZUlkeCIsImRpc2N1c3Npb25JZHgiLCJjaGVja0lkeCIsImZpeElkeCIsImNjaUlkeCIsInJ1bGVJZElkeCIsInNldmVyaXR5IiwidGl0bGUiLCJkaXNjdXNzaW9uIiwiY2hlY2siLCJmaXgiLCJjY2kiLCJydWxlSWQiLCJ2YWx1ZXMiLCJiZW5jaG1hcmtJZHgiLCJ2ZXJzaW9uSWR4IiwidnVsbklkIiwic2V2ZXJpdHlWYWx1ZSIsImNjaVRleHQiLCJjY2lNYXRjaGVzIiwibWF0Y2giLCJkZXNjcmlwdGlvbiIsImNoZWNrVGV4dCIsImZpeFRleHQiLCJuaXN0Q29udHJvbHMiLCJQT1NUIiwiZm9ybURhdGEiLCJmaWxlIiwiaXNYbWwiLCJlbmRzV2l0aCIsImlzQ3N2IiwiZmlsZUNvbnRlbnQiLCJwYXJzZVhjY2RmWG1sIiwiZmV0Y2hSZXF1aXJlbWVudERldGFpbHMiLCJjaGVja01hdGNoIiwiZml4TWF0Y2giLCJzdGlnIiwiZGF0ZSIsImZpbmRpbmdzIiwidnVsbklkcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiZmluZGluZyIsInNldlRleHQiLCJjYXQiLCJ0b1N0cmluZyIsInJ1bGVfaWQiLCJydWxlaWQiLCJydWxlVGl0bGUiLCJydWxldGl0bGUiLCJjaGVja3RleHQiLCJjaGVja190ZXh0IiwiZml4dGV4dCIsImZpeF90ZXh0IiwiY2NpcyIsIm5pc3QiLCJzZXZlcml0eURpc3QiLCJyZXEiLCJ0aXRsZU1hdGNoIiwidmVyc2lvbk1hdGNoIiwiZGF0ZU1hdGNoIiwicmVxU2VjdGlvblBhdHRlcm4iLCJkZXRhaWxlZFJlcXMiLCJleGVjIiwidGFibGVSb3dzIiwicm93UGF0dGVybiIsInJvd01hdGNoIiwicm93SHRtbCIsInZ1bG5NYXRjaCIsImNhdE1hdGNoIiwic2V2TWF0Y2giLCJ2dWxuSWRQYXR0ZXJuIiwiYWxsVnVsbklkcyIsIlNldCIsInJlcURhdGEiLCJyZXF1aXJlbWVudENvdW50IiwicmF3U2V2ZXJpdHkiLCJydWxlUGF0dGVybiIsIlJlZ0V4cCIsInJ1bGVNYXRjaCIsInZ1bG5Db250ZXh0Iiwic3Vic3RyaW5nIiwibWF4IiwiaW5kZXhPZiIsIm5pc3RNYXRjaGVzIiwid2FybiIsImluZGV4IiwieG1sQ29udGVudCIsImdyb3VwUGF0dGVybiIsImdyb3VwTWF0Y2giLCJncm91cElkIiwiZ3JvdXBDb250ZW50IiwicnVsZUNvbnRlbnQiLCJkZXNjTWF0Y2giLCJzdHJpcEh0bWwiLCJjY2lQYXR0ZXJuIiwiY2NpTWF0Y2giLCJuaXN0UGF0dGVybiIsIm5pc3RNYXRjaCIsImNvbnRyb2wiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/import-stig/route.ts\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/./node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/./node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var C_Users_ronni_OneDrive_Desktop_Projects_SRTM_tool_app_api_import_stig_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./app/api/import-stig/route.ts */ \"(rsc)/./app/api/import-stig/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/import-stig/route\",\n        pathname: \"/api/import-stig\",\n        filename: \"route\",\n        bundlePath: \"app/api/import-stig/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"C:\\\\Users\\\\ronni\\\\OneDrive\\\\Desktop\\\\Projects\\\\SRTM-tool\\\\app\\\\api\\\\import-stig\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_ronni_OneDrive_Desktop_Projects_SRTM_tool_app_api_import_stig_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/import-stig/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZpbXBvcnQtc3RpZyUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGaW1wb3J0LXN0aWclMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZpbXBvcnQtc3RpZyUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNyb25uaSU1Q09uZURyaXZlJTVDRGVza3RvcCU1Q1Byb2plY3RzJTVDU1JUTS10b29sJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1DJTNBJTVDVXNlcnMlNUNyb25uaSU1Q09uZURyaXZlJTVDRGVza3RvcCU1Q1Byb2plY3RzJTVDU1JUTS10b29sJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PXN0YW5kYWxvbmUmcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCZpc0dsb2JhbE5vdEZvdW5kRW5hYmxlZD0hIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ3FCO0FBQ2Q7QUFDUztBQUNPO0FBQ0s7QUFDbUM7QUFDakQ7QUFDTztBQUNmO0FBQ3NDO0FBQ3pCO0FBQ007QUFDQztBQUNoQjtBQUNvRDtBQUN0SDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhLE9BQW9DLElBQUksQ0FBRTtBQUN2RCx3QkFBd0IsTUFBdUM7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NkNBQTZDLDBGQUFxQjtBQUNsRTtBQUNBLGtCQUFrQiw2RUFBWTtBQUM5QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2RUFBNkUsZ0ZBQWM7QUFDM0YsaUNBQWlDLFFBQVEsRUFBRSxRQUFRO0FBQ25ELDBCQUEwQix1RUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTiw2QkFBNkIsNkZBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkZBQW1CO0FBQ3JEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZFQUFZO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCB7IGdldFJlcXVlc3RNZXRhIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcmVxdWVzdC1tZXRhXCI7XG5pbXBvcnQgeyBnZXRUcmFjZXIsIFNwYW5LaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3RyYWNlL3RyYWNlclwiO1xuaW1wb3J0IHsgbm9ybWFsaXplQXBwUGF0aCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYXBwLXBhdGhzXCI7XG5pbXBvcnQgeyBOb2RlTmV4dFJlcXVlc3QsIE5vZGVOZXh0UmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9iYXNlLWh0dHAvbm9kZVwiO1xuaW1wb3J0IHsgTmV4dFJlcXVlc3RBZGFwdGVyLCBzaWduYWxGcm9tTm9kZVJlc3BvbnNlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvd2ViL3NwZWMtZXh0ZW5zaW9uL2FkYXB0ZXJzL25leHQtcmVxdWVzdFwiO1xuaW1wb3J0IHsgQmFzZVNlcnZlclNwYW4gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBnZXRSZXZhbGlkYXRlUmVhc29uIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvaW5zdHJ1bWVudGF0aW9uL3V0aWxzXCI7XG5pbXBvcnQgeyBzZW5kUmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9zZW5kLXJlc3BvbnNlXCI7XG5pbXBvcnQgeyBmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMsIHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci93ZWIvdXRpbHNcIjtcbmltcG9ydCB7IGdldENhY2hlQ29udHJvbEhlYWRlciB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9jYWNoZS1jb250cm9sXCI7XG5pbXBvcnQgeyBJTkZJTklURV9DQUNIRSwgTkVYVF9DQUNIRV9UQUdTX0hFQURFUiB9IGZyb20gXCJuZXh0L2Rpc3QvbGliL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgTm9GYWxsYmFja0Vycm9yIH0gZnJvbSBcIm5leHQvZGlzdC9zaGFyZWQvbGliL25vLWZhbGxiYWNrLWVycm9yLmV4dGVybmFsXCI7XG5pbXBvcnQgeyBDYWNoZWRSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZXNwb25zZS1jYWNoZVwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIkM6XFxcXFVzZXJzXFxcXHJvbm5pXFxcXE9uZURyaXZlXFxcXERlc2t0b3BcXFxcUHJvamVjdHNcXFxcU1JUTS10b29sXFxcXGFwcFxcXFxhcGlcXFxcaW1wb3J0LXN0aWdcXFxccm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwic3RhbmRhbG9uZVwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9pbXBvcnQtc3RpZy9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2ltcG9ydC1zdGlnXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9pbXBvcnQtc3RpZy9yb3V0ZVwiXG4gICAgfSxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcmVsYXRpdmVQcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJycsXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJDOlxcXFxVc2Vyc1xcXFxyb25uaVxcXFxPbmVEcml2ZVxcXFxEZXNrdG9wXFxcXFByb2plY3RzXFxcXFNSVE0tdG9vbFxcXFxhcHBcXFxcYXBpXFxcXGltcG9ydC1zdGlnXFxcXHJvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICAgICAgd29ya1VuaXRBc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIHBhdGNoRmV0Y2gsICB9O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMsIGN0eCkge1xuICAgIHZhciBfbmV4dENvbmZpZ19leHBlcmltZW50YWw7XG4gICAgbGV0IHNyY1BhZ2UgPSBcIi9hcGkvaW1wb3J0LXN0aWcvcm91dGVcIjtcbiAgICAvLyB0dXJib3BhY2sgZG9lc24ndCBub3JtYWxpemUgYC9pbmRleGAgaW4gdGhlIHBhZ2UgbmFtZVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gdG8gcHJvY2VzcyBkeW5hbWljIHJvdXRlcyBwcm9wZXJseVxuICAgIC8vIFRPRE86IGZpeCB0dXJib3BhY2sgcHJvdmlkaW5nIGRpZmZlcmluZyB2YWx1ZSBmcm9tIHdlYnBhY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIHNyY1BhZ2UgPSBzcmNQYWdlLnJlcGxhY2UoL1xcL2luZGV4JC8sICcnKSB8fCAnLyc7XG4gICAgfSBlbHNlIGlmIChzcmNQYWdlID09PSAnL2luZGV4Jykge1xuICAgICAgICAvLyB3ZSBhbHdheXMgbm9ybWFsaXplIC9pbmRleCBzcGVjaWZpY2FsbHlcbiAgICAgICAgc3JjUGFnZSA9ICcvJztcbiAgICB9XG4gICAgY29uc3QgbXVsdGlab25lRHJhZnRNb2RlID0gcHJvY2Vzcy5lbnYuX19ORVhUX01VTFRJX1pPTkVfRFJBRlRfTU9ERTtcbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlLFxuICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGVcbiAgICB9KTtcbiAgICBpZiAoIXByZXBhcmVSZXN1bHQpIHtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgIHJlcy5lbmQoJ0JhZCBSZXF1ZXN0Jyk7XG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVpbGRJZCwgcGFyYW1zLCBuZXh0Q29uZmlnLCBpc0RyYWZ0TW9kZSwgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQsIGlzT25EZW1hbmRSZXZhbGlkYXRlLCByZXZhbGlkYXRlT25seUdlbmVyYXRlZCwgcmVzb2x2ZWRQYXRobmFtZSB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICBjb25zdCBub3JtYWxpemVkU3JjUGFnZSA9IG5vcm1hbGl6ZUFwcFBhdGgoc3JjUGFnZSk7XG4gICAgbGV0IGlzSXNyID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSB8fCBwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgIGlmIChpc0lzciAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY29uc3QgaXNQcmVyZW5kZXJlZCA9IEJvb2xlYW4ocHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW3Jlc29sdmVkUGF0aG5hbWVdKTtcbiAgICAgICAgY29uc3QgcHJlcmVuZGVySW5mbyA9IHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdO1xuICAgICAgICBpZiAocHJlcmVuZGVySW5mbykge1xuICAgICAgICAgICAgaWYgKHByZXJlbmRlckluZm8uZmFsbGJhY2sgPT09IGZhbHNlICYmICFpc1ByZXJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vRmFsbGJhY2tFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjYWNoZUtleSA9IG51bGw7XG4gICAgaWYgKGlzSXNyICYmICFyb3V0ZU1vZHVsZS5pc0RldiAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY2FjaGVLZXkgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAvLyBlbnN1cmUgL2luZGV4IGFuZCAvIGlzIG5vcm1hbGl6ZWQgdG8gb25lIGtleVxuICAgICAgICBjYWNoZUtleSA9IGNhY2hlS2V5ID09PSAnL2luZGV4JyA/ICcvJyA6IGNhY2hlS2V5O1xuICAgIH1cbiAgICBjb25zdCBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSA9IC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50LCB3ZSBhbHdheXMgc3VwcG9ydCBkeW5hbWljIEhUTUxcbiAgICByb3V0ZU1vZHVsZS5pc0RldiA9PT0gdHJ1ZSB8fCAvLyBJZiB0aGlzIGlzIG5vdCBTU0cgb3IgZG9lcyBub3QgaGF2ZSBzdGF0aWMgcGF0aHMsIHRoZW4gaXQgc3VwcG9ydHNcbiAgICAvLyBkeW5hbWljIEhUTUwuXG4gICAgIWlzSXNyO1xuICAgIC8vIFRoaXMgaXMgYSByZXZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWNcbiAgICAvLyBwYWdlIGFuZCBpdCBpcyBub3QgYmVpbmcgcmVzdW1lZCBmcm9tIGEgcG9zdHBvbmVkIHJlbmRlciBhbmRcbiAgICAvLyBpdCBpcyBub3QgYSBkeW5hbWljIFJTQyByZXF1ZXN0IHRoZW4gaXQgaXMgYSByZXZhbGlkYXRpb25cbiAgICAvLyByZXF1ZXN0LlxuICAgIGNvbnN0IGlzUmV2YWxpZGF0ZSA9IGlzSXNyICYmICFzdXBwb3J0c0R5bmFtaWNSZXNwb25zZTtcbiAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsOiB7XG4gICAgICAgICAgICAgICAgY2FjaGVDb21wb25lbnRzOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmNhY2hlQ29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgYXV0aEludGVycnVwdHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuYXV0aEludGVycnVwdHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2UsXG4gICAgICAgICAgICBpbmNyZW1lbnRhbENhY2hlOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbmNyZW1lbnRhbENhY2hlJyksXG4gICAgICAgICAgICBjYWNoZUxpZmVQcm9maWxlczogKF9uZXh0Q29uZmlnX2V4cGVyaW1lbnRhbCA9IG5leHRDb25maWcuZXhwZXJpbWVudGFsKSA9PSBudWxsID8gdm9pZCAwIDogX25leHRDb25maWdfZXhwZXJpbWVudGFsLmNhY2hlTGlmZSxcbiAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbCxcbiAgICAgICAgICAgIG9uQ2xvc2U6IChjYik9PntcbiAgICAgICAgICAgICAgICByZXMub24oJ2Nsb3NlJywgY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQWZ0ZXJUYXNrRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uSW5zdHJ1bWVudGF0aW9uUmVxdWVzdEVycm9yOiAoZXJyb3IsIF9yZXF1ZXN0LCBlcnJvckNvbnRleHQpPT5yb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVycm9yLCBlcnJvckNvbnRleHQsIHJvdXRlclNlcnZlckNvbnRleHQpXG4gICAgICAgIH0sXG4gICAgICAgIHNoYXJlZENvbnRleHQ6IHtcbiAgICAgICAgICAgIGJ1aWxkSWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9kZU5leHRSZXEgPSBuZXcgTm9kZU5leHRSZXF1ZXN0KHJlcSk7XG4gICAgY29uc3Qgbm9kZU5leHRSZXMgPSBuZXcgTm9kZU5leHRSZXNwb25zZShyZXMpO1xuICAgIGNvbnN0IG5leHRSZXEgPSBOZXh0UmVxdWVzdEFkYXB0ZXIuZnJvbU5vZGVOZXh0UmVxdWVzdChub2RlTmV4dFJlcSwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZShyZXMpKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnZva2VSb3V0ZU1vZHVsZSA9IGFzeW5jIChzcGFuKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlTW9kdWxlLmhhbmRsZShuZXh0UmVxLCBjb250ZXh0KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gYXN5bmMgKGN1cnJlbnRTcGFuKT0+e1xuICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VHZW5lcmF0b3IgPSBhc3luYyAoeyBwcmV2aW91c0NhY2hlRW50cnkgfSk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiYgaXNPbkRlbWFuZFJldmFsaWRhdGUgJiYgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQgJiYgIXByZXZpb3VzQ2FjaGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbi1kZW1hbmQgcmV2YWxpZGF0ZSBhbHdheXMgc2V0cyB0aGlzIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCAnUkVWQUxJREFURUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW52b2tlUm91dGVNb2R1bGUoY3VycmVudFNwYW4pO1xuICAgICAgICAgICAgICAgICAgICByZXEuZmV0Y2hNZXRyaWNzID0gY29udGV4dC5yZW5kZXJPcHRzLmZldGNoTWV0cmljcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlbmRpbmdXYWl0VW50aWwgPSBjb250ZXh0LnJlbmRlck9wdHMucGVuZGluZ1dhaXRVbnRpbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB1c2luZyBwcm92aWRlZCB3YWl0VW50aWwgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHdlIGZhbGxiYWNrIHRvIHNlbmRSZXNwb25zZSdzIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nV2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LndhaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC53YWl0VW50aWwocGVuZGluZ1dhaXRVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dhaXRVbnRpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZVRhZ3MgPSBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkVGFncztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgZm9yIGEgc3RhdGljIHJlc3BvbnNlLCB3ZSBjYW4gY2FjaGUgaXQgc28gbG9uZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIG5vdCBlZGdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJc3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBoZWFkZXJzIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tORVhUX0NBQ0hFX1RBR1NfSEVBREVSXSA9IGNhY2hlVGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyc1snY29udGVudC10eXBlJ10gJiYgYmxvYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBibG9iLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gdHlwZW9mIGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZSA+PSBJTkZJTklURV9DQUNIRSA/IGZhbHNlIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA+PSBJTkZJTklURV9DQUNIRSA/IHVuZGVmaW5lZCA6IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRFeHBpcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNhY2hlIGVudHJ5IGZvciB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBCdWZmZXIuZnJvbShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCByZXNwb25zZSB3aXRob3V0IGNhY2hpbmcgaWYgbm90IElTUlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VuZFJlc3BvbnNlKG5vZGVOZXh0UmVxLCBub2RlTmV4dFJlcywgcmVzcG9uc2UsIGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBiYWNrZ3JvdW5kIHJldmFsaWRhdGUgd2UgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgZXJyb3IgaGVyZSBhcyBpdCB3b24ndCBiZSBidWJibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NhY2hlRW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzQ2FjaGVFbnRyeS5pc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVyciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcktpbmQ6ICdBcHAgUm91dGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVBhdGg6IHNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJvdXRlclNlcnZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGF3YWl0IHJvdXRlTW9kdWxlLmhhbmRsZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlR2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjcmVhdGUgYSBjYWNoZUVudHJ5IGZvciBJU1JcbiAgICAgICAgICAgIGlmICghaXNJc3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlLmtpbmQpICE9PSBDYWNoZWRSb3V0ZUtpbmQuQVBQX1JPVVRFKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlMTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhcmlhbnQ6IGFwcC1yb3V0ZSByZWNlaXZlZCBpbnZhbGlkIGNhY2hlIGVudHJ5ICR7Y2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlMSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZTEua2luZH1gKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU3MDFcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCBpc09uRGVtYW5kUmV2YWxpZGF0ZSA/ICdSRVZBTElEQVRFRCcgOiBjYWNoZUVudHJ5LmlzTWlzcyA/ICdNSVNTJyA6IGNhY2hlRW50cnkuaXNTdGFsZSA/ICdTVEFMRScgOiAnSElUJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcmFmdCBtb2RlIHNob3VsZCBuZXZlciBiZSBjYWNoZWRcbiAgICAgICAgICAgIGlmIChpc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCAncHJpdmF0ZSwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtYXgtYWdlPTAsIG11c3QtcmV2YWxpZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhjYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKCEoZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc0lzcikpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmRlbGV0ZShORVhUX0NBQ0hFX1RBR1NfSEVBREVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGNhY2hlIGNvbnRyb2wgaXMgYWxyZWFkeSBzZXQgb24gdGhlIHJlc3BvbnNlIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBvdmVycmlkZSBpdCB0byBhbGxvdyB1c2VycyB0byBjdXN0b21pemUgaXQgdmlhIG5leHQuY29uZmlnXG4gICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wgJiYgIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSAmJiAhaGVhZGVycy5nZXQoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdDYWNoZS1Db250cm9sJywgZ2V0Q2FjaGVDb250cm9sSGVhZGVyKGNhY2hlRW50cnkuY2FjaGVDb250cm9sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UoY2FjaGVFbnRyeS52YWx1ZS5ib2R5LCB7XG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlRW50cnkudmFsdWUuc3RhdHVzIHx8IDIwMFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVSZXNwb25zZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVSZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIE5vRmFsbGJhY2tFcnJvcikpIHtcbiAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogbm9ybWFsaXplZFNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldGhyb3cgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHNlcnZpbmcgZXJyb3IgcGFnZVxuICAgICAgICAvLyBJZiB0aGlzIGlzIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbiwgdGhyb3cgdGhlIGVycm9yIGFnYWluLlxuICAgICAgICBpZiAoaXNJc3IpIHRocm93IGVycjtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZW5kIGEgNTAwIHJlc3BvbnNlLlxuICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fimport-stig%2Froute&page=%2Fapi%2Fimport-stig%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fimport-stig%2Froute.ts&appDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cronni%5COneDrive%5CDesktop%5CProjects%5CSRTM-tool&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();